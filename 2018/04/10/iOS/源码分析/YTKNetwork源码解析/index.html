<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">

<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">


  <link rel="manifest" href="/images/manifest.json">


  <meta name="msapplication-config" content="/images/browserconfig.xml" />



  <meta name="keywords" content="iOS,Objective-C,源码解析," />





  <link rel="alternate" href="/atom.xml" title="liuxc的博客" type="application/atom+xml" />






<meta name="description" content="作为一名iOS开发工作者，大家应该都听过YTKNetwork框架吧。它是猿题库技术团队开源的一个网络请求框架，内部封装了AFNetworking。它把每个请求实例化，管理它的生命周期，也可以管理多个请求。 在正式讲解源码之前，我会先讲一下该框架所用的架构和设计模式。我总觉得对架构和设计有一定的了解的话，会有助于对源码的理解。 1. 架构 先上图：   在这里简单说明一下：  YTKNetwork框">
<meta name="keywords" content="iOS,Objective-C,源码解析">
<meta property="og:type" content="article">
<meta property="og:title" content="YTKNetwork源码解析">
<meta property="og:url" content="http://yoursite.com/2018/04/10/iOS/源码分析/YTKNetwork源码解析/index.html">
<meta property="og:site_name" content="liuxc的博客">
<meta property="og:description" content="作为一名iOS开发工作者，大家应该都听过YTKNetwork框架吧。它是猿题库技术团队开源的一个网络请求框架，内部封装了AFNetworking。它把每个请求实例化，管理它的生命周期，也可以管理多个请求。 在正式讲解源码之前，我会先讲一下该框架所用的架构和设计模式。我总觉得对架构和设计有一定的了解的话，会有助于对源码的理解。 1. 架构 先上图：   在这里简单说明一下：  YTKNetwork框">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/859001-054321f909402be5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/859001-c5c7e9ff32b2e647.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/859001-6c5f41fbe2993059.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/859001-eab27afc98b324bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2018-04-10T01:56:03.191Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="YTKNetwork源码解析">
<meta name="twitter:description" content="作为一名iOS开发工作者，大家应该都听过YTKNetwork框架吧。它是猿题库技术团队开源的一个网络请求框架，内部封装了AFNetworking。它把每个请求实例化，管理它的生命周期，也可以管理多个请求。 在正式讲解源码之前，我会先讲一下该框架所用的架构和设计模式。我总觉得对架构和设计有一定的了解的话，会有助于对源码的理解。 1. 架构 先上图：   在这里简单说明一下：  YTKNetwork框">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/859001-054321f909402be5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":true,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/04/10/iOS/源码分析/YTKNetwork源码解析/"/>





  <title>YTKNetwork源码解析 | liuxc的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">liuxc的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">每天进步一点点</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/10/iOS/源码分析/YTKNetwork源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="liuxc">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liuxc的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">YTKNetwork源码解析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-10T09:27:15+08:00">
                2018-04-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2018-04-10T09:56:03+08:00">
                2018-04-10
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/04/10/iOS/源码分析/YTKNetwork源码解析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/04/10/iOS/源码分析/YTKNetwork源码解析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  14,033
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  61
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>作为一名iOS开发工作者，大家应该都听过<a href="https://github.com/yuantiku/YTKNetwork" target="_blank" rel="noopener">YTKNetwork框架</a>吧。它是猿题库技术团队开源的一个网络请求框架，内部封装了AFNetworking。它把每个请求实例化，管理它的生命周期，也可以管理多个请求。</p>
<p>在正式讲解源码之前，我会先讲一下该框架所用的架构和设计模式。我总觉得对架构和设计有一定的了解的话，会有助于对源码的理解。</p>
<h2 id="1-架构"><a href="#1-架构" class="headerlink" title="1. 架构"></a>1. 架构</h2><hr>
<p>先上图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-054321f909402be5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<blockquote>
<p>在这里简单说明一下：</p>
<ol>
<li>YTKNetwork框架将每一个请求实例化，YTKBaseRequest是所有请求类的基类，YTKRequest是它的子类。所以如果我们想要发送一个请求，则需要创建并实例化一个继承于YTKRequest的自定义的请求类（CustomRequest）并发送请求。</li>
<li>YTKNetworkAgent是一个单例，负责管理所有的请求类（例如CustomRequest）。当CustomRequest发送请求以后，会把自己放在YTKNetworkAgent持有的一个字典里，让其管理自己。</li>
<li>我们说YTKNetwork封装了AFNetworking，实际上是YTKNetworkAgent封装了AFNetworking，由它负责AFNetworking请求的发送和AFNetworking的回调处理。所以如果我们想更换一个第三方网络请求库，就可以在这里更换一下。而YTKRequest更多的是只是负责缓存的处理。</li>
<li>YTKNetworkConfig与YTKPriviate的具体职能现在不做介绍，会在后文给出。</li>
</ol>
</blockquote>
<p>OK，现在我们知道了YTKNetwork中类与类之间的关系以及关键类的大致职能，接下来我会告诉你YTKNetwork为什么会采用这种关系来架构，以及采用这种架构会有什么好处。</p>
<h2 id="2-设计模式"><a href="#2-设计模式" class="headerlink" title="2. 设计模式"></a>2. 设计模式</h2><hr>
<p>YTKNetwork框架采用的设计模式是<strong>命令模式（Command Pattern）</strong>。</p>
<p>首先看一下命令模式的定义：</p>
<blockquote>
<p>命令模式将请求封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。<br>摘自：<a href="https://www.amazon.cn/Head-First设计模式-弗里曼/dp/B0011FBU34/ref=sr_1_1?ie=UTF8&amp;qid=1500104908&amp;sr=8-1&amp;keywords=head+first+设计模式" target="_blank" rel="noopener">《Head First 设计模式》</a></p>
</blockquote>
<p>看一下命令模式的类图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-c5c7e9ff32b2e647.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>图中英文的含义：</p>
<table>
<thead>
<tr>
<th>英文</th>
<th>中文</th>
</tr>
</thead>
<tbody>
<tr>
<td>Command</td>
<td>抽象命令类</td>
</tr>
<tr>
<td>ConcreteCommand</td>
<td>命令类的实现类（子类）</td>
</tr>
<tr>
<td>Invoker</td>
<td>调用者</td>
</tr>
<tr>
<td>Receiver</td>
<td>命令接收者（执行者)</td>
</tr>
<tr>
<td>Client</td>
<td>客户端</td>
</tr>
</tbody>
</table>
<p>详细介绍一下：</p>
<ol>
<li>命令模式的本质是对命令的封装，将发出命令的责任和执行命令的责任分割开。</li>
<li>命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。</li>
</ol>
<p>可能还是觉得有点抽象，在这里举一个<a href="https://www.amazon.cn/Head-First设计模式-弗里曼/dp/B0011FBU34/ref=sr_1_1?ie=UTF8&amp;qid=1500104908&amp;sr=8-1&amp;keywords=head+first+设计模式" target="_blank" rel="noopener">《Head First 设计模式》</a>里的例子，一个客人在餐厅点餐的过程：</p>
<ol>
<li>你将点的菜写在订单里，交给了服务员。</li>
<li>服务员将订单交给厨师。</li>
<li>厨师做好菜之后将做好的菜交给服务员。</li>
<li>最后服务员把菜递给你。</li>
</ol>
<p>在这里，命令就好比是订单，而你是命令的发起者。你的命令（订单）通过服务员（调用者）交给了命令的执行者（厨师）。<br>所以至于这道菜具体是谁做，怎么做，你是不知道的，你做的只是发出命令和接受结果。而且对于餐厅来说，厨师是可以随便换的，而你可能对此一无所知。反过来，厨师只需要好好把菜做好，至于是谁点的菜也不需要他考虑。</p>
<p>结合上面命令模式的类图以及餐厅点餐的例子，我们来理清一下<code>YTKNetwork</code>内部的职能</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>Command</th>
<th>ConcreteCommand</th>
<th>Invoker</th>
<th>Receiver</th>
<th>Client</th>
</tr>
</thead>
<tbody>
<tr>
<td>餐厅</td>
<td>空白订单</td>
<td>填入菜名的订单</td>
<td>服务员</td>
<td>厨师</td>
<td>客人</td>
</tr>
<tr>
<td>YTKNetwork</td>
<td>YTKBaseRequest</td>
<td>CustomRequest</td>
<td>YTKNetworkAgent</td>
<td>AFNetworking</td>
<td>ViewController/ViewModel</td>
</tr>
</tbody>
</table>
<p>可以看到，YTKNetwork对命令模式的实现是很符合其设计标准的，它将请求的发起者和接收者分离开来(中间隔着调用者)，可以让我们随时更换接受者。</p>
<p>另外，因为封装了请求，我们既可以管理单个请求，也可以同时管理多个请求，甚至实现琏式请求的发送。关于多个请求的发送，我们也可以想象在餐厅里，你可以在吃的过程中还想起来要吃别的东西，例如点心，饮料之类的，你就可以填多个订单（当然也可以写在一起）交给服务员。</p>
<p>相信到这里，大家应该对YTKNetwork的设计与架构有了足够的认识了，下面进入到真正的源码解析，我们结合一下它的代码来看一下YTKNetwork是如何实现和管理网络请求的。</p>
<h2 id="3-源码解析"><a href="#3-源码解析" class="headerlink" title="3. 源码解析"></a>3. 源码解析</h2><hr>
<p>在真正讲解源码之前，我先详细说一下各个类的职责:</p>
<h3 id="3-1-责任介绍"><a href="#3-1-责任介绍" class="headerlink" title="3.1 责任介绍"></a>3.1 责任介绍</h3><table>
<thead>
<tr>
<th>类名</th>
<th>职责</th>
</tr>
</thead>
<tbody>
<tr>
<td>YTKBaseRequest</td>
<td>所有请求类的基类。持有NSURLSessionTask实例，responseData，responseObject，error等重要数据，提供一些需要子类实现的与网络请求相关的方法，处理回调的代理和block，命令YTKNetworkAgent发起网络请求。</td>
</tr>
<tr>
<td>YTKRequest</td>
<td>YTKBaseRequest的子类。负责缓存的处理：请求前查询缓存；请求后写入缓存。</td>
</tr>
<tr>
<td>YTKNetworkConfig</td>
<td>被YTKRequest和YTKNetworkAgent访问。负责所有请求的全局配置，例如baseUrl和CDNUrl等等。</td>
</tr>
<tr>
<td>YTKNetworkPrivate</td>
<td>提供JSON验证，appVersion等辅助性的方法；给YTKBaseRequest增加一些分类。</td>
</tr>
<tr>
<td>YTKNetworkAgent</td>
<td>真正发起请求的类。负责发起请求，结束请求，并持有一个字典来存储正在执行的请求。</td>
</tr>
<tr>
<td>YTKBatchRequest</td>
<td>可以发起批量请求，持有一个数组来保存所有的请求类。在请求执行后遍历这个数组来发起请求，如果其中有一个请求返回失败，则认定本组请求失败。</td>
</tr>
<tr>
<td>YTKBatchRequestAgent</td>
<td>负责管理多个YTKBatchRequest实例，持有一个数组来保存YTKBatchRequest。支持添加和删除YTKBatchRequest实例。</td>
</tr>
<tr>
<td>YTKChainRequest</td>
<td>可以发起链式请求，持有一个数组来保存所有的请求类。当某个请求结束后才能发起下一个请求，如果其中有一个请求返回失败，则认定本请求链失败。</td>
</tr>
<tr>
<td>YTKChainRequestAgent</td>
<td>负责管理多个YTKChainRequestAgent实例，持有一个数组来保存YTKChainRequest。支持添加和删除YTKChainRequest实例。</td>
</tr>
</tbody>
</table>
<p>OK，现在知道了YTKNetwork内部的责任分配，下面我们先从单个请求的全部流程（配置，发起，结束）来看一下YTKNetwork都做了什么。</p>
<h3 id="3-2-单个请求"><a href="#3-2-单个请求" class="headerlink" title="3.2 单个请求"></a>3.2 单个请求</h3><h4 id="3-21-单个请求的配置"><a href="#3-21-单个请求的配置" class="headerlink" title="3.21 单个请求的配置"></a>3.21 单个请求的配置</h4><p><a href="https://github.com/yuantiku/YTKNetwork/blob/master/Docs/BasicGuide_cn.md" target="_blank" rel="noopener">官方的教程</a>建议我们将请求的全局配置是在AppDelegate.m文件里，设定baseUrl以及cdnUrl等参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application </span><br><span class="line">   didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">   YTKNetworkConfig *config = [YTKNetworkConfig sharedConfig];</span><br><span class="line">   config.baseUrl = @&quot;http://yuantiku.com&quot;;</span><br><span class="line">   config.cdnUrl = @&quot;http://fen.bi&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们需要新建一个注册的请求，则需要创建一个继承于YTKRequest的注册接口的类RegisterApi，并将针对该请求参数配置好：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// RegisterApi.h</span><br><span class="line">#import &quot;YTKRequest.h&quot;</span><br><span class="line">@interface RegisterApi : YTKRequest</span><br><span class="line">- (id)initWithUsername:(NSString *)username password:(NSString *)password;</span><br><span class="line">@end</span><br><span class="line">// RegisterApi.m</span><br><span class="line">#import &quot;RegisterApi.h&quot;</span><br><span class="line">@implementation RegisterApi &#123;</span><br><span class="line">    NSString *_username;</span><br><span class="line">    NSString *_password;</span><br><span class="line">&#125;</span><br><span class="line">//初始化的时候将两个参数值传入</span><br><span class="line">- (id)initWithUsername:(NSString *)username password:(NSString *)password &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _username = username;</span><br><span class="line">        _password = password;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">//需要和baseUrl拼接的地址</span><br><span class="line">- (NSString *)requestUrl &#123;</span><br><span class="line">    // “ http://www.yuantiku.com ” 在 YTKNetworkConfig 中设置，这里只填除去域名剩余的网址信息</span><br><span class="line">    return @&quot;/iphone/register&quot;;</span><br><span class="line">&#125;</span><br><span class="line">//请求方法，某人是GET</span><br><span class="line">- (YTKRequestMethod)requestMethod &#123;</span><br><span class="line">    return YTKRequestMethodPOST;</span><br><span class="line">&#125;</span><br><span class="line">//请求体</span><br><span class="line">- (id)requestArgument &#123;</span><br><span class="line">    return @&#123;</span><br><span class="line">        @&quot;username&quot;: _username,</span><br><span class="line">        @&quot;password&quot;: _password</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>现在我们知道如何配置全局的参数和针对某个请求的参数了，接下来看一下单个请求是如何发起的。</p>
<h3 id="3-22-单个请求的发起"><a href="#3-22-单个请求的发起" class="headerlink" title="3.22 单个请求的发起"></a>3.22 单个请求的发起</h3><p>还是刚才的注册API，在实例化以后，直接调用<code>startWithCompletionBlockWithSuccess:failure</code>方法（或<code>start</code>方法）就可以发起它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//LoginViewController.m</span><br><span class="line">- (void)loginButtonPressed:(id)sender &#123;</span><br><span class="line">    NSString *username = self.UserNameTextField.text;</span><br><span class="line">    NSString *password = self.PasswordTextField.text;</span><br><span class="line">    if (username.length &gt; 0 &amp;&amp; password.length &gt; 0) &#123;</span><br><span class="line">        RegisterApi *api = [[RegisterApi alloc] initWithUsername:username password:password];</span><br><span class="line">        [api startWithCompletionBlockWithSuccess:^(YTKBaseRequest *request) &#123;</span><br><span class="line">            // 你可以直接在这里使用 self</span><br><span class="line">            NSLog(@&quot;succeed&quot;);</span><br><span class="line">        &#125; failure:^(YTKBaseRequest *request) &#123;</span><br><span class="line">            // 你可以直接在这里使用 self</span><br><span class="line">            NSLog(@&quot;failed&quot;);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是以block的形式回调，YTKNetwork也支持代理的回调：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//LoginViewController.m</span><br><span class="line">- (void)loginButtonPressed:(id)sender &#123;</span><br><span class="line">    NSString *username = self.UserNameTextField.text;</span><br><span class="line">    NSString *password = self.PasswordTextField.text;</span><br><span class="line">    if (username.length &gt; 0 &amp;&amp; password.length &gt; 0) &#123;</span><br><span class="line">        RegisterApi *api = [[RegisterApi alloc] initWithUsername:username password:password];</span><br><span class="line">        api.delegate = self;</span><br><span class="line">        [api start];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (void)requestFinished:(YTKBaseRequest *)request &#123;</span><br><span class="line">    NSLog(@&quot;succeed&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)requestFailed:(YTKBaseRequest *)request &#123;</span><br><span class="line">    NSLog(@&quot;failed&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有两点需要注意的是：</p>
<blockquote>
<ol>
<li>必须给自定义请求类（RegisterApi）调用<code>startWithCompletionBlockWithSuccess:failure</code>方法（或<code>start</code>方法），才能真正发起请求。</li>
<li>在同时设置了回调代理和回调block的情况下，首先回调的是回调代理方法，然后再走回调block。</li>
</ol>
</blockquote>
<p>知道了YTKRequest请求是如何在外部发起的，我们现在从<code>startWithCompletionBlockWithSuccess:failure</code>方法开始，来看一下YTKNetwork都做了什么：</p>
<p>首先来到YTKBaseRequest类（因为最早是由它定义的该方法）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//YTKBaseRequest.m</span><br><span class="line">//传入成功和失败的block,并保存起来</span><br><span class="line">- (void)startWithCompletionBlockWithSuccess:(YTKRequestCompletionBlock)success</span><br><span class="line">                                    failure:(YTKRequestCompletionBlock)failure &#123;</span><br><span class="line">    //保存成功和失败的回调block，便于将来调用</span><br><span class="line">    [self setCompletionBlockWithSuccess:success failure:failure];</span><br><span class="line">    //发起请求</span><br><span class="line">    [self start];</span><br><span class="line">&#125;</span><br><span class="line">//保存成功和失败的block</span><br><span class="line">- (void)setCompletionBlockWithSuccess:(YTKRequestCompletionBlock)success</span><br><span class="line">                              failure:(YTKRequestCompletionBlock)failure &#123;</span><br><span class="line">    self.successCompletionBlock = success;</span><br><span class="line">    self.failureCompletionBlock = failure;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当保存完成功和失败的block以后，调用<code>start</code>方法，于是来到了YTKRequest类（注意，虽然YTKBaseRequest也实现了<code>start</code>方法，但是由于YTKRequest类是它的子类并也实现了start方法，所以这里最先走的是YTKRequest类的<code>start</code>方法）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">//YTKRequest.m</span><br><span class="line">- (void)start &#123;</span><br><span class="line">    </span><br><span class="line">    //1. 如果忽略缓存 -&gt; 请求</span><br><span class="line">    if (self.ignoreCache) &#123;</span><br><span class="line">        [self startWithoutCache];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //2. 如果存在下载未完成的文件 -&gt; 请求</span><br><span class="line">    if (self.resumableDownloadPath) &#123;</span><br><span class="line">        [self startWithoutCache];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //3. 获取缓存失败 -&gt; 请求</span><br><span class="line">    if (![self loadCacheWithError:nil]) &#123;</span><br><span class="line">        [self startWithoutCache];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //4. 到这里，说明一定能拿到可用的缓存，可以直接回调了（因为一定能拿到可用的缓存，所以一定是调用成功的block和代理）</span><br><span class="line">    _dataFromCache = YES;</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        </span><br><span class="line">        //5. 回调之前的操作</span><br><span class="line">        //5.1 缓存处理</span><br><span class="line">        [self requestCompletePreprocessor];</span><br><span class="line">        </span><br><span class="line">        //5.2 用户可以在这里进行真正回调前的操作</span><br><span class="line">        [self requestCompleteFilter];</span><br><span class="line">        </span><br><span class="line">        YTKRequest *strongSelf = self;</span><br><span class="line">        </span><br><span class="line">        //6. 执行回调</span><br><span class="line">        //6.1 请求完成的代理</span><br><span class="line">        [strongSelf.delegate requestFinished:strongSelf];</span><br><span class="line">        </span><br><span class="line">        //6.2 请求成功的block</span><br><span class="line">        if (strongSelf.successCompletionBlock) &#123;</span><br><span class="line">            strongSelf.successCompletionBlock(strongSelf);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //7. 把成功和失败的block都设置为nil，避免循环引用</span><br><span class="line">        [strongSelf clearCompletionBlock];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们之前说过YTKRequest负责缓存的相关处理，所以在上面这个start方法里，它做的是请求之前缓存的查询和检查工作:</p>
<ul>
<li>如果忽略缓存，或者缓存获取失败，调用startWithoutCache方法（参考1-3的情况），发起请求。</li>
<li>如果能成功获取到缓存，则直接回调（参考4-7的情况）。</li>
</ul>
<p>我们来看一下每一步的具体实现：</p>
<ol>
<li><code>ignoreCache</code>属性是用户手动设置的，如果用户强制忽略缓存，则无论是否缓存是否存在，直接发送请求。</li>
<li><code>resumableDownloadPath</code>是断点下载路径，如果该路径不为空，说明有未完成的下载任务，则直接发送请求继续下载。</li>
<li><code>loadCacheWithError：</code>方法验证了加载缓存是否成功的方法（返回值为YES，说明可以加载缓存；反之亦然），看一下具体实现：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//YTKRequest.m</span><br><span class="line">- (BOOL)loadCacheWithError:(NSError * _Nullable __autoreleasing *)error &#123;</span><br><span class="line">    </span><br><span class="line">    // 缓存时间小于0，则返回（缓存时间默认为-1，需要用户手动设置，单位是秒）</span><br><span class="line">    if ([self cacheTimeInSeconds] &lt; 0) &#123;</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            *error = [NSError errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorInvalidCacheTime userInfo:@&#123; NSLocalizedDescriptionKey:@&quot;Invalid cache time&quot;&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    // 是否有缓存的元数据，如果没有，返回错误</span><br><span class="line">    if (![self loadCacheMetadata]) &#123;</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            *error = [NSError errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorInvalidMetadata userInfo:@&#123; NSLocalizedDescriptionKey:@&quot;Invalid metadata. Cache may not exist&quot;&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    // 有缓存，再验证是否有效</span><br><span class="line">    if (![self validateCacheWithError:error]) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    // 有缓存，而且有效，再验证是否能取出来</span><br><span class="line">    if (![self loadCacheData]) &#123;</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            *error = [NSError errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorInvalidCacheData userInfo:@&#123; NSLocalizedDescriptionKey:@&quot;Invalid cache data&quot;&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先讲一下什么是元数据：元数据是指数据的数据，在这里描述了缓存数据本身的一些特征：包括版本号，缓存时间，敏感信息等等， 稍后会做详细介绍。</p>
<p>我们来看一下上面关于缓存的元数据的获取方法：<code>loadCacheMetadata</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//YTKRequest.m</span><br><span class="line">- (BOOL)loadCacheMetadata &#123;</span><br><span class="line">    </span><br><span class="line">    NSString *path = [self cacheMetadataFilePath];</span><br><span class="line">    NSFileManager * fileManager = [NSFileManager defaultManager];</span><br><span class="line">    if ([fileManager fileExistsAtPath:path isDirectory:nil]) &#123;</span><br><span class="line">        @try &#123;</span><br><span class="line">            //将序列化之后被保存在磁盘里的文件反序列化到当前对象的属性cacheMetadata</span><br><span class="line">            _cacheMetadata = [NSKeyedUnarchiver unarchiveObjectWithFile:path];</span><br><span class="line">            return YES;</span><br><span class="line">        &#125; @catch (NSException *exception) &#123;</span><br><span class="line">            YTKLog(@&quot;Load cache metadata failed, reason = %@&quot;, exception.reason);</span><br><span class="line">            return NO;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>cacheMetadata（YTKCacheMetadata） 是当前reqeust类用来保存缓存元数据的属性。</p>
<p>YTKCacheMetadata类被定义在YTKRequest.m文件里面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//YTKRequest.m</span><br><span class="line">@interface YTKCacheMetadata : NSObject&lt;NSSecureCoding&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) long long version;</span><br><span class="line">@property (nonatomic, strong) NSString *sensitiveDataString;</span><br><span class="line">@property (nonatomic, assign) NSStringEncoding stringEncoding;</span><br><span class="line">@property (nonatomic, strong) NSDate *creationDate;</span><br><span class="line">@property (nonatomic, strong) NSString *appVersionString;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>它描述的是缓存的版本号，敏感信息，创建时间，app版本等信息，并支持序列化处理，可以保存在磁盘里。<br>因此，<code>loadCacheMetadata</code>方法的目的是将之前被序列化保存的缓存元数据信息反序列化，赋给自身的<code>cacheMetadata</code>属性上。</p>
<p>现在获取了缓存的元数据并赋给了自身的<code>cacheMetadata</code>属性上，那么接下来就要逐一验证元数据里的各项信息是否符合要求，在下面的<code>validateCacheWithError：</code>里面验证：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">//YTKRequest.m</span><br><span class="line">- (BOOL)validateCacheWithError:(NSError * _Nullable __autoreleasing *)error &#123;</span><br><span class="line">    </span><br><span class="line">    // 是否大于过期时间</span><br><span class="line">    NSDate *creationDate = self.cacheMetadata.creationDate;</span><br><span class="line">    NSTimeInterval duration = -[creationDate timeIntervalSinceNow];</span><br><span class="line">    if (duration &lt; 0 || duration &gt; [self cacheTimeInSeconds]) &#123;</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            *error = [NSError errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorExpired userInfo:@&#123; NSLocalizedDescriptionKey:@&quot;Cache expired&quot;&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    // 缓存的版本号是否符合</span><br><span class="line">    long long cacheVersionFileContent = self.cacheMetadata.version;</span><br><span class="line">    if (cacheVersionFileContent != [self cacheVersion]) &#123;</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            *error = [NSError errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorVersionMismatch userInfo:@&#123; NSLocalizedDescriptionKey:@&quot;Cache version mismatch&quot;&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 敏感信息是否符合</span><br><span class="line">    NSString *sensitiveDataString = self.cacheMetadata.sensitiveDataString;</span><br><span class="line">    NSString *currentSensitiveDataString = ((NSObject *)[self cacheSensitiveData]).description;</span><br><span class="line">    if (sensitiveDataString || currentSensitiveDataString) &#123;</span><br><span class="line">        // If one of the strings is nil, short-circuit evaluation will trigger</span><br><span class="line">        if (sensitiveDataString.length != currentSensitiveDataString.length || ![sensitiveDataString isEqualToString:currentSensitiveDataString]) &#123;</span><br><span class="line">            if (error) &#123;</span><br><span class="line">                *error = [NSError errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorSensitiveDataMismatch userInfo:@&#123; NSLocalizedDescriptionKey:@&quot;Cache sensitive data mismatch&quot;&#125;];</span><br><span class="line">            &#125;</span><br><span class="line">            return NO;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // app的版本是否符合</span><br><span class="line">    NSString *appVersionString = self.cacheMetadata.appVersionString;</span><br><span class="line">    NSString *currentAppVersionString = [YTKNetworkUtils appVersionString];</span><br><span class="line">    if (appVersionString || currentAppVersionString) &#123;</span><br><span class="line">        if (appVersionString.length != currentAppVersionString.length || ![appVersionString isEqualToString:currentAppVersionString]) &#123;</span><br><span class="line">            if (error) &#123;</span><br><span class="line">                *error = [NSError errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorAppVersionMismatch userInfo:@&#123; NSLocalizedDescriptionKey:@&quot;App version mismatch&quot;&#125;];</span><br><span class="line">            &#125;</span><br><span class="line">            return NO;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果每项元数据信息都能通过，再在<code>loadCacheData</code>方法里面验证缓存是否能被取出来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//YTKRequest.m</span><br><span class="line">- (BOOL)loadCacheData &#123;</span><br><span class="line">    </span><br><span class="line">    NSString *path = [self cacheFilePath];</span><br><span class="line">    NSFileManager *fileManager = [NSFileManager defaultManager];</span><br><span class="line">    NSError *error = nil;</span><br><span class="line">    if ([fileManager fileExistsAtPath:path isDirectory:nil]) &#123;</span><br><span class="line">        NSData *data = [NSData dataWithContentsOfFile:path];</span><br><span class="line">        _cacheData = data;</span><br><span class="line">        _cacheString = [[NSString alloc] initWithData:_cacheData encoding:self.cacheMetadata.stringEncoding];</span><br><span class="line">        switch (self.responseSerializerType) &#123;</span><br><span class="line">            case YTKResponseSerializerTypeHTTP:</span><br><span class="line">                // Do nothing.</span><br><span class="line">                return YES;</span><br><span class="line">            case YTKResponseSerializerTypeJSON:</span><br><span class="line">                _cacheJSON = [NSJSONSerialization JSONObjectWithData:_cacheData options:(NSJSONReadingOptions)0 error:&amp;error];</span><br><span class="line">                return error == nil;</span><br><span class="line">            case YTKResponseSerializerTypeXMLParser:</span><br><span class="line">                _cacheXML = [[NSXMLParser alloc] initWithData:_cacheData];</span><br><span class="line">                return YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果通过了最终的考验，则说明当前请求对应的缓存是符合各项要求并可以被成功取出，也就是可以直接进行回调了。</p>
<p>当确认缓存可以成功取出后，手动设置<code>dataFromCache</code>属性为 YES，说明当前的请求结果是来自于缓存，而没有通过网络请求。</p>
<p>然后在真正回调之前做了如下处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//YTKRequest.m：</span><br><span class="line">- (void)start&#123;</span><br><span class="line">    ....</span><br><span class="line">    //5. 回调之前的操作</span><br><span class="line">    //5.1 缓存处理</span><br><span class="line">    [self requestCompletePreprocessor];</span><br><span class="line">    //5.2 用户可以在这里进行真正回调前的操作</span><br><span class="line">    [self requestCompleteFilter];</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5.1：<code>requestCompletePreprocessor</code>方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//YTKRequest.m：</span><br><span class="line">- (void)requestCompletePreprocessor &#123;</span><br><span class="line">    </span><br><span class="line">    [super requestCompletePreprocessor];</span><br><span class="line">    //是否异步将responseData写入缓存（写入缓存的任务放在专门的队列ytkrequest_cache_writing_queue进行）</span><br><span class="line">    if (self.writeCacheAsynchronously) &#123;</span><br><span class="line">        </span><br><span class="line">        dispatch_async(ytkrequest_cache_writing_queue(), ^&#123;</span><br><span class="line">            //保存响应数据到缓存</span><br><span class="line">            [self saveResponseDataToCacheFile:[super responseData]];</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //保存响应数据到缓存</span><br><span class="line">        [self saveResponseDataToCacheFile:[super responseData]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//YTKRequest.m：</span><br><span class="line">//保存响应数据到缓存</span><br><span class="line">- (void)saveResponseDataToCacheFile:(NSData *)data &#123;</span><br><span class="line">    </span><br><span class="line">    if ([self cacheTimeInSeconds] &gt; 0 &amp;&amp; ![self isDataFromCache]) &#123;</span><br><span class="line">        if (data != nil) &#123;</span><br><span class="line">            @try &#123;</span><br><span class="line">                // New data will always overwrite old data.</span><br><span class="line">                [data writeToFile:[self cacheFilePath] atomically:YES];</span><br><span class="line">                YTKCacheMetadata *metadata = [[YTKCacheMetadata alloc] init];</span><br><span class="line">                metadata.version = [self cacheVersion];</span><br><span class="line">                metadata.sensitiveDataString = ((NSObject *)[self cacheSensitiveData]).description;</span><br><span class="line">                metadata.stringEncoding = [YTKNetworkUtils stringEncodingWithRequest:self];</span><br><span class="line">                metadata.creationDate = [NSDate date];</span><br><span class="line">                metadata.appVersionString = [YTKNetworkUtils appVersionString];</span><br><span class="line">                [NSKeyedArchiver archiveRootObject:metadata toFile:[self cacheMetadataFilePath]];</span><br><span class="line">                </span><br><span class="line">            &#125; @catch (NSException *exception) &#123;</span><br><span class="line">                YTKLog(@&quot;Save cache failed, reason = %@&quot;, exception.reason);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们可以看到, <code>requestCompletePreprocessor</code>方法的任务是将响应数据保存起来，也就是做缓存。但是，缓存的保存有两个条件，一个是需要<code>cacheTimeInSeconds</code>方法返回正整数（缓存时间，单位是秒，后续会详细说明）；另一个条件是<code>isDataFromCache</code>方法返回NO。但是我们知道，如果缓存可用，就会将这个属性设置为YES，所以走到这里的时候，就不做缓存了。</p>
</blockquote>
<p>接着看下5.2：<code>requestCompleteFilter</code>方法则是需要用户自己提供具体实现的，专门作为回调成功之前的一些处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//YTKBaseRequest.m</span><br><span class="line">- (void)requestCompleteFilter &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，回调之前的处理都结束了，下面来看一下在缓存可用的情况下的回调：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//YTKRequest.m</span><br><span class="line">- (void)start&#123;</span><br><span class="line">   </span><br><span class="line">    ...</span><br><span class="line">    YTKRequest *strongSelf = self;</span><br><span class="line">        </span><br><span class="line">    //6. 执行回调</span><br><span class="line">    //6.1 请求完成的代理</span><br><span class="line">    [strongSelf.delegate requestFinished:strongSelf];</span><br><span class="line">        </span><br><span class="line">    //6.2 请求成功的block</span><br><span class="line">    if (strongSelf.successCompletionBlock) &#123;</span><br><span class="line">         strongSelf.successCompletionBlock(strongSelf);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    //7. 把成功和失败的block都设置为nil，避免循环引用</span><br><span class="line">    [strongSelf clearCompletionBlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到 ，这里面同时存在两种回调：代理的回调和block的回调。先执行的是代理的回调，然后执行的是block的回调。而且在回调结束之后，YTKNetwork会帮助我们清空回调的block：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//YTKBaseRequest.m</span><br><span class="line">- (void)clearCompletionBlock &#123;</span><br><span class="line">    // 清空请求结束的block，避免循环引用</span><br><span class="line">    self.successCompletionBlock = nil;</span><br><span class="line">    self.failureCompletionBlock = nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，在用户同时实现了代理和block的情况下，二者都会被调用。</p>
</blockquote>
<p>到这里，我们了解了YTKNetwork在网络请求之前是如何验证缓存，以及在缓存有效的情况下是如何回调的。</p>
<p>反过来，如果缓存无效（或忽略缓存）时，需要立即请求网络。那么我们现在来看一看在这个时候YTKNetwork都做了什么：</p>
<p>仔细看一下上面的<code>start</code>方法，我们会发现，如果缓存不满足条件时，会直接调用<code>startWithoutCache</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//YTKRequest.m</span><br><span class="line">- (void)start&#123;</span><br><span class="line">    //1. 如果忽略缓存 -&gt; 请求</span><br><span class="line">    if (self.ignoreCache) &#123;</span><br><span class="line">        [self startWithoutCache];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //2. 如果存在下载未完成的文件 -&gt; 请求</span><br><span class="line">    if (self.resumableDownloadPath) &#123;</span><br><span class="line">        [self startWithoutCache];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //3. 获取缓存失败 -&gt; 请求</span><br><span class="line">    if (![self loadCacheWithError:nil]) &#123;</span><br><span class="line">        [self startWithoutCache];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么在<code>startWithoutCache</code>方法里都做了什么呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//YTKRequest.m</span><br><span class="line">- (void)startWithoutCache &#123;</span><br><span class="line">    </span><br><span class="line">    //1. 清除缓存</span><br><span class="line">    [self clearCacheVariables];</span><br><span class="line">    </span><br><span class="line">    //2. 调用父类的发起请求</span><br><span class="line">    [super start];</span><br><span class="line">&#125;</span><br><span class="line">//清除当前请求对应的所有缓存</span><br><span class="line">- (void)clearCacheVariables &#123;</span><br><span class="line">    _cacheData = nil;</span><br><span class="line">    _cacheXML = nil;</span><br><span class="line">    _cacheJSON = nil;</span><br><span class="line">    _cacheString = nil;</span><br><span class="line">    _cacheMetadata = nil;</span><br><span class="line">    _dataFromCache = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，首先清除了关于缓存的所有数据，然后调用父类的<code>start</code>方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//YTKBaseRequest.m:</span><br><span class="line">- (void)start &#123;</span><br><span class="line">    </span><br><span class="line">    //1. 告诉Accessories即将回调了（其实是即将发起请求）</span><br><span class="line">    [self toggleAccessoriesWillStartCallBack];</span><br><span class="line">    //2. 令agent添加请求并发起请求，在这里并不是组合关系，agent只是一个单例</span><br><span class="line">    [[YTKNetworkAgent sharedAgent] addRequest:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一步里的Accessories是一些遵从代理的对象。这个代理定义了一些用来追踪请求状况的方法。它被定义在了YTKBaseRequest.h文件里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//用来跟踪请求的状态的代理。</span><br><span class="line">@protocol YTKRequestAccessory &lt;NSObject&gt;</span><br><span class="line">@optional</span><br><span class="line">///  Inform the accessory that the request is about to start.</span><br><span class="line">///</span><br><span class="line">///  @param request The corresponding request.</span><br><span class="line">- (void)requestWillStart:(id)request;</span><br><span class="line">///  Inform the accessory that the request is about to stop. This method is called</span><br><span class="line">///  before executing `requestFinished` and `successCompletionBlock`.</span><br><span class="line">///</span><br><span class="line">///  @param request The corresponding request.</span><br><span class="line">- (void)requestWillStop:(id)request;</span><br><span class="line">///  Inform the accessory that the request has already stoped. This method is called</span><br><span class="line">///  after executing `requestFinished` and `successCompletionBlock`.</span><br><span class="line">///</span><br><span class="line">///  @param request The corresponding request.</span><br><span class="line">- (void)requestDidStop:(id)request;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>所以只要某个对象遵从了这个代理，就可以追踪到请求将要开始，将要结束，已经结束的状态。</p>
<p>接着看一下第二步：YTKNetworkAgent把当前的请求对象添加到了自己身上并发送请求。来看一下它的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">//YTKNetworkAgent.m</span><br><span class="line">- (void)addRequest:(YTKBaseRequest *)request &#123;</span><br><span class="line">    </span><br><span class="line">    //1. 获取task</span><br><span class="line">    NSParameterAssert(request != nil);</span><br><span class="line">    NSError * __autoreleasing requestSerializationError = nil;</span><br><span class="line">    //获取用户自定义的requestURL</span><br><span class="line">    NSURLRequest *customUrlRequest= [request buildCustomUrlRequest];</span><br><span class="line">    </span><br><span class="line">    if (customUrlRequest) &#123;</span><br><span class="line">        </span><br><span class="line">        __block NSURLSessionDataTask *dataTask = nil;</span><br><span class="line">        //如果存在用户自定义request，则直接走AFNetworking的dataTaskWithRequest:方法</span><br><span class="line">        dataTask = [_manager dataTaskWithRequest:customUrlRequest completionHandler:^(NSURLResponse * _Nonnull response, id  _Nullable responseObject, NSError * _Nullable error) &#123;</span><br><span class="line">            //响应的统一处理</span><br><span class="line">            [self handleRequestResult:dataTask responseObject:responseObject error:error];</span><br><span class="line">        &#125;];</span><br><span class="line">        request.requestTask = dataTask;</span><br><span class="line">        </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        </span><br><span class="line">        //如果用户没有自定义url，则直接走这里</span><br><span class="line">        request.requestTask = [self sessionTaskForRequest:request error:&amp;requestSerializationError];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    //序列化失败，则认定为请求失败</span><br><span class="line">    if (requestSerializationError) &#123;</span><br><span class="line">        //请求失败的处理</span><br><span class="line">        [self requestDidFailWithRequest:request error:requestSerializationError];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    NSAssert(request.requestTask != nil, @&quot;requestTask should not be nil&quot;);</span><br><span class="line">    // 优先级的映射</span><br><span class="line">    // !!Available on iOS 8 +</span><br><span class="line">    if ([request.requestTask respondsToSelector:@selector(priority)]) &#123;</span><br><span class="line">        switch (request.requestPriority) &#123;</span><br><span class="line">            case YTKRequestPriorityHigh:</span><br><span class="line">                request.requestTask.priority = NSURLSessionTaskPriorityHigh;</span><br><span class="line">                break;</span><br><span class="line">            case YTKRequestPriorityLow:</span><br><span class="line">                request.requestTask.priority = NSURLSessionTaskPriorityLow;</span><br><span class="line">                break;</span><br><span class="line">            case YTKRequestPriorityDefault:</span><br><span class="line">                /*!!fall through*/</span><br><span class="line">            default:</span><br><span class="line">                request.requestTask.priority = NSURLSessionTaskPriorityDefault;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // Retain request</span><br><span class="line">    YTKLog(@&quot;Add request: %@&quot;, NSStringFromClass([request class]));</span><br><span class="line">    </span><br><span class="line">    //2. 将request放入保存请求的字典中，taskIdentifier为key，request为值</span><br><span class="line">    [self addRequestToRecord:request];</span><br><span class="line">    </span><br><span class="line">    //3. 开始task</span><br><span class="line">    [request.requestTask resume];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法挺长的，但是请不要被吓到，它总共分为三个部分：</p>
<ul>
<li>第一部分是获取当前请求对应的task并赋给request的requestTask属性（以后提到的request，都为用户自定义的当前请求类的实例）。</li>
<li>第二部分是把request放入专门用来保存请求的字典中，key为taskIdentifier。</li>
<li>第三部分是启动task。</li>
</ul>
<p>下面我来依次讲解每个部分：</p>
<p>第一部分：获取当前请求对应的task并赋给request：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//YTKNetworkAgent.m</span><br><span class="line">- (void)addRequest:(YTKBaseRequest *)request &#123;</span><br><span class="line">  ...</span><br><span class="line">  if (customUrlRequest) &#123;</span><br><span class="line">        </span><br><span class="line">        __block NSURLSessionDataTask *dataTask = nil;</span><br><span class="line">        //如果存在用户自定义request，则直接走AFNetworking的dataTaskWithRequest:方法</span><br><span class="line">        dataTask = [_manager dataTaskWithRequest:customUrlRequest completionHandler:^(NSURLResponse * _Nonnull response, id  _Nullable responseObject, NSError * _Nullable error) &#123;</span><br><span class="line">            //统一处理请求响应</span><br><span class="line">            [self handleRequestResult:dataTask responseObject:responseObject error:error];</span><br><span class="line">        &#125;];</span><br><span class="line">        request.requestTask = dataTask;</span><br><span class="line">        </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        </span><br><span class="line">        //如果用户没有自定义url，则直接走这里</span><br><span class="line">        request.requestTask = [self sessionTaskForRequest:request error:&amp;requestSerializationError];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里判断了用户是否自定义了request：</p>
<ol>
<li>如果是，则直接调用AFNetworking的dataTaskWithRequest:方法。</li>
<li>如果不是，则调用YTKRequest自己的生成task的方法。</li>
</ol>
<p>第一种情况就不说了，因为AF帮我们做好了。在这里看一下第二种情况，<code>sessionTaskForRequest: error :</code>方法内部：</p>
<p>从这个方法最后的switch语句可以看出，这个方法的作用是返回当前request的NSURLSessionTask的实例。而且最终生成NSURLSessionTask实例的方法都是通过<code>dataTaskWithHTTPMethod:requestSerializer:URLString:parameters:error:</code>这个私有方法来实现的。在讲解这个关键的私有方法之前，先来逐步讲解一下这个私有方法需要的每个参数的获取方法：</p>
<ol>
<li>获得请求类型（GET，POST等）：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//YTKNetworkAgent.m</span><br><span class="line">- (NSURLSessionTask *)sessionTaskForRequest:(YTKBaseRequest *)request error:(NSError * _Nullable __autoreleasing *)error &#123;</span><br><span class="line">  ...</span><br><span class="line">  YTKRequestMethod method = [request requestMethod];</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>requestMethod</code>方法最初在YTKBaseRequest里面已经实现了，默认返回了YTKRequestMethodGET。</p>
<p>它的枚举类型在YTKBaseRequest.h里面定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//YTKBaseRequest.h</span><br><span class="line">///  HTTP Request method.</span><br><span class="line">typedef NS_ENUM(NSInteger, YTKRequestMethod) &#123;</span><br><span class="line">    YTKRequestMethodGET = 0,</span><br><span class="line">    YTKRequestMethodPOST,</span><br><span class="line">    YTKRequestMethodHEAD,</span><br><span class="line">    YTKRequestMethodPUT,</span><br><span class="line">    YTKRequestMethodDELETE,</span><br><span class="line">    YTKRequestMethodPATCH,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用户可以根据实际的需求在自定义request类里面重写这个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//RegisterAPI.m</span><br><span class="line">- (YTKRequestMethod)requestMethod &#123;</span><br><span class="line">    return YTKRequestMethodPOST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>获得请求url：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">//YTKNetworkAgent.m</span><br><span class="line">- (NSURLSessionTask *)sessionTaskForRequest:(YTKBaseRequest *)request error:(NSError * _Nullable __autoreleasing *)error &#123;</span><br><span class="line">  ...</span><br><span class="line">  NSString *url = [self buildRequestUrl:request];</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">//返回当前请求url</span><br><span class="line">- (NSString *)buildRequestUrl:(YTKBaseRequest *)request &#123;</span><br><span class="line">   </span><br><span class="line">    NSParameterAssert(request != nil);</span><br><span class="line">    //用户自定义的url（不包括在YTKConfig里面设置的base_url）</span><br><span class="line">    NSString *detailUrl = [request requestUrl];</span><br><span class="line">    NSURL *temp = [NSURL URLWithString:detailUrl];</span><br><span class="line">    </span><br><span class="line">    // 存在host和scheme的url立即返回正确</span><br><span class="line">    if (temp &amp;&amp; temp.host &amp;&amp; temp.scheme) &#123;</span><br><span class="line">        return detailUrl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 如果需要过滤url，则过滤</span><br><span class="line">    NSArray *filters = [_config urlFilters];</span><br><span class="line">    for (id&lt;YTKUrlFilterProtocol&gt; f in filters) &#123;</span><br><span class="line">        detailUrl = [f filterUrl:detailUrl withRequest:request];</span><br><span class="line">    &#125;</span><br><span class="line">    NSString *baseUrl;</span><br><span class="line">    if ([request useCDN]) &#123;</span><br><span class="line">        //如果使用CDN，在当前请求没有配置CDN地址的情况下，返回全局配置的CDN</span><br><span class="line">        if ([request cdnUrl].length &gt; 0) &#123;</span><br><span class="line">            baseUrl = [request cdnUrl];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            baseUrl = [_config cdnUrl];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //如果使用baseUrl，在当前请求没有配置baseUrl，返回全局配置的baseUrl</span><br><span class="line">        if ([request baseUrl].length &gt; 0) &#123;</span><br><span class="line">            baseUrl = [request baseUrl];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            baseUrl = [_config baseUrl];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果末尾没有/，则在末尾添加一个／</span><br><span class="line">    NSURL *url = [NSURL URLWithString:baseUrl];</span><br><span class="line">    if (baseUrl.length &gt; 0 &amp;&amp; ![baseUrl hasSuffix:@&quot;/&quot;]) &#123;</span><br><span class="line">        url = [url URLByAppendingPathComponent:@&quot;&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    return [NSURL URLWithString:detailUrl relativeToURL:url].absoluteString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>获得请求参数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//YTKNetworkAgent.m</span><br><span class="line">- (NSURLSessionTask *)sessionTaskForRequest:(YTKBaseRequest *)request error:(NSError * _Nullable __autoreleasing *)error &#123;</span><br><span class="line">   ...</span><br><span class="line">      //获取用户提供的请求参数</span><br><span class="line">    id param = request.requestArgument;</span><br><span class="line">    //获取用户提供的构造请求体的block（默认是没有的）</span><br><span class="line">    AFConstructingBlock constructingBlock = [request constructingBodyBlock];</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，requestArgument是一个get方法，需要用户自己定义请求体，例如在RegisterAPI里面就定义了两个请求参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//RegisterApi.m</span><br><span class="line">- (id)requestArgument &#123;</span><br><span class="line">    return @&#123;</span><br><span class="line">        @&quot;username&quot;: _username,</span><br><span class="line">        @&quot;password&quot;: _password</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>获得request serializer</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//YTKNetworkAgent.m</span><br><span class="line">- (NSURLSessionTask *)sessionTaskForRequest:(YTKBaseRequest *)request error:(NSError * _Nullable __autoreleasing *)error &#123;</span><br><span class="line">   ...</span><br><span class="line">   </span><br><span class="line">   //4. 获得request serializer</span><br><span class="line">   AFHTTPRequestSerializer *requestSerializer = [self requestSerializerForRequest:request];</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line">- (AFHTTPRequestSerializer *)requestSerializerForRequest:(YTKBaseRequest *)request &#123;</span><br><span class="line">    </span><br><span class="line">    AFHTTPRequestSerializer *requestSerializer = nil;</span><br><span class="line">    </span><br><span class="line">    //HTTP or JSON</span><br><span class="line">    if (request.requestSerializerType == YTKRequestSerializerTypeHTTP) &#123;</span><br><span class="line">        requestSerializer = [AFHTTPRequestSerializer serializer];</span><br><span class="line">    &#125; else if (request.requestSerializerType == YTKRequestSerializerTypeJSON) &#123;</span><br><span class="line">        requestSerializer = [AFJSONRequestSerializer serializer];</span><br><span class="line">    &#125;</span><br><span class="line">    //超时时间</span><br><span class="line">    requestSerializer.timeoutInterval = [request requestTimeoutInterval];</span><br><span class="line">    </span><br><span class="line">    //是否允许数据服务</span><br><span class="line">    requestSerializer.allowsCellularAccess = [request allowsCellularAccess];</span><br><span class="line">    //如果当前请求需要验证</span><br><span class="line">    NSArray&lt;NSString *&gt; *authorizationHeaderFieldArray = [request requestAuthorizationHeaderFieldArray];</span><br><span class="line">    if (authorizationHeaderFieldArray != nil) &#123;</span><br><span class="line">        [requestSerializer setAuthorizationHeaderFieldWithUsername:authorizationHeaderFieldArray.firstObject</span><br><span class="line">                                                          password:authorizationHeaderFieldArray.lastObject];</span><br><span class="line">    &#125;</span><br><span class="line">    //如果当前请求需要自定义 HTTPHeaderField</span><br><span class="line">    NSDictionary&lt;NSString *, NSString *&gt; *headerFieldValueDictionary = [request requestHeaderFieldValueDictionary];</span><br><span class="line">    if (headerFieldValueDictionary != nil) &#123;</span><br><span class="line">        for (NSString *httpHeaderField in headerFieldValueDictionary.allKeys) &#123;</span><br><span class="line">            NSString *value = headerFieldValueDictionary[httpHeaderField];</span><br><span class="line">            [requestSerializer setValue:value forHTTPHeaderField:httpHeaderField];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return requestSerializer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个方法通过传入的request实例，根据它的一些配置（用户提供）来获取AFHTTPRequestSerializer的实例。</p>
<p>到现在为止，获取NSURLSessionTask实例的几个参数都拿到了，剩下的就是调用<code>dataTaskWithHTTPMethod:requestSerializer:URLString:parameters:error:</code>方法来获取NSURLSessionTask实例了。我们来看一下这个方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//YTKNetworkAgent.m</span><br><span class="line">- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method</span><br><span class="line">                               requestSerializer:(AFHTTPRequestSerializer *)requestSerializer</span><br><span class="line">                                       URLString:(NSString *)URLString</span><br><span class="line">                                      parameters:(id)parameters</span><br><span class="line">                                           error:(NSError * _Nullable __autoreleasing *)error &#123;</span><br><span class="line">    return [self dataTaskWithHTTPMethod:method requestSerializer:requestSerializer URLString:URLString parameters:parameters constructingBodyWithBlock:nil error:error];</span><br><span class="line">&#125;</span><br><span class="line">//最终返回NSURLSessionDataTask实例</span><br><span class="line">- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method</span><br><span class="line">                               requestSerializer:(AFHTTPRequestSerializer *)requestSerializer</span><br><span class="line">                                       URLString:(NSString *)URLString</span><br><span class="line">                                      parameters:(id)parameters</span><br><span class="line">                       constructingBodyWithBlock:(nullable void (^)(id &lt;AFMultipartFormData&gt; formData))block</span><br><span class="line">                                           error:(NSError * _Nullable __autoreleasing *)error &#123;</span><br><span class="line">    NSMutableURLRequest *request = nil;</span><br><span class="line">    //根据有无构造请求体的block的情况来获取request</span><br><span class="line">    if (block) &#123;</span><br><span class="line">        request = [requestSerializer multipartFormRequestWithMethod:method URLString:URLString parameters:parameters constructingBodyWithBlock:block error:error];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        request = [requestSerializer requestWithMethod:method URLString:URLString parameters:parameters error:error];</span><br><span class="line">    &#125;</span><br><span class="line">    //获得request以后来获取dataTask</span><br><span class="line">    __block NSURLSessionDataTask *dataTask = nil;</span><br><span class="line">    dataTask = [_manager dataTaskWithRequest:request</span><br><span class="line">                           completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *_error) &#123;</span><br><span class="line">                               //响应的统一处理</span><br><span class="line">                               [self handleRequestResult:dataTask responseObject:responseObject error:_error];</span><br><span class="line">                           &#125;];</span><br><span class="line">    return dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个方法，上面的方法调用了下面的来获取最终的NSURLSessionDataTask实例。</p>
<p>OK，现在我们已经知道了NSURLSessionDataTask实例是如何获取的，再来看一下在addRequest：方法里接下来做的是对序列化失败的处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//YTKNetworkAgent.m</span><br><span class="line">- (void)addRequest:(YTKBaseRequest *)request &#123;</span><br><span class="line">   ...</span><br><span class="line">   </span><br><span class="line">  //序列化失败</span><br><span class="line">    if (requestSerializationError) &#123;</span><br><span class="line">        //请求失败的处理</span><br><span class="line">        [self requestDidFailWithRequest:request error:requestSerializationError];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>requestDidFailWithRequest:方法专门处理请求失败的情况，因为它被包含在统一处理请求回调的方法中，所以在稍后会在讲解统一处理请求回调的方法的时候再详细讲解这个方法。</p>
<p>继续往下走，到了优先级的映射部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//YTKNetworkAgent.m</span><br><span class="line">- (void)addRequest:(YTKBaseRequest *)request &#123;</span><br><span class="line">   ...</span><br><span class="line">   </span><br><span class="line">    // 优先级的映射</span><br><span class="line">    // !!Available on iOS 8 +</span><br><span class="line">    if ([request.requestTask respondsToSelector:@selector(priority)]) &#123;</span><br><span class="line">        switch (request.requestPriority) &#123;</span><br><span class="line">            case YTKRequestPriorityHigh:</span><br><span class="line">                request.requestTask.priority = NSURLSessionTaskPriorityHigh;</span><br><span class="line">                break;</span><br><span class="line">            case YTKRequestPriorityLow:</span><br><span class="line">                request.requestTask.priority = NSURLSessionTaskPriorityLow;</span><br><span class="line">                break;</span><br><span class="line">            case YTKRequestPriorityDefault:</span><br><span class="line">                /*!!fall through*/</span><br><span class="line">            default:</span><br><span class="line">                request.requestTask.priority = NSURLSessionTaskPriorityDefault;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>requestPriority是YTKBaseRequest的一个枚举属性，它的枚举在YTKBaseRequest.h里面被定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, YTKRequestPriority) &#123;</span><br><span class="line">    YTKRequestPriorityLow = -4L,</span><br><span class="line">    YTKRequestPriorityDefault = 0,</span><br><span class="line">    YTKRequestPriorityHigh = 4,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这里，将用户设置的YTKRequestPriority映射到NSURLSessionTask的priority上。</p>
<p>到这里，我们拿到了task的实例并设置好了优先级，紧接着就是addRequest:方法里的第二个部分：<br>YTKNetworkAgent将request实例放在了一个字典中，保存起来：</p>
<p><strong>第二部分：把request放入专门用来保存请求的字典中，key为taskIdentifier：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//YTKNetworkAgent.m</span><br><span class="line">- (void)addRequest:(YTKBaseRequest *)request &#123;</span><br><span class="line">   ...</span><br><span class="line">   ...</span><br><span class="line">   </span><br><span class="line">  //将request实例放入保存请求的字典中，taskIdentifier为key，request为值</span><br><span class="line">  [self addRequestToRecord:request];</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line">- (void)addRequestToRecord:(YTKBaseRequest *)request &#123;</span><br><span class="line">    </span><br><span class="line">    //加锁</span><br><span class="line">    Lock();</span><br><span class="line">    _requestsRecord[@(request.requestTask.taskIdentifier)] = request;</span><br><span class="line">    Unlock();</span><br><span class="line">&#125;</span><br><span class="line">#define Lock() pthread_mutex_lock(&amp;_lock)</span><br><span class="line">#define Unlock() pthread_mutex_unlock(&amp;_lock)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看到，在添加前和添加后是进行了加锁和解锁的处理的。而且request实例被保存的时候，将其task的identifier作为key来保存。</p>
</blockquote>
<p>在当前的request被保存以后，就到了最后一步，正式发起请求：</p>
<p><strong>第三部分：启动task</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//YTKNetworkAgent.m</span><br><span class="line">- (NSURLSessionTask *)sessionTaskForRequest:(YTKBaseRequest *)request error:(NSError * _Nullable __autoreleasing *)error &#123;</span><br><span class="line">   ...</span><br><span class="line">   </span><br><span class="line">   [request.requestTask resume];</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到现在为止，我们了解了YTKNetwork里面，一个请求开始之前做的事情：查找可用缓存，生成NSURLSessionTask实例，获取url，requestSerializer，将request放到YTKNetworkAgent的一个字典里等等（详细流程会在稍后给出）。</p>
<p>那么接下来我们看一下YTKNetwork是如何处理请求的回调的。</p>
<p>眼尖的同学们可能会注意到，在获取NSURLSessionTask实例的时候，出现了两次“响应的统一处理”的注释，大家可以搜索这个注释就可以找到这个方法：<code>handleRequestResult:responseObject:error:</code>。这个方法负责的是对请求回调的处理，当然包括了成功和失败的情况。我们来看一下在这个方法里都做了什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">//YTKNetworkAgent.m</span><br><span class="line">//统一处理请求结果，包括成功和失败的情况</span><br><span class="line">- (void)handleRequestResult:(NSURLSessionTask *)task responseObject:(id)responseObject error:(NSError *)error &#123;</span><br><span class="line">    </span><br><span class="line">    //1. 获取task对应的request</span><br><span class="line">    Lock();</span><br><span class="line">    YTKBaseRequest *request = _requestsRecord[@(task.taskIdentifier)];</span><br><span class="line">    Unlock();</span><br><span class="line">    //如果不存在对应的request，则立即返回</span><br><span class="line">    if (!request) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    。。。</span><br><span class="line">    //2. 获取request对应的response</span><br><span class="line">    request.responseObject = responseObject;</span><br><span class="line">    </span><br><span class="line">    //3. 获取responseObject，responseData和responseString</span><br><span class="line">    if ([request.responseObject isKindOfClass:[NSData class]]) &#123;</span><br><span class="line">        </span><br><span class="line">       //3.1 获取 responseData</span><br><span class="line">        request.responseData = responseObject;</span><br><span class="line">        </span><br><span class="line">        //3.2 获取responseString</span><br><span class="line">        request.responseString = [[NSString alloc] initWithData:responseObject encoding:[YTKNetworkUtils stringEncodingWithRequest:request]];</span><br><span class="line">         //3.3 获取responseObject（或responseJSONObject）</span><br><span class="line">        //根据返回的响应的序列化的类型来得到对应类型的响应</span><br><span class="line">        switch (request.responseSerializerType)</span><br><span class="line">        &#123;</span><br><span class="line">            case YTKResponseSerializerTypeHTTP:</span><br><span class="line">                // Default serializer. Do nothing.</span><br><span class="line">                break;</span><br><span class="line">                </span><br><span class="line">            case YTKResponseSerializerTypeJSON:</span><br><span class="line">                request.responseObject = [self.jsonResponseSerializer responseObjectForResponse:task.response data:request.responseData error:&amp;serializationError];</span><br><span class="line">                request.responseJSONObject = request.responseObject;</span><br><span class="line">                break;</span><br><span class="line">                </span><br><span class="line">            case YTKResponseSerializerTypeXMLParser:</span><br><span class="line">                request.responseObject = [self.xmlParserResponseSerialzier responseObjectForResponse:task.response data:request.responseData error:&amp;serializationError];</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //4. 判断是否有错误，将错误对象赋值给requestError，改变succeed的布尔值。目的是根据succeed的值来判断到底是进行成功的回调还是失败的回调</span><br><span class="line">    if (error) &#123;</span><br><span class="line">        //如果该方法传入的error不为nil</span><br><span class="line">        succeed = NO;</span><br><span class="line">        requestError = error;</span><br><span class="line">        </span><br><span class="line">    &#125; else if (serializationError) &#123;</span><br><span class="line">        //如果序列化失败了</span><br><span class="line">        succeed = NO;</span><br><span class="line">        requestError = serializationError;</span><br><span class="line">        </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        </span><br><span class="line">        //即使没有error而且序列化通过，也要验证request是否有效</span><br><span class="line">        succeed = [self validateResult:request error:&amp;validationError];</span><br><span class="line">        requestError = validationError;</span><br><span class="line">    &#125;</span><br><span class="line">    //5. 根据succeed的布尔值来调用相应的处理</span><br><span class="line">    if (succeed) &#123;</span><br><span class="line">        //请求成功的处理</span><br><span class="line">        [self requestDidSucceedWithRequest:request];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        </span><br><span class="line">        //请求失败的处理</span><br><span class="line">        [self requestDidFailWithRequest:request error:requestError];</span><br><span class="line">    &#125;</span><br><span class="line">     //6. 回调完成的处理</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        //6.1 在字典里移除当前request</span><br><span class="line">        [self removeRequestFromRecord:request];</span><br><span class="line">         //6.2 清除所有block</span><br><span class="line">        [request clearCompletionBlock];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单讲解一下上面的代码：</p>
<ul>
<li>首先通过task的identifier值从YTKNetworkAgent保存的字典里获取对应的请求。</li>
<li>然后将获得的responseObject进行处理，将处理后获得的responseObject，responseData和responseString赋值给当前的请求实例request。</li>
<li>再根据这些值的获取情况来判断最终回调的成败（改变succeed的值）。</li>
<li>最后根据succeed的值来进行成功和失败的回调。</li>
</ul>
<p>这里先重点介绍一下是如何判断json的有效性的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//YTKNetworkAgent.m</span><br><span class="line">//判断code是否符合范围和json的有效性</span><br><span class="line">- (BOOL)validateResult:(YTKBaseRequest *)request error:(NSError * _Nullable __autoreleasing *)error &#123;</span><br><span class="line">    </span><br><span class="line">    //1. 判断code是否在200~299之间</span><br><span class="line">    BOOL result = [request statusCodeValidator];</span><br><span class="line">    </span><br><span class="line">    if (!result) &#123;</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            *error = [NSError errorWithDomain:YTKRequestValidationErrorDomain code:YTKRequestValidationErrorInvalidStatusCode userInfo:@&#123;NSLocalizedDescriptionKey:@&quot;Invalid status code&quot;&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //2. result 存在的情况判断json是否有效</span><br><span class="line">    id json = [request responseJSONObject];</span><br><span class="line">    id validator = [request jsonValidator];</span><br><span class="line">    </span><br><span class="line">    if (json &amp;&amp; validator) &#123;</span><br><span class="line">        //通过json和validator来判断json是否有效</span><br><span class="line">        result = [YTKNetworkUtils validateJSON:json withValidator:validator];</span><br><span class="line">        </span><br><span class="line">        //如果json无效</span><br><span class="line">        if (!result) &#123;</span><br><span class="line">            if (error) &#123;</span><br><span class="line">                *error = [NSError errorWithDomain:YTKRequestValidationErrorDomain code:YTKRequestValidationErrorInvalidJSONFormat userInfo:@&#123;NSLocalizedDescriptionKey:@&quot;Invalid JSON format&quot;&#125;];</span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，首先，用statusCodeValidator方法判断响应的code是否在正确的范围:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//YTKBaseReqiest.m</span><br><span class="line">- (BOOL)statusCodeValidator &#123;</span><br><span class="line">    NSInteger statusCode = [self responseStatusCode];</span><br><span class="line">    return (statusCode &gt;= 200 &amp;&amp; statusCode &lt;= 299);</span><br><span class="line">&#125;</span><br><span class="line">- (NSInteger)responseStatusCode &#123;</span><br><span class="line">    return self.response.statusCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再判断json的有效性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">//YTKNetworkUtils.m</span><br><span class="line">//判断json的有效性</span><br><span class="line">+ (BOOL)validateJSON:(id)json withValidator:(id)jsonValidator &#123;</span><br><span class="line">    if ([json isKindOfClass:[NSDictionary class]] &amp;&amp;</span><br><span class="line">        [jsonValidator isKindOfClass:[NSDictionary class]]) &#123;</span><br><span class="line">        NSDictionary * dict = json;</span><br><span class="line">        NSDictionary * validator = jsonValidator;</span><br><span class="line">        BOOL result = YES;</span><br><span class="line">        NSEnumerator * enumerator = [validator keyEnumerator];</span><br><span class="line">        NSString * key;</span><br><span class="line">        while ((key = [enumerator nextObject]) != nil) &#123;</span><br><span class="line">            id value = dict[key];</span><br><span class="line">            id format = validator[key];</span><br><span class="line">            if ([value isKindOfClass:[NSDictionary class]]</span><br><span class="line">                || [value isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">                result = [self validateJSON:value withValidator:format];</span><br><span class="line">                if (!result) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if ([value isKindOfClass:format] == NO &amp;&amp;</span><br><span class="line">                    [value isKindOfClass:[NSNull class]] == NO) &#123;</span><br><span class="line">                    result = NO;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125; else if ([json isKindOfClass:[NSArray class]] &amp;&amp;</span><br><span class="line">               [jsonValidator isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">        NSArray * validatorArray = (NSArray *)jsonValidator;</span><br><span class="line">        if (validatorArray.count &gt; 0) &#123;</span><br><span class="line">            NSArray * array = json;</span><br><span class="line">            NSDictionary * validator = jsonValidator[0];</span><br><span class="line">            for (id item in array) &#123;</span><br><span class="line">                BOOL result = [self validateJSON:item withValidator:validator];</span><br><span class="line">                if (!result) &#123;</span><br><span class="line">                    return NO;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125; else if ([json isKindOfClass:jsonValidator]) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，YTKNetworkUtils这个类是在YTKNetworkPirvate里面定义的，YTKNetworkPirvate里面有一些工具类的方法，在后面还会遇到。</p>
<p>在验证返回的JSON数据是否有效以后，就可以进行回调了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//YTKNetworkAgent.m</span><br><span class="line">- (void)handleRequestResult:(NSURLSessionTask *)task responseObject:(id)responseObject error:(NSError *)error &#123;</span><br><span class="line">    ...</span><br><span class="line">    //5. 根据succeed的布尔值来调用相应的处理</span><br><span class="line">    if (succeed) &#123;</span><br><span class="line">        //请求成功的处理</span><br><span class="line">        [self requestDidSucceedWithRequest:request];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        </span><br><span class="line">        //请求失败的处理</span><br><span class="line">        [self requestDidFailWithRequest:request error:requestError];</span><br><span class="line">    &#125;</span><br><span class="line">    //6. 回调完成的处理</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        //6.1 在字典里移除当前request</span><br><span class="line">        [self removeRequestFromRecord:request];</span><br><span class="line">         //6.2 清除所有block</span><br><span class="line">        [request clearCompletionBlock];</span><br><span class="line">    &#125;);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先来分别看一下请求成功的处理和失败的处理：</p>
<p>请求成功的处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//YTKNetworkAgent.m</span><br><span class="line">//请求成功：主要负责将结果写入缓存&amp;回调成功的代理和block</span><br><span class="line">- (void)requestDidSucceedWithRequest:(YTKBaseRequest *)request &#123;</span><br><span class="line">    </span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        //写入缓存 </span><br><span class="line">        [request requestCompletePreprocessor];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        </span><br><span class="line">        //告诉Accessories请求就要停止了</span><br><span class="line">        [request toggleAccessoriesWillStopCallBack];</span><br><span class="line">        </span><br><span class="line">        //在真正的回调之前做的处理,用户自定义</span><br><span class="line">        [request requestCompleteFilter];</span><br><span class="line">        //如果有代理，则调用成功的代理</span><br><span class="line">        if (request.delegate != nil) &#123;</span><br><span class="line">            [request.delegate requestFinished:request];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //如果传入了成功回调的代码，则调用</span><br><span class="line">        if (request.successCompletionBlock) &#123;</span><br><span class="line">            request.successCompletionBlock(request);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //告诉Accessories请求已经结束了</span><br><span class="line">        [request toggleAccessoriesDidStopCallBack];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我么可以看到，在请求成功以后，第一个做的是写入缓存，我们来看一下<code>requestCompletePreprocessor</code>方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//YTKRequest.m</span><br><span class="line">- (void)requestCompletePreprocessor &#123;</span><br><span class="line">    </span><br><span class="line">    [super requestCompletePreprocessor];</span><br><span class="line">    //是否异步将responseData写入缓存（写入缓存的任务放在专门的队列进行）</span><br><span class="line">    if (self.writeCacheAsynchronously) &#123;</span><br><span class="line">        </span><br><span class="line">        dispatch_async(ytkrequest_cache_writing_queue(), ^&#123;</span><br><span class="line">            //写入缓存文件</span><br><span class="line">            [self saveResponseDataToCacheFile:[super responseData]];</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">         //写入缓存文件</span><br><span class="line">        [self saveResponseDataToCacheFile:[super responseData]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//写入缓存文件</span><br><span class="line">- (void)saveResponseDataToCacheFile:(NSData *)data &#123;</span><br><span class="line">    </span><br><span class="line">    if ([self cacheTimeInSeconds] &gt; 0 &amp;&amp; ![self isDataFromCache]) &#123;</span><br><span class="line">        if (data != nil) &#123;</span><br><span class="line">            @try &#123;</span><br><span class="line">                // 1. 保存request的responseData到cacheFilePath</span><br><span class="line">                [data writeToFile:[self cacheFilePath] atomically:YES];</span><br><span class="line">                // 2. 保存request的metadata到cacheMetadataFilePath</span><br><span class="line">                YTKCacheMetadata *metadata = [[YTKCacheMetadata alloc] init];</span><br><span class="line">                metadata.version = [self cacheVersion];</span><br><span class="line">                metadata.sensitiveDataString = ((NSObject *)[self cacheSensitiveData]).description;</span><br><span class="line">                metadata.stringEncoding = [YTKNetworkUtils stringEncodingWithRequest:self];</span><br><span class="line">                metadata.creationDate = [NSDate date];</span><br><span class="line">                metadata.appVersionString = [YTKNetworkUtils appVersionString];</span><br><span class="line">                [NSKeyedArchiver archiveRootObject:metadata toFile:[self cacheMetadataFilePath]];</span><br><span class="line">                </span><br><span class="line">            &#125; @catch (NSException *exception) &#123;</span><br><span class="line">                YTKLog(@&quot;Save cache failed, reason = %@&quot;, exception.reason);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先看一下写入缓存操作的执行条件：当<code>cacheTimeInSeconds</code>方法返回大于0并且<code>isDataFromCache</code>为NO的时候会进行写入缓存。</p>
<p><code>cacheTimeInSeconds</code>方法返回的是缓存保存的时间，它最初定义在YTKBaseRquest里面，默认返回是-1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//YTKBaseRequest.m</span><br><span class="line">- (NSInteger)cacheTimeInSeconds &#123;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以说YTKNetwork默认是不进行缓存的，如果用户需要做缓存，则需要在自定义的request类里面返回一个大于0的整数，这个整数的单位是秒。</p>
<p><code>isDataFromCache</code>属性在上面讲解发送请求部分里的查询缓存的步骤里有介绍。在这里再强调一下：<code>isDataFromCache</code>的默认值是NO。在请求发起之前，<br>查询缓存的时候：</p>
<ul>
<li>如果发现缓存不可用（或忽略缓存），则立即发送请求，这个时候，isDataFromCache的值不做更改，仍然是NO。</li>
<li>如果发现缓存可用（在不忽略缓存的情况下），就要将isDataFromCache属性设置为YES，说明将不需要发送请求，直接在里获取数据了。</li>
</ul>
<p>即是说，如果发送了请求，则<code>isDataFromCache</code>一定是NO的，那么在上面这个判断里面，(!isDataFromCache)就一定为YES了。</p>
<p>因此，如果用户设置了缓存保存的时间，在请求返回成功后，就会写入缓存。</p>
<p>我们接着往下看，对于缓存，YTKNetwork保存的是两种缓存：<br>第一种是纯粹的NSData类型的实例。第二种是描述当前NSData实例的元数据YTKCacheMetadata的实例，从它的属性来看，分为这几种：</p>
<ol>
<li>缓存的版本，默认返回为0，用户可以自定义。</li>
<li>敏感数据，类型为id，默认返回nil，用户可以自定义。</li>
<li>NSString的编码格式，在YTKNetworkPrivate内的YTKNetworkUtils实现。</li>
<li>元数据的创建时间。</li>
<li>app的版本号，在YTKNetworkPrivate内的YTKNetworkUtils实现。</li>
</ol>
<p>在将元数据的实例的这些属性都被赋值以后，将元数据实例序列化写入磁盘中。保存的路径通过<code>cacheMetadataFilePath</code>方法获取。</p>
<p>现在知道了YTKRequest的缓存内容，我们来看一下这两种缓存的位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">//YTKRequest.m</span><br><span class="line">//纯NSData数据缓存的文件名</span><br><span class="line">- (NSString *)cacheFileName &#123;</span><br><span class="line">    NSString *requestUrl = [self requestUrl];</span><br><span class="line">    NSString *baseUrl = [YTKNetworkConfig sharedConfig].baseUrl;</span><br><span class="line">    id argument = [self cacheFileNameFilterForRequestArgument:[self requestArgument]];</span><br><span class="line">    NSString *requestInfo = [NSString stringWithFormat:@&quot;Method:%ld Host:%@ Url:%@ Argument:%@&quot;,</span><br><span class="line">                             (long)[self requestMethod], baseUrl, requestUrl, argument];</span><br><span class="line">    NSString *cacheFileName = [YTKNetworkUtils md5StringFromString:requestInfo];</span><br><span class="line">    return cacheFileName;</span><br><span class="line">&#125;</span><br><span class="line">//纯NSData数据的缓存位置</span><br><span class="line">- (NSString *)cacheFilePath &#123;</span><br><span class="line">    NSString *cacheFileName = [self cacheFileName];</span><br><span class="line">    NSString *path = [self cacheBasePath];</span><br><span class="line">    path = [path stringByAppendingPathComponent:cacheFileName];</span><br><span class="line">    return path;</span><br><span class="line">&#125;</span><br><span class="line">//元数据的缓存位置</span><br><span class="line">- (NSString *)cacheMetadataFilePath &#123;</span><br><span class="line">    NSString *cacheMetadataFileName = [NSString stringWithFormat:@&quot;%@.metadata&quot;, [self cacheFileName]];</span><br><span class="line">    NSString *path = [self cacheBasePath];</span><br><span class="line">    path = [path stringByAppendingPathComponent:cacheMetadataFileName];</span><br><span class="line">    return path;</span><br><span class="line">&#125;</span><br><span class="line">//创建用户保存所有YTKNetwork缓存的文件夹</span><br><span class="line">- (NSString *)cacheBasePath &#123;</span><br><span class="line">    </span><br><span class="line">    //获取全路径</span><br><span class="line">    NSString *pathOfLibrary = [NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES) objectAtIndex:0];</span><br><span class="line">    NSString *path = [pathOfLibrary stringByAppendingPathComponent:@&quot;LazyRequestCache&quot;];</span><br><span class="line">    // YTKCacheDirPathFilterProtocol定义了用户可以自定义存储位置的代理方法</span><br><span class="line">    NSArray&lt;id&lt;YTKCacheDirPathFilterProtocol&gt;&gt; *filters = [[YTKNetworkConfig sharedConfig] cacheDirPathFilters];</span><br><span class="line">    if (filters.count &gt; 0) &#123;</span><br><span class="line">        for (id&lt;YTKCacheDirPathFilterProtocol&gt; f in filters) &#123;</span><br><span class="line">            path = [f filterCacheDirPath:path withRequest:self];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //创建文件夹</span><br><span class="line">    [self createDirectoryIfNeeded:path];</span><br><span class="line">    return path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，纯NSData数据缓存的文件名包含了请求方法（GET,POST..），baseURL，requestURL，请求参数拼接的字符串再进行md5加密而成。</p>
<p>而元数据的的文件名则在纯NSData数据缓存的文件名后面加上了.metadata后缀。</p>
<p>为了更形象地看到这两种缓存，我将缓存的保存时间设置为200秒之后再请求一次，然后打开文件夹找到了它们：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-6c5f41fbe2993059.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>而且我们也确认了保存所有YTKNetwork缓存的文件夹的名字为LazyRequestCache。</p>
<p>OK，现在我们知道了在请求成功回调后的缓存写入，接下来看一下是如何回调的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//YTKNetworkAgent.m</span><br><span class="line">- (void)handleRequestResult:(NSURLSessionTask *)task responseObject:(id)responseObject error:(NSError *)error &#123;</span><br><span class="line">    ...</span><br><span class="line">    YTKRequest *strongSelf = self;</span><br><span class="line">    //6. 执行回调</span><br><span class="line">    //6.1 请求完成的代理</span><br><span class="line">    [strongSelf.delegate requestFinished:strongSelf];</span><br><span class="line">    //6.2 请求成功的block</span><br><span class="line">    if (strongSelf.successCompletionBlock) &#123;</span><br><span class="line">        strongSelf.successCompletionBlock(strongSelf);</span><br><span class="line">    &#125;</span><br><span class="line">    //7. 把成功和失败的block都设置为nil，避免循环引用</span><br><span class="line">    [strongSelf clearCompletionBlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到,代理的回调是先于block的回调的。而且在block回调结束以后，会立即调用clearCompletionBlock方法将block清空。该方法的实现是在YTKBaseRequest里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//YTKBaseRequest.m</span><br><span class="line">- (void)clearCompletionBlock &#123;</span><br><span class="line">    // 清空请求结束的block，避免循环引用</span><br><span class="line">    self.successCompletionBlock = nil;</span><br><span class="line">    self.failureCompletionBlock = nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们知道了请求成功的处理，那么再来看一下请求失败时的处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">//YTKNetworkAgent.m</span><br><span class="line">//请求失败</span><br><span class="line">- (void)requestDidFailWithRequest:(YTKBaseRequest *)request error:(NSError *)error &#123;</span><br><span class="line">    </span><br><span class="line">    request.error = error;</span><br><span class="line">    YTKLog(@&quot;Request %@ failed, status code = %ld, error = %@&quot;,</span><br><span class="line">           NSStringFromClass([request class]), (long)request.responseStatusCode, error.localizedDescription);</span><br><span class="line">    // 储存未完成的下载数据</span><br><span class="line">    NSData *incompleteDownloadData = error.userInfo[NSURLSessionDownloadTaskResumeData];</span><br><span class="line">    if (incompleteDownloadData) &#123;</span><br><span class="line">        [incompleteDownloadData writeToURL:[self incompleteDownloadTempPathForDownloadPath:request.resumableDownloadPath] atomically:YES];</span><br><span class="line">    &#125;</span><br><span class="line">    // Load response from file and clean up if download task failed.</span><br><span class="line">    //如果下载任务失败，则取出对应的响应文件并清空</span><br><span class="line">    if ([request.responseObject isKindOfClass:[NSURL class]]) &#123;</span><br><span class="line">        NSURL *url = request.responseObject;</span><br><span class="line">        </span><br><span class="line">        //isFileURL：是否是文件，如果是，则可以再isFileURL获取；&amp;&amp;后面是再次确认是否存在改url对应的文件</span><br><span class="line">        if (url.isFileURL &amp;&amp; [[NSFileManager defaultManager] fileExistsAtPath:url.path]) &#123;</span><br><span class="line">            </span><br><span class="line">            //将url的data和string赋给request</span><br><span class="line">            request.responseData = [NSData dataWithContentsOfURL:url];</span><br><span class="line">            request.responseString = [[NSString alloc] initWithData:request.responseData encoding:[YTKNetworkUtils stringEncodingWithRequest:request]];</span><br><span class="line">            [[NSFileManager defaultManager] removeItemAtURL:url error:nil];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //清空request</span><br><span class="line">        request.responseObject = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        //请求失败的预处理，YTK没有定义，需要用户定义</span><br><span class="line">        [request requestFailedPreprocessor];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        </span><br><span class="line">        //告诉Accessories请求就要停止了</span><br><span class="line">        [request toggleAccessoriesWillStopCallBack];</span><br><span class="line">        </span><br><span class="line">        //在真正的回调之前做的处理</span><br><span class="line">        [request requestFailedFilter];</span><br><span class="line">        //如果有代理，就调用代理</span><br><span class="line">        if (request.delegate != nil) &#123;</span><br><span class="line">            [request.delegate requestFailed:request];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //如果传入了失败回调的block代码，就调用block</span><br><span class="line">        if (request.failureCompletionBlock) &#123;</span><br><span class="line">            request.failureCompletionBlock(request);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //告诉Accessories请求已经停止了</span><br><span class="line">        [request toggleAccessoriesDidStopCallBack];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法里，首先判断了当前任务是否为下载任务，如果是，则储存当前已经下载好的data到<code>resumableDownloadPath</code>里面。而如果下载任务失败，则将其对应的在本地保存的路径上的文件清空。</p>
<p>到这里，我已经把单个请求从配置，发送，响应，回调的步骤都讲解完了。为了帮助大家理解整个过程，这里提供了整个的流程图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-eab27afc98b324bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>我们说YTKNetworkAgent是请求的发送者，既然有发送，也就会有取消等操作，这就不得不提它的另外两个接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//YTKNetworkAgent.h</span><br><span class="line">///  取消某个request</span><br><span class="line">- (void)cancelRequest:(YTKBaseRequest *)request;</span><br><span class="line">///  取消所有添加的request</span><br><span class="line">- (void)cancelAllRequests;</span><br></pre></td></tr></table></figure>
<p>首先我们看下取消某个request这个方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//YTKNetworkAgent.m</span><br><span class="line">///  取消某个request</span><br><span class="line">- (void)cancelRequest:(YTKBaseRequest *)request &#123;</span><br><span class="line">    NSParameterAssert(request != nil);</span><br><span class="line">    //获取request的task，并取消</span><br><span class="line">    [request.requestTask cancel];</span><br><span class="line">    //从字典里移除当前request</span><br><span class="line">    [self removeRequestFromRecord:request];</span><br><span class="line">    //清理所有block</span><br><span class="line">    [request clearCompletionBlock];</span><br><span class="line">&#125;</span><br><span class="line">//从字典里移除某request</span><br><span class="line">- (void)removeRequestFromRecord:(YTKBaseRequest *)request &#123;</span><br><span class="line">    </span><br><span class="line">    //加锁</span><br><span class="line">    Lock();</span><br><span class="line">    [_requestsRecord removeObjectForKey:@(request.requestTask.taskIdentifier)];</span><br><span class="line">    YTKLog(@&quot;Request queue size = %zd&quot;, [_requestsRecord count]);</span><br><span class="line">    Unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取消所有在字典里添加的request：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//YTKNetworkAgent.m</span><br><span class="line">- (void)cancelAllRequests &#123;</span><br><span class="line">    Lock();</span><br><span class="line">    NSArray *allKeys = [_requestsRecord allKeys];</span><br><span class="line">    Unlock();</span><br><span class="line">    if (allKeys &amp;&amp; allKeys.count &gt; 0) &#123;</span><br><span class="line">        NSArray *copiedKeys = [allKeys copy];</span><br><span class="line">        for (NSNumber *key in copiedKeys) &#123;</span><br><span class="line">            Lock();</span><br><span class="line">            YTKBaseRequest *request = _requestsRecord[key];</span><br><span class="line">            Unlock();</span><br><span class="line">            //stop每个请求</span><br><span class="line">            [request stop];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个stop方法是在YTKBaseRequest里面定义的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//YTKBaseRequest.m</span><br><span class="line">- (void)stop &#123;</span><br><span class="line">    </span><br><span class="line">    //告诉Accessories将要回调了</span><br><span class="line">    [self toggleAccessoriesWillStopCallBack];</span><br><span class="line">    </span><br><span class="line">    //清空代理</span><br><span class="line">    self.delegate = nil;</span><br><span class="line">    </span><br><span class="line">    //调用agent的取消某个request的方法</span><br><span class="line">    [[YTKNetworkAgent sharedAgent] cancelRequest:self];</span><br><span class="line">    </span><br><span class="line">    //告诉Accessories回调完成了</span><br><span class="line">    [self toggleAccessoriesDidStopCallBack];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK，看到这里，相信你对YTKNetwork单个请求的流程有了比较好的了解了，下面我们来看一下YTKNetwork的高级功能：批量请求和链式请求。</p>
<h3 id="3-3-批量请求和链式请求"><a href="#3-3-批量请求和链式请求" class="headerlink" title="3.3 批量请求和链式请求"></a>3.3 批量请求和链式请求</h3><p>YTKNetwork支持的批量请求有两种：</p>
<ol>
<li>批量请求：多个请求几乎同时发起。</li>
<li>链式请求：当前个请求结束后才能发起下一个请求。</li>
</ol>
<p>其实无论是批量请求，还是链式请求，我们都可以想到很可能是用一个数组将这些请求管理了起来。那么具体是如何实现的呢？</p>
<p>我们首先来看一下YTKNetwork是如何实现批量请求的。</p>
<h4 id="3-31批量请求"><a href="#3-31批量请求" class="headerlink" title="3.31批量请求"></a>3.31批量请求</h4><p>YTKNetwork 使用YTKBatchRequest类来发送无序的批量请求，它需要用一个含有YTKRequest子类的数组来初始化，并将这个数组保存起来赋给它的<code>_requestArray</code>实例变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//YTKBatchRequest.m</span><br><span class="line">- (instancetype)initWithRequestArray:(NSArray&lt;YTKRequest *&gt; *)requestArray &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        </span><br><span class="line">        //保存为属性</span><br><span class="line">        _requestArray = [requestArray copy];</span><br><span class="line">        //批量请求完成的数量初始化为0</span><br><span class="line">        _finishedCount = 0;</span><br><span class="line">        </span><br><span class="line">        //类型检查，所有元素都必须为YTKRequest或的它的子类，否则强制初始化失败</span><br><span class="line">        for (YTKRequest * req in _requestArray) &#123;</span><br><span class="line">            if (![req isKindOfClass:[YTKRequest class]]) &#123;</span><br><span class="line">                YTKLog(@&quot;Error, request item must be YTKRequest instance.&quot;);</span><br><span class="line">                return nil;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化以后，我们就可以调用start方法来发起当前YTKBatchRequest实例所管理的所有请求了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//YTKBatchRequest.m</span><br><span class="line">//batch请求开始</span><br><span class="line">- (void)startWithCompletionBlockWithSuccess:(void (^)(YTKBatchRequest *batchRequest))success</span><br><span class="line">                                    failure:(void (^)(YTKBatchRequest *batchRequest))failure &#123;</span><br><span class="line">    [self setCompletionBlockWithSuccess:success failure:failure];</span><br><span class="line">    [self start];</span><br><span class="line">&#125;</span><br><span class="line">//设置成功和失败的block</span><br><span class="line">- (void)setCompletionBlockWithSuccess:(void (^)(YTKBatchRequest *batchRequest))success</span><br><span class="line">                              failure:(void (^)(YTKBatchRequest *batchRequest))failure &#123;</span><br><span class="line">    self.successCompletionBlock = success;</span><br><span class="line">    self.failureCompletionBlock = failure;</span><br><span class="line">&#125;</span><br><span class="line">- (void)start &#123;</span><br><span class="line">    </span><br><span class="line">    //如果batch里第一个请求已经成功结束，则不能再start</span><br><span class="line">    if (_finishedCount &gt; 0) &#123;</span><br><span class="line">        YTKLog(@&quot;Error! Batch request has already started.&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //最开始设定失败的request为nil</span><br><span class="line">    _failedRequest = nil;</span><br><span class="line">    </span><br><span class="line">    //使用YTKBatchRequestAgent来管理当前的批量请求</span><br><span class="line">    [[YTKBatchRequestAgent sharedAgent] addBatchRequest:self];</span><br><span class="line">    [self toggleAccessoriesWillStartCallBack];</span><br><span class="line">    </span><br><span class="line">    //遍历所有request，并开始请求</span><br><span class="line">    for (YTKRequest * req in _requestArray) &#123;</span><br><span class="line">        req.delegate = self;</span><br><span class="line">        [req clearCompletionBlock];</span><br><span class="line">        [req start];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，我们可以看出：</p>
<ol>
<li>在至少完成了其中一个请求以后，调用当前YTKBatchRequest实例的start方法会立即返回，否则可以无限制start。</li>
<li>YTKBatchRequest的实例是需要在发起请求之前，要被添加在YTKBatchRequestAgent里的数组里：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//YTKBatchRequestAgent.m</span><br><span class="line">- (void)addBatchRequest:(YTKBatchRequest *)request &#123;</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">        [_requestArray addObject:request];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>因为是批量发送请求，所以在这里是遍历YTKBatchRequest实例的_requestArray并逐一发送请求。因为已经封装好了单个的请求，所以在这里直接start就好了。</li>
</ol>
<p>发起请求以后，在每个请求回调的代理方法里，来判断这次批量请求是否成功。</p>
<p>YTKRequest子类成功的回调：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//YTKBatchRequest.m</span><br><span class="line">#pragma mark - Network Request Delegate</span><br><span class="line">- (void)requestFinished:(YTKRequest *)request &#123;</span><br><span class="line">    </span><br><span class="line">    //某个request成功后，首先让_finishedCount + 1</span><br><span class="line">    _finishedCount++;</span><br><span class="line">    </span><br><span class="line">    //如果_finishedCount等于_requestArray的个数，则判定当前batch请求成功</span><br><span class="line">    if (_finishedCount == _requestArray.count) &#123;</span><br><span class="line">        </span><br><span class="line">        //调用即将结束的代理</span><br><span class="line">        [self toggleAccessoriesWillStopCallBack];</span><br><span class="line">        </span><br><span class="line">        //调用请求成功的代理</span><br><span class="line">        if ([_delegate respondsToSelector:@selector(batchRequestFinished:)]) &#123;</span><br><span class="line">            [_delegate batchRequestFinished:self];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //调用批量请求成功的block</span><br><span class="line">        if (_successCompletionBlock) &#123;</span><br><span class="line">            _successCompletionBlock(self);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //清空成功和失败的block</span><br><span class="line">        [self clearCompletionBlock];</span><br><span class="line">        </span><br><span class="line">        //调用请求结束的代理</span><br><span class="line">        [self toggleAccessoriesDidStopCallBack];</span><br><span class="line">        </span><br><span class="line">        //从YTKBatchRequestAgent里移除当前的batch</span><br><span class="line">        [[YTKBatchRequestAgent sharedAgent] removeBatchRequest:self];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，在某个请求的回调成功以后，会让成功计数+1。在+1以后，如果成功计数和当前批量请求数组里元素的个数相等，则判定当前批量请求成功，并进行当前批量请求的成功回调。</p>
<p>接下来我们看一下某个请求失败的处理：</p>
<p>YTKReques子类失败的回调：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//YTKBatchRequest.m</span><br><span class="line">- (void)requestFailed:(YTKRequest *)request &#123;</span><br><span class="line">    </span><br><span class="line">    _failedRequest = request;</span><br><span class="line">    </span><br><span class="line">    //调用即将结束的代理</span><br><span class="line">    [self toggleAccessoriesWillStopCallBack];</span><br><span class="line">    </span><br><span class="line">    //停止batch里所有的请求</span><br><span class="line">    for (YTKRequest *req in _requestArray) &#123;</span><br><span class="line">        [req stop];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //调用请求失败的代理</span><br><span class="line">    if ([_delegate respondsToSelector:@selector(batchRequestFailed:)]) &#123;</span><br><span class="line">        [_delegate batchRequestFailed:self];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //调用请求失败的block</span><br><span class="line">    if (_failureCompletionBlock) &#123;</span><br><span class="line">        _failureCompletionBlock(self);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //清空成功和失败的block</span><br><span class="line">    [self clearCompletionBlock];</span><br><span class="line">    //调用请求结束的代理</span><br><span class="line">    [self toggleAccessoriesDidStopCallBack];</span><br><span class="line">    </span><br><span class="line">    //从YTKBatchRequestAgent里移除当前的batch</span><br><span class="line">    [[YTKBatchRequestAgent sharedAgent] removeBatchRequest:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里不难看出，当前批量请求里面只要有一个request失败了，则判定当前批量请求失败。<br>而当前批量请求失败的回调（代理和block）会传入这个失败的request的实例。而且这个失败的request会先被赋给_failedRequest这个实例变量里。</p>
<p>总的来说，YTKBatchRequest类用一个数组来保存当前批量请求所要处理的所有request实例。而且用一个成功计数来判定当前批量请求整体是否成功。而当前批量请求的失败则是由这些request实例里面第一个失败的实例导致的：只要有一个request回调失败了，则立即停止其他的所有请求并调用当前批量请求的失败回调。</p>
<p>现在讲完了批量请求的处理，我们接下来看一下链式请求的处理。</p>
<h4 id="3-32链式请求"><a href="#3-32链式请求" class="headerlink" title="3.32链式请求"></a>3.32链式请求</h4><p>和批量请求类似，处理链式请求的类是YTKChainRequest，并且用YTKChainRequestAgent单例来管理YTKChainRequest的实例。</p>
<p>但是和批量请求不同的是，YTKChainRequest实例的初始化是不需要传入一个含有request的数组的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//YTKChainRequest.m</span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    </span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        </span><br><span class="line">        //下一个请求的index</span><br><span class="line">        _nextRequestIndex = 0;</span><br><span class="line">        </span><br><span class="line">        //保存链式请求的数组</span><br><span class="line">        _requestArray = [NSMutableArray array];</span><br><span class="line">        </span><br><span class="line">        //保存回调的数组</span><br><span class="line">        _requestCallbackArray = [NSMutableArray array];</span><br><span class="line">        </span><br><span class="line">        //空回调，用来填充用户没有定义的回调block</span><br><span class="line">        _emptyCallback = ^(YTKChainRequest *chainRequest, YTKBaseRequest *baseRequest) &#123;</span><br><span class="line">            // do nothing</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是它提供了添加和删除request的接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//YTKChainRequest.m</span><br><span class="line">//在当前chain添加request和callback</span><br><span class="line">- (void)addRequest:(YTKBaseRequest *)request callback:(YTKChainCallback)callback &#123;</span><br><span class="line">    </span><br><span class="line">    //保存当前请求</span><br><span class="line">    [_requestArray addObject:request];</span><br><span class="line">    </span><br><span class="line">    if (callback != nil) &#123;</span><br><span class="line">        [_requestCallbackArray addObject:callback];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //之所以特意弄一个空的callback，是为了避免在用户没有给当前request的callback传值的情况下，造成request数组和callback数组的不对称</span><br><span class="line">        [_requestCallbackArray addObject:_emptyCallback];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，在给YTKChainRequest实例添加request实例的同时，还可以传入回调的block。当然也可以不传，但是为了保持request数组和callback数组的对称性（因为回调的时候是需要根据request数组里的index来获取callback数组里对应的callback的），YTKNetwork给我们提供了一个空的block。</p>
<p>我们接着看一下链式请求的发起：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//YTKChainRequest.m</span><br><span class="line">- (void)start &#123;</span><br><span class="line">    //如果第1个请求已经结束，就不再重复start了</span><br><span class="line">    if (_nextRequestIndex &gt; 0) &#123;</span><br><span class="line">        YTKLog(@&quot;Error! Chain request has already started.&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果请求队列数组里面还有request，则取出并start</span><br><span class="line">    if ([_requestArray count] &gt; 0) &#123;</span><br><span class="line">        [self toggleAccessoriesWillStartCallBack];</span><br><span class="line">        //取出当前request并start</span><br><span class="line">        [self startNextRequest];</span><br><span class="line">        //在当前的_requestArray添加当前的chain（YTKChainRequestAgent允许有多个chain）</span><br><span class="line">        [[YTKChainRequestAgent sharedAgent] addChainRequest:self];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        YTKLog(@&quot;Error! Chain request array is empty.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，YTKChainRequest用<code>_nextRequestIndex</code>来保存下一个请求的index，它的默认值是0。而它的值的累加是在当前请求结束后，发起下面的请求之前进行的。所以说，如果已经完成了请求队列里的第一个请求，就无法在启动当前的请求队列了，会立即返回。</p>
<p>这里<code>startNextRequest</code>方法比较重要：在判断请求队列数组里面还有request的话，就会调用这个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//YTKChainRequest.m</span><br><span class="line">- (BOOL)startNextRequest &#123;</span><br><span class="line">    if (_nextRequestIndex &lt; [_requestArray count]) &#123;</span><br><span class="line">        YTKBaseRequest *request = _requestArray[_nextRequestIndex];</span><br><span class="line">        _nextRequestIndex++;</span><br><span class="line">        request.delegate = self;</span><br><span class="line">        [request clearCompletionBlock];</span><br><span class="line">        [request start];</span><br><span class="line">        return YES;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法有两个作用：</p>
<ol>
<li>第一个作用是判断是否能进行下一个request（如果index 大于或等于 request数组的count的话就不能在request数组里取出request，因为会造成数组越界）</li>
<li>第二个作用是如果可以进行下一个request，则发起该request。并将<code>_nextRequestIndex+1</code>。</li>
</ol>
<p>所以和批量请求不同的是，链式请求的请求队列是可以变动的，用户可以无限制地添加请求。只要请求队列里面有请求存在，则YTKChainRequest就会继续发送它们。</p>
<p>现在我们知道了YTKChainRequest的发送，接下来看一下回调部分:</p>
<p>和YTKBatchRequest相同的是，YTKChainRequest也实现了YTKRequest的代理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//某个request请求成功的代理的实现</span><br><span class="line">//YTKChainRequest.m</span><br><span class="line">- (void)requestFinished:(YTKBaseRequest *)request &#123;</span><br><span class="line">    </span><br><span class="line">    //1. 取出当前的request和callback，进行回调</span><br><span class="line">    NSUInteger currentRequestIndex = _nextRequestIndex - 1;</span><br><span class="line">    YTKChainCallback callback = _requestCallbackArray[currentRequestIndex];</span><br><span class="line">    callback(self, request);//注意：这个回调只是当前request的回调，而不是当前chain全部完成的回调。当前chain的回调在下面</span><br><span class="line">    </span><br><span class="line">    //2. 如果不能再继续请求了，说明当前成功的request已经是chain里最后一个request，也就是说当前chain里所有的回调都成功了，即这个chain请求成功了。</span><br><span class="line">    if (![self startNextRequest]) &#123;</span><br><span class="line">        [self toggleAccessoriesWillStopCallBack];</span><br><span class="line">        if ([_delegate respondsToSelector:@selector(chainRequestFinished:)]) &#123;</span><br><span class="line">            [_delegate chainRequestFinished:self];</span><br><span class="line">            [[YTKChainRequestAgent sharedAgent] removeChainRequest:self];</span><br><span class="line">        &#125;</span><br><span class="line">        [self toggleAccessoriesDidStopCallBack];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，在某个request回调成功以后，会根据当前请求的index（_nextRequestIndex-1）来获取其对应的block并调用。接着，再调用<code>startNextRequest</code>方法来判断当前的YTKChainRequest的请求队列里面是否还有其他的请求了：</p>
<ul>
<li>如果没有了，则调用当前YTKChainRequest的最终成功的回调。</li>
<li>如果还有，则发起接下来的request（按顺序）。</li>
</ul>
<p>接下来我们再看一下某个request失败的代理的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//YTKChainRequest.m</span><br><span class="line">//某个reqeust请求失败的代理</span><br><span class="line">- (void)requestFailed:(YTKBaseRequest *)request &#123;</span><br><span class="line">    </span><br><span class="line">    //如果当前 chain里的某个request失败了，则判定当前chain失败。调用当前chain失败的回调</span><br><span class="line">    [self toggleAccessoriesWillStopCallBack];</span><br><span class="line">    if ([_delegate respondsToSelector:@selector(chainRequestFailed:failedBaseRequest:)]) &#123;</span><br><span class="line">        [_delegate chainRequestFailed:self failedBaseRequest:request];</span><br><span class="line">        [[YTKChainRequestAgent sharedAgent] removeChainRequest:self];</span><br><span class="line">    &#125;</span><br><span class="line">    [self toggleAccessoriesDidStopCallBack];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前的request请求失败了，则判定当前链式请求是失败的，则立即调用当前链式请求的失败回调。</p>
<p>现在我们知道了链式请求的请求和回调，再来看一下链式请求的终止：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//YTKChainRequest.m</span><br><span class="line">//终止当前的chain</span><br><span class="line">- (void)stop &#123;</span><br><span class="line">    //首先调用即将停止的callback</span><br><span class="line">    [self toggleAccessoriesWillStopCallBack];</span><br><span class="line">    //然后stop当前的请求，再清空chain里所有的请求和回掉block</span><br><span class="line">    [self clearRequest];</span><br><span class="line">    //在YTKChainRequestAgent里移除当前的chain</span><br><span class="line">    [[YTKChainRequestAgent sharedAgent] removeChainRequest:self];</span><br><span class="line">    //最后调用已经结束的callback</span><br><span class="line">    [self toggleAccessoriesDidStopCallBack];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个<code>stop</code>方法是可以在外部调用的，所以用户可以随时终止当前链式请求的进行。它首先调用<code>clearReuqest</code>方法，将当前request停止，再将请求队列数组和callback数组清空。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//YTKChainRequest.m</span><br><span class="line">- (void)clearRequest &#123;</span><br><span class="line">    //获取当前请求的index</span><br><span class="line">    NSUInteger currentRequestIndex = _nextRequestIndex - 1;</span><br><span class="line">    if (currentRequestIndex &lt; [_requestArray count]) &#123;</span><br><span class="line">        YTKBaseRequest *request = _requestArray[currentRequestIndex];</span><br><span class="line">        [request stop];</span><br><span class="line">    &#125;</span><br><span class="line">    [_requestArray removeAllObjects];</span><br><span class="line">    [_requestCallbackArray removeAllObjects];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在YTKChainRequestAgent单例里面，将自己移除掉。</p>
<h2 id="4-最后的话"><a href="#4-最后的话" class="headerlink" title="4. 最后的话"></a>4. 最后的话</h2><p>阅读这个框架的源码我的收获是：加深了对命令模式，对Block的理解，知道了一个网络请求都需要什么元素组成，知道了网络缓存该怎么设计，也知道了链式请求怎么设计等等。</p>
<p>我还记得当初听说YTKNetwork能发起链式请求的时候觉得毫无思路的感觉，不过现在应该没什么问题了。</p>
<p>所以说多阅读源码对技术水平的提升是很有帮助的，除了能增多对本语言API的了解，其实更有意义的是它能让你接触到一些新的设计和解决问题的办法，这些都是脱离某个语言本身的东西，也是作为一名程序员所必不可少的东西。</p>
<p>希望这篇文章能对读者们有所帮助~</p>

      
    </div>
    
    
    

     

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="liuxc 微信支付"/>
        <p>微信支付</p>
      </div>
    

    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS/" rel="tag"><i class="fa fa-tag"></i> iOS</a>
          
            <a href="/tags/Objective-C/" rel="tag"><i class="fa fa-tag"></i> Objective-C</a>
          
            <a href="/tags/源码解析/" rel="tag"><i class="fa fa-tag"></i> 源码解析</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/04/08/Data Structure & Algorithm/数据结构/" rel="next" title="数据结构&算法 in Swift">
                <i class="fa fa-chevron-left"></i> 数据结构&算法 in Swift
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/04/16/Design Mode/23个经典设计模式的Swift实现/" rel="prev" title="23个经典设计模式的Swift实现">
                23个经典设计模式的Swift实现 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        
<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          
  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>
  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="liuxc" />
            
              <p class="site-author-name" itemprop="name">liuxc</p>
              <p class="site-description motion-element" itemprop="description">每天进步一点点</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/liuxc123" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="lxc_work@126.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.zhihu.com/people/mirl-33/activities" target="_blank" title="知乎">
                    
                      <i class="fa fa-fw fa-globe"></i>知乎</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="http://www.jianshu.com/u/d96162b35a72" target="_blank" title="简书">
                    
                      <i class="fa fa-fw fa-globe"></i>简书</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-架构"><span class="nav-number">1.</span> <span class="nav-text">1. 架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-设计模式"><span class="nav-number">2.</span> <span class="nav-text">2. 设计模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-源码解析"><span class="nav-number">3.</span> <span class="nav-text">3. 源码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-责任介绍"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 责任介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-单个请求"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 单个请求</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-21-单个请求的配置"><span class="nav-number">3.2.1.</span> <span class="nav-text">3.21 单个请求的配置</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-22-单个请求的发起"><span class="nav-number">3.3.</span> <span class="nav-text">3.22 单个请求的发起</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-批量请求和链式请求"><span class="nav-number">3.4.</span> <span class="nav-text">3.3 批量请求和链式请求</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-31批量请求"><span class="nav-number">3.4.1.</span> <span class="nav-text">3.31批量请求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-32链式请求"><span class="nav-number">3.4.2.</span> <span class="nav-text">3.32链式请求</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-最后的话"><span class="nav-number">4.</span> <span class="nav-text">4. 最后的话</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liuxc</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">博客全站共&#58;</span>
    
    <span title="博客全站共">78.7k&nbsp字</span>
  
</div>


  <div class="powered-by">
    <i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
      本站访客数:<span id="busuanzi_value_site_uv"></span></span>
  </div>





  
  <span class="post-meta-divider">|</span>
  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  

    
      <script id="dsq-count-scr" src="https://.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://yoursite.com/2018/04/10/iOS/源码分析/YTKNetwork源码解析/';
          this.page.identifier = '2018/04/10/iOS/源码分析/YTKNetwork源码解析/';
          this.page.title = 'YTKNetwork源码解析';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  








  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  


  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.3"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.3"></script>


  
  <script type="text/javascript" src="/js/src/exturl.js?v=5.1.3"></script>


</body>
</html>
