<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Runtime笔记]]></title>
    <url>%2F2018%2F04%2F26%2FiOS%2FiOS%2FRuntime%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言iOS开发也有几年了，之前一直听说有runtime，也看过其他框架源码中使用过，但是对于具体的原理还是比较模糊，这次通过此次分享让大家加深对于runtime理解。 Runtime的特性主要是消息(方法)传递，如果消息(方法)在对象中找不到，就进行转发，具体怎么实现的呢。我们从下面几个方面探寻Runtime的实现机制。 Runtime介绍 Runtime消息传递 Runtime消息转发 Runtime应用 Runtime介绍 Objective-C 扩展了 C 语言，并加入了面向对象特性和 Smalltalk 式的消息传递机制。而这个扩展的核心是一个用 C 和 编译语言 写的 Runtime 库。它是 Objective-C 面向对象和动态机制的基石。 Objective-C 是一个动态语言，这意味着它不仅需要一个编译器，也需要一个运行时系统来动态得创建类和对象、进行消息传递和转发。理解 Objective-C 的 Runtime 机制可以帮我们更好的了解这个语言，适当的时候还能对语言进行扩展，从系统层面解决项目中的一些设计或技术问题。了解 Runtime ，要先了解它的核心 - 消息传递 （Messaging）。 Runtime其实有两个版本: “modern” 和 “legacy”。我们现在用的 Objective-C 2.0 采用的是现行 (Modern) 版的 Runtime 系统，只能运行在 iOS 和 macOS 10.5 之后的 64 位程序中。而 macOS 较老的32位程序仍采用 Objective-C 1 中的（早期）Legacy 版本的 Runtime 系统。这两个版本最大的区别在于当你更改一个类的实例变量的布局时，在早期版本中你需要重新编译它的子类，而现行版就不需要。 Runtime 基本是用 C 和汇编写的，可见苹果为了动态系统的高效而作出的努力。你可以在这里下到苹果维护的开源代码。苹果和GNU各自维护一个开源的 runtime 版本，这两个版本之间都在努力的保持一致。 平时的业务中主要是使用官方Api，解决我们框架性的需求。 高级编程语言想要成为可执行文件需要先编译为汇编语言再汇编为机器语言，机器语言也是计算机能够识别的唯一语言，但是OC并不能直接编译为汇编语言，而是要先转写为纯C语言再进行编译和汇编的操作，从OC到C语言的过渡就是由runtime来实现的。然而我们使用OC进行面向对象开发，而C语言更多的是面向过程开发，这就需要将面向对象的类转变为面向过程的结构体。 Runtime消息传递一个对象的方法像这样[obj foo]，编译器转成消息发送objc_msgSend(obj, foo)，Runtime时执行的流程是这样的： 首先，通过obj的isa指针找到它的class； 在class的method list找foo； 如果class中没有找到foo，继续往它的superclass中找； 一但找到foo这个函数，就去执行它的实现IMP 但这种实现有个问题，效率低。但是一个class往往只有20%的函数会被经常调用，可能占总调用次数的80%。每个消息都要遍历一次objc_method_list并不合理。如果把经常被调用的函数缓存下来，那可以大大提高函数查询的效率。这也就是objc_class中另一个重要成员objc_cache做的事情 - 再找到foo之后，把foo的method_name作为key，method_imp作为value给存起来。当再次收到foo消息的时候，可以直接在cache里找到，避免去遍历objc_method_list。从前面的源代码可以看到objc_cache是存在objc_class结构体中的。 objec_msgSend的方法定义如下： 1OBJC_EXPORT id objc_msgSend(id self, SEL op, ...) 那消息传递是怎么实现的呢？我们看看对象(object)，类(class)，方法(method)这几个的结构体： 1234567891011121314151617181920212223242526272829303132333435//对象struct objc_object &#123; Class isa OBJC_ISA_AVAILABILITY;&#125;;//类struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE;//方法列表struct objc_method_list &#123; struct objc_method_list *obsolete OBJC2_UNAVAILABLE; int method_count OBJC2_UNAVAILABLE;#ifdef __LP64__ int space OBJC2_UNAVAILABLE;#endif /* variable length structure */ struct objc_method method_list[1] OBJC2_UNAVAILABLE;&#125; OBJC2_UNAVAILABLE;//方法struct objc_method &#123; SEL method_name OBJC2_UNAVAILABLE; char *method_types OBJC2_UNAVAILABLE; IMP method_imp OBJC2_UNAVAILABLE;&#125; 系统首先找到消息的接收对象，然后通过对象的isa找到它的类。 在它的类中查找method_list，是否有selector方法。 没有则查找父类的method_list。 找到对应的method，执行它的IMP。 转发IMP的return值。 下面讲讲消息传递用到的一些概念： 类对象(objc_class) 实例(objc_object) 元类(Meta Class) Method(objc_method) SEL(objc_selector) IMP 类缓存(objc_cache) Category(objc_category) 类对象(objc_class)Objective-C类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针。 1typedef struct objc_class *Class; 查看objc/runtime.h中objc_class结构体的定义如下： 12345678910111213141516struct objc_class &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; const char * _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE; struct objc_class结构体定义了很多变量，通过命名不难发现，结构体里保存了指向父类的指针、类的名字、版本、实例大小、实例变量列表、方法列表、缓存、遵守的协议列表等，一个类包含的信息也不就正是这些吗？没错，类对象就是一个结构体struct objc_class，这个结构体存放的数据称为元数据（motadata），该结构体的第一个成员变量也是isa指针，这就说明了Class本身其实也是一个对象，因此我们称之为类对象，类对象在编译期产生用于创建实例对象，是单例。 实例(objc_object)1234567/// Represents an instance of a class.struct objc_object &#123; Class isa OBJC_ISA_AVAILABILITY;&#125;;/// A pointer to an instance of a class.typedef struct objc_object *id; 类对象中的元数据存储的都是如何创建一个实例的相关信息，那么类对象和类方法应该从哪里创建呢？就是从isa指针指向的结构体创建，类对象的isa指针指向的我们称之为元类(metaclass)， 元类(Meta Class)通过上图我们可以看出整个体系构成了一个自闭环，struct objc_object结构体实例它的isa指针指向类对象，类对象的isa指针指向了元类，super_class指针指向父类的类对象，而元类的super_class指针指向了父类的元类，那元类的isa指针又指向了自己。 元类(Meta Class)是一个类对象的类。在上面我们提到，所有的类自身也是一个对象，我们可以向这个对象发送消息(即调用类方法)。为了调用类方法，这个类的isa指针必须指向一个包含这些类方法的一个objc_class结构体。这就引出了meta-class的概念，元类中保存了创建类对象以及类方法所需的所有信息。任何NSObject继承体系下的meta-class都使用NSObject的meta-class作为自己的所属类，而基类的meta-class的isa指针是指向它自己。 Method(objc_method)先看下定义 1234567runtime.h/// An opaque type that represents a method in a class definition.代表类定义中一个方法的不透明类型typedef struct objc_method *Method;struct objc_method &#123; SEL method_name OBJC2_UNAVAILABLE; char *method_types OBJC2_UNAVAILABLE; IMP method_imp OBJC2_UNAVAILABLE; Method和我们平时理解的函数是一致的，就是表示能够独立完成一个功能的一段代码，比如： 1234- (void)logName&#123; NSLog(@&quot;name&quot;);&#125; 这段代码，就是一个函数。 我们来看下objc_method这个结构体的内容： SEL method_name 方法名 char *method_types 方法类型 IMP method_imp 方法实现 在这个结构体中，我们已经看到了SEL和IMP，说明SEL和IMP其实都是Method的属性。 我们接着来看SEL。 SEL(objc_selector)先看下定义 123Objc.h/// An opaque type that represents a method selector.代表一个方法的不透明类型typedef struct objc_selector *SEL; objc_msgSend函数第二个参数类型为SEL，它是selector在Objective-C中的表示类型（Swift中是Selector类）。selector是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是SEL: 1@property SEL selector; 可以看到selector是SEL的一个实例。 1A method selector is a C string that has been registered (or “mapped“) with the Objective-C runtime. Selectors generated by the compiler are automatically mapped by the runtime when the class is loaded. 其实selector就是个映射到方法的C字符串，你可以用 Objective-C 编译器命令@selector()或者 Runtime 系统的sel_registerName函数来获得一个 SEL 类型的方法选择器。 selector既然是一个string，我觉得应该是类似className+method的组合，命名规则有两条： 同一个类，selector不能重复 不同的类，selector可以重复 这也带来了一个弊端，我们在写C代码的时候，经常会用到函数重载，就是函数名相同，参数不同，但是这在Objective-C中是行不通的，因为selector只记了method的name，没有参数，所以没法区分不同的method。 比如： 12- (void)caculate(NSInteger)num;- (void)caculate(CGFloat)num; 是会报错的。 我们只能通过命名来区别： 12- (void)caculateWithInt(NSInteger)num;- (void)caculateWithFloat(CGFloat)num; 在不同类中相同名字的方法所对应的方法选择器是相同的，即使方法名字相同而变量类型不同也会导致它们具有相同的方法选择器。 IMP看下IMP的定义 123/// A pointer to the function of a method implementation. 指向一个方法实现的指针typedef id (*IMP)(id, SEL, ...); #endif 就是指向最终实现程序的内存地址的指针。 在iOS的Runtime中，Method通过selector和IMP两个属性，实现了快速查询方法及实现，相对提高了性能，又保持了灵活性。 类缓存(objc_cache)当Objective-C运行时通过跟踪它的isa指针检查对象时，它可以找到一个实现许多方法的对象。然而，你可能只调用它们的一小部分，并且每次查找时，搜索所有选择器的类分派表没有意义。所以类实现一个缓存，每当你搜索一个类分派表，并找到相应的选择器，它把它放入它的缓存。所以当objc_msgSend查找一个类的选择器，它首先搜索类缓存。这是基于这样的理论：如果你在类上调用一个消息，你可能以后再次调用该消息。为了加速消息分发， 系统会对方法和对应的地址进行缓存，就放在上述的objc_cache，所以在实际运行中，大部分常用的方法都是会被缓存起来的，Runtime系统实际上非常快，接近直接执行内存地址的程序速度。 Category(objc_category)Category是表示一个指向分类的结构体的指针，其定义如下： 12345678struct category_t &#123; const char *name; classref_t cls; struct method_list_t *instanceMethods; struct method_list_t *classMethods; struct protocol_list_t *protocols; struct property_list_t *instanceProperties;&#125;; 123456name：是指 class_name 而不是 category_name。cls：要扩展的类对象，编译期间是不会定义的，而是在Runtime阶段通过name对 应到对应的类对象。instanceMethods：category中所有给类添加的实例方法的列表。classMethods：category中所有添加的类方法的列表。protocols：category实现的所有协议的列表。instanceProperties：表示Category里所有的properties，这就是我们可以通过objc_setAssociatedObject和objc_getAssociatedObject增加实例变量的原因，不过这个和一般的实例变量是不一样的。 从上面的category_t的结构体中可以看出，分类中可以添加实例方法，类方法，甚至可以实现协议，添加属性，不可以添加成员变量。 Runtime消息转发前文介绍了进行一次发送消息会在相关的类对象中搜索方法列表，如果找不到则会沿着继承树向上一直搜索知道继承树根部（通常为NSObject），如果还是找不到并且消息转发都失败了就回执行doesNotRecognizeSelector:方法报unrecognized selector错。那么消息转发到底是什么呢？接下来将会逐一介绍最后的三次机会。 动态方法解析 备用接收者 完整消息转发 动态方法解析首先，Objective-C运行时会调用 +resolveInstanceMethod:或者 +resolveClassMethod:，让你有机会提供一个函数实现。如果你添加了函数并返回YES， 那运行时系统就会重新启动一次消息发送的过程。 实现一个动态方法解析的例子如下： 123456789101112131415161718- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //执行foo函数 [self performSelector:@selector(foo:)];&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; if (sel == @selector(foo:)) &#123;//如果是执行foo函数，就动态解析，指定新的IMP class_addMethod([self class], sel, (IMP)fooMethod, &quot;v@:&quot;); return YES; &#125; return [super resolveInstanceMethod:sel];&#125;void fooMethod(id obj, SEL _cmd) &#123; NSLog(@&quot;Doing foo&quot;);//新的foo函数&#125; 打印结果： 2018-04-01 12:23:35.952670+0800 ocram[87546:23235469] Doing foo 可以看到虽然没有实现foo:这个函数，但是我们通过class_addMethod动态添加fooMethod函数，并执行fooMethod这个函数的IMP。从打印结果看，成功实现了。如果resolve方法返回 NO ，运行时就会移到下一步：forwardingTargetForSelector。 备用接收者如果目标对象实现了-forwardingTargetForSelector:，Runtime 这时就会调用这个方法，给你把这个消息转发给其他对象的机会。 实现一个备用接收者的例子如下： 1234567891011121314151617181920212223242526272829303132333435363738394041#import &quot;ViewController.h&quot;#import &quot;objc/runtime.h&quot;@interface Person: NSObject@end@implementation Person- (void)foo &#123; NSLog(@&quot;Doing foo&quot;);//Person的foo函数&#125;@end@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //执行foo函数 [self performSelector:@selector(foo)];&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; return YES;//返回YES，进入下一步转发&#125;- (id)forwardingTargetForSelector:(SEL)aSelector &#123; if (aSelector == @selector(foo)) &#123; return [Person new];//返回Person对象，让Person对象接收这个消息 &#125; return [super forwardingTargetForSelector:aSelector];&#125;@end 打印结果： 2018-04-01 12:45:04.757929+0800 ocram[88023:23260346] Doing foo 可以看到我们通过forwardingTargetForSelector把当前ViewController的方法转发给了Person去执行了。打印结果也证明我们成功实现了转发。 完整消息转发如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。首先它会发送-methodSignatureForSelector:消息获得函数的参数和返回值类型。如果-methodSignatureForSelector:返回nil ，Runtime则会发出 -doesNotRecognizeSelector:消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime就会创建一个NSInvocation 对象并发送 -forwardInvocation:消息给目标对象。 实现一个完整转发的例子如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#import &quot;ViewController.h&quot;#import &quot;objc/runtime.h&quot;@interface Person: NSObject@end@implementation Person- (void)foo &#123; NSLog(@&quot;Doing foo&quot;);//Person的foo函数&#125;@end@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //执行foo函数 [self performSelector:@selector(foo)];&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; return YES;//返回YES，进入下一步转发&#125;- (id)forwardingTargetForSelector:(SEL)aSelector &#123; return nil;//返回nil，进入下一步转发&#125;- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123; if ([NSStringFromSelector(aSelector) isEqualToString:@&quot;foo&quot;]) &#123; return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];//签名，进入forwardInvocation &#125; return [super methodSignatureForSelector:aSelector];&#125;- (void)forwardInvocation:(NSInvocation *)anInvocation &#123; SEL sel = anInvocation.selector; Person *p = [Person new]; if([p respondsToSelector:sel]) &#123; [anInvocation invokeWithTarget:p]; &#125; else &#123; [self doesNotRecognizeSelector:sel]; &#125;&#125;@end 打印结果： 2018-04-01 13:00:45.423385+0800 ocram[88353:23279961] Doing foo 从打印结果来看，我们实现了完整的转发。通过签名，Runtime生成了一个对象anInvocation，发送给了forwardInvocation，我们在forwardInvocation方法里面让Person对象去执行了foo函数。签名参数v@:怎么解释呢，这里苹果文档Type Encodings有详细的解释。 以上就是Runtime的三次转发流程。下面我们讲讲Runtime的实际应用。 Runtime应用Runtime简直就是做大型框架的利器。它的应用场景非常多，下面就介绍一些常见的应用场景。 关联对象(Objective-C Associated Objects)给分类增加属性 方法魔法(Method Swizzling)方法添加和替换和KVO实现 消息转发(热更新)解决Bug(JSPatch) 实现NSCoding的自动归档和自动解档 实现字典和模型的自动转换(MJExtension) 关联对象(Objective-C Associated Objects)给分类增加属性我们都是知道分类是不能自定义属性和变量的。下面通过关联对象实现给分类添加属性。 关联对象Runtime提供了下面几个接口： 123456//关联对象void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)//获取关联的对象id objc_getAssociatedObject(id object, const void *key)//移除关联的对象void objc_removeAssociatedObjects(id object) 参数解释 1234id object：被关联的对象const void *key：关联的key，要求唯一id value：关联的对象objc_AssociationPolicy policy：内存管理的策略 内存管理的策略 1234567891011typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123; OBJC_ASSOCIATION_ASSIGN = 0, /**&lt; Specifies a weak reference to the associated object. */ OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&lt; Specifies a strong reference to the associated object. * The association is not made atomically. */ OBJC_ASSOCIATION_COPY_NONATOMIC = 3, /**&lt; Specifies that the associated object is copied. * The association is not made atomically. */ OBJC_ASSOCIATION_RETAIN = 01401, /**&lt; Specifies a strong reference to the associated object. * The association is made atomically. */ OBJC_ASSOCIATION_COPY = 01403 /**&lt; Specifies that the associated object is copied. * The association is made atomically. */&#125;; 下面实现一个UIView的Category添加自定义属性defaultColor。 1234567891011121314151617181920212223242526272829303132333435363738394041#import &quot;ViewController.h&quot;#import &quot;objc/runtime.h&quot;@interface UIView (DefaultColor)@property (nonatomic, strong) UIColor *defaultColor;@end@implementation UIView (DefaultColor)@dynamic defaultColor;static char kDefaultColorKey;- (void)setDefaultColor:(UIColor *)defaultColor &#123; objc_setAssociatedObject(self, &amp;kDefaultColorKey, defaultColor, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (id)defaultColor &#123; return objc_getAssociatedObject(self, &amp;kDefaultColorKey);&#125;@end@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. UIView *test = [UIView new]; test.defaultColor = [UIColor blackColor]; NSLog(@&quot;%@&quot;, test.defaultColor);&#125;@end 打印结果： 2018-04-01 15:41:44.977732+0800 ocram[2053:63739] UIExtendedGrayColorSpace 0 1 打印结果来看，我们成功在分类上添加了一个属性，实现了它的setter和getter方法。 通过关联对象实现的属性的内存管理也是有ARC管理的，所以我们只需要给定适当的内存策略就行了，不需要操心对象的释放。 我们看看内存测量对于的属性修饰。 内存策略 属性修饰 描述 OBJC_ASSOCIATION_ASSIGN @property (assign) 或 @property (unsafe_unretained) 指定一个关联对象的弱引用。 OBJC_ASSOCIATION_RETAIN_NONATOMIC @property (nonatomic, strong) @property (nonatomic, strong) 指定一个关联对象的强引用，不能被原子化使用。 OBJC_ASSOCIATION_COPY_NONATOMIC @property (nonatomic, copy) 指定一个关联对象的copy引用，不能被原子化使用。 OBJC_ASSOCIATION_RETAIN @property (atomic, strong) 指定一个关联对象的强引用，能被原子化使用。 OBJC_ASSOCIATION_COPY @property (atomic, copy) 指定一个关联对象的copy引用，能被原子化使用。 方法魔法(Method Swizzling)方法添加和替换和KVO实现方法添加实际上添加方法刚才在讲消息转发的时候，动态方法解析的时候就提到了。 12//class_addMethod(Class _Nullable __unsafe_unretained cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types)class_addMethod([self class], sel, (IMP)fooMethod, &quot;v@:&quot;); cls 被添加方法的类 name 添加的方法的名称的SEL imp 方法的实现。该函数必须至少要有两个参数，self,_cmd 类型编码 方法替换下面实现一个替换ViewController的viewDidLoad方法的例子。 12345678910111213141516171819202122232425262728293031323334353637@implementation ViewController+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class class = [self class]; SEL originalSelector = @selector(viewDidLoad); SEL swizzledSelector = @selector(jkviewDidLoad); Method originalMethod = class_getInstanceMethod(class,originalSelector); Method swizzledMethod = class_getInstanceMethod(class,swizzledSelector); //judge the method named swizzledMethod is already existed. BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); // if swizzledMethod is already existed. if (didAddMethod) &#123; class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125;);&#125;- (void)jkviewDidLoad &#123; NSLog(@&quot;替换的方法&quot;); [self jkviewDidLoad];&#125;- (void)viewDidLoad &#123; NSLog(@&quot;自带的方法&quot;); [super viewDidLoad];&#125;@end swizzling应该只在+load中完成。 在 Objective-C 的运行时中，每个类有两个方法都会自动调用。+load 是在一个类被初始装载时调用，+initialize 是在应用第一次调用该类的类方法或实例方法前调用的。两个方法都是可选的，并且只有在方法被实现的情况下才会被调用。 swizzling应该只在dispatch_once 中完成,由于swizzling 改变了全局的状态，所以我们需要确保每个预防措施在运行时都是可用的。原子操作就是这样一个用于确保代码只会被执行一次的预防措施，就算是在不同的线程中也能确保代码只执行一次。Grand Central Dispatch 的 dispatch_once满足了所需要的需求，并且应该被当做使用swizzling 的初始化单例方法的标准。 实现图解如下图。 从图中可以看出，我们通过swizzling特性，将selectorC的方法实现IMPc与selectorN的方法实现IMPn交换了，当我们调用selectorC，也就是给对象发送selectorC消息时，所查找到的对应的方法实现就是IMPn而不是IMPc了。 KVO实现 全称是Key-value observing，翻译成键值观察。提供了一种当其它对象属性被修改的时候能通知当前对象的机制。再MVC大行其道的Cocoa中，KVO机制很适合实现model和controller类之间的通讯。 KVO的实现依赖于 Objective-C 强大的 Runtime，当观察某对象 A 时，KVO 机制动态创建一个对象A当前类的子类，并为这个新的子类重写了被观察属性 keyPath 的 setter 方法。setter 方法随后负责通知观察对象属性的改变状况。 Apple 使用了 isa-swizzling 来实现 KVO 。当观察对象A时，KVO机制动态创建一个新的名为：NSKVONotifying_A的新类，该类继承自对象A的本类，且 KVO 为 NSKVONotifying_A 重写观察属性的 setter 方法，setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象属性值的更改情况。 NSKVONotifying_A 类剖析 12NSLog(@&quot;self-&gt;isa:%@&quot;,self-&gt;isa); NSLog(@&quot;self class:%@&quot;,[self class]); 在建立KVO监听前，打印结果为： 12self-&gt;isa:Aself class:A 在建立KVO监听之后，打印结果为： 12self-&gt;isa:NSKVONotifying_Aself class:A 在这个过程，被观察对象的 isa 指针从指向原来的 A 类，被KVO 机制修改为指向系统新创建的子类NSKVONotifying_A 类，来实现当前类属性值改变的监听；所以当我们从应用层面上看来，完全没有意识到有新的类出现，这是系统“隐瞒”了对 KVO 的底层实现过程，让我们误以为还是原来的类。但是此时如果我们创建一个新的名为“NSKVONotifying_A”的类，就会发现系统运行到注册 KVO 的那段代码时程序就崩溃，因为系统在注册监听的时候动态创建了名为 NSKVONotifying_A 的中间类，并指向这个中间类了。 子类setter方法剖析 KVO 的键值观察通知依赖于 NSObject 的两个方法:willChangeValueForKey:和 didChangeValueForKey: ，在存取数值的前后分别调用 2 个方法：被观察属性发生改变之前，willChangeValueForKey:被调用，通知系统该 keyPath 的属性值即将变更；当改变发生后， didChangeValueForKey: 被调用，通知系统该keyPath 的属性值已经变更；之后， observeValueForKey:ofObject:change:context:也会被调用。且重写观察属性的setter 方法这种继承方式的注入是在运行时而不是编译时实现的。 KVO 为子类的观察者属性重写调用存取方法的工作原理在代码中相当于： 12345- (void)setName:(NSString *)newName &#123; [self willChangeValueForKey:@&quot;name&quot;]; //KVO 在调用存取方法之前总调用 [super setValue:newName forKey:@&quot;name&quot;]; //调用父类的存取方法 [self didChangeValueForKey:@&quot;name&quot;]; //KVO 在调用存取方法之后总调用&#125; 消息转发(热更新)解决Bug(JSPatch) JSPatch 是一个 iOS 动态更新框架，只需在项目中引入极小的引擎，就可以使用 JavaScript 调用任何 Objective-C 原生接口，获得脚本语言的优势：为项目动态添加模块，或替换项目原生代码动态修复 bug。 关于消息转发，前面已经讲到过了，消息转发分为三级，我们可以在每级实现替换功能，实现消息转发，从而不会造成崩溃。JSPatch不仅能够实现消息转发，还可以实现方法添加、替换能一系列功能。 实现NSCoding的自动归档和自动解档原理描述：用runtime提供的函数遍历Model自身所有属性，并对属性进行encode和decode操作。 核心方法：在Model的基类中重写方法： 1234567891011121314151617181920212223242526272829303132//encode- (void)encodeWithCoder:(NSCoder *)aCoder &#123; unsigned int outCount; Ivar *ivars = class_copyIvarList([self class], &amp;outCount); for (int i = 0; i &lt; outCount; i++) &#123; Ivar ivar = ivars[i]; NSString *key = [NSString stringWithUTF8String:ivar_getName(ivar)]; [aCoder encodeObject:[self valueForKey:key] forKey:key]; &#125; free(ivars);//释放ivars&#125;//decode- (instancetype)initWithCoder:(NSCoder *)aDecoder &#123; self = [super init]; if (self) &#123; unsigned int outCount; Ivar *ivars = class_copyIvarList([self class], &amp;outCount); for (int i = 0; i &lt; outCount; i++) &#123; Ivar ivar = ivars[i]; NSString *key = [NSString stringWithUTF8String:ivar_getName(ivar)]; //解档 id value = [aDecoder decodeObjectForKey:key]; //设置 [self setValue:value forKey:key]; &#125; free(ivars);//释放ivars &#125; return self;&#125; 实现字典和模型的自动转换(MJExtension)原理描述：用runtime提供的函数遍历Model自身所有属性，如果属性在json中有对应的值，则将其赋值。 核心方法：在NSObject的分类中添加方法 12345678910111213141516171819202122232425262728293031323334- (instancetype)initWithDict:(NSDictionary *)dict &#123; if (self = [self init]) &#123; //(1)获取类的属性及属性对应的类型 NSMutableArray * keys = [NSMutableArray array]; NSMutableArray * attributes = [NSMutableArray array]; /* * 例子 * name = value3 attribute = T@&quot;NSString&quot;,C,N,V_value3 * name = value4 attribute = T^i,N,V_value4 */ unsigned int outCount; objc_property_t * properties = class_copyPropertyList([self class], &amp;outCount); for (int i = 0; i &lt; outCount; i ++) &#123; objc_property_t property = properties[i]; //通过property_getName函数获得属性的名字 NSString * propertyName = [NSString stringWithCString:property_getName(property) encoding:NSUTF8StringEncoding]; [keys addObject:propertyName]; //通过property_getAttributes函数可以获得属性的名字和@encode编码 NSString * propertyAttribute = [NSString stringWithCString:property_getAttributes(property) encoding:NSUTF8StringEncoding]; [attributes addObject:propertyAttribute]; &#125; //立即释放properties指向的内存 free(properties); //(2)根据类型给属性赋值 for (NSString * key in keys) &#123; if ([dict valueForKey:key] == nil) continue; [self setValue:[dict valueForKey:key] forKey:key]; &#125; &#125; return self;&#125; 以上就是Runtime应用的一些场景，本文到此结束了。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
        <tag>Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解RunLoop]]></title>
    <url>%2F2018%2F04%2F25%2FiOS%2FiOS%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3RunLoop%2F</url>
    <content type="text"><![CDATA[RunLoop 是 iOS 和 OSX 开发中非常基础的一个概念，这篇文章将从 CFRunLoop 的源码入手，介绍 RunLoop 的概念以及底层实现原理。之后会介绍一下在 iOS 中，苹果是如何利用 RunLoop 实现自动释放池、延迟回调、触摸事件、屏幕刷新等功能的。 RunLoop 的概念一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的： 1234567function loop() &#123; initialize(); do &#123; var message = get_next_message(); process_message(message); &#125; while (message != quit);&#125; 这种模型通常被称作 Event Loop。 Event Loop 在很多系统和框架里都有实现，比如 Node.js 的事件处理，比如 Windows 程序的消息循环，再比如 OSX/iOS 里的 RunLoop。实现这种模型的关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。 所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。 OSX/iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。 CFRunLoopRef 的代码是开源的，你可以在这里 http://opensource.apple.com/tarballs/CF/ 下载到整个 CoreFoundation 的源码来查看。 RunLoop 与线程的关系首先，iOS 开发中能遇到两个线程对象: pthread_t 和 NSThread。过去苹果有份文档/tn/tn2028.html)标明了 NSThread 只是 pthread_t 的封装，但那份文档已经失效了，现在它们也有可能都是直接包装自最底层的 mach thread。苹果并没有提供这两个对象相互转换的接口，但不管怎么样，可以肯定的是 pthread_t 和 NSThread 是一一对应的。比如，你可以通过 pthread_main_thread_np() 或 [NSThread mainThread] 来获取主线程；也可以通过 pthread_self() 或 [NSThread currentThread] 来获取当前线程。CFRunLoop 是基于 pthread 来管理的。 苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。 这两个函数内部的逻辑大概是下面这样: 1234567891011121314151617181920212223242526272829303132333435363738/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRefstatic CFMutableDictionaryRef loopsDic;/// 访问 loopsDic 时的锁static CFSpinLock_t loopsLock; /// 获取一个 pthread 对应的 RunLoop。CFRunLoopRef _CFRunLoopGet(pthread_t thread) &#123; OSSpinLockLock(&amp;loopsLock); if (!loopsDic) &#123; // 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。 loopsDic = CFDictionaryCreateMutable(); CFRunLoopRef mainLoop = _CFRunLoopCreate(); CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop); &#125; /// 直接从 Dictionary 里获取。 CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread)); if (!loop) &#123; /// 取不到时，创建一个 loop = _CFRunLoopCreate(); CFDictionarySetValue(loopsDic, thread, loop); /// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。 _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop); &#125; OSSpinLockUnLock(&amp;loopsLock); return loop;&#125; CFRunLoopRef CFRunLoopGetMain() &#123; return _CFRunLoopGet(pthread_main_thread_np());&#125; CFRunLoopRef CFRunLoopGetCurrent() &#123; return _CFRunLoopGet(pthread_self());&#125; 从上面的代码可以看出，线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。 RunLoop 对外的接口在 CoreFoundation 里面关于 RunLoop 有5个类: CFRunLoopRef CFRunLoopModeRef CFRunLoopSourceRef CFRunLoopTimerRef CFRunLoopObserverRef 其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下: 一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。 CFRunLoopSourceRef 是事件产生的地方。Source有两个版本：Source0 和 Source1。 Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。 Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。 CFRunLoopTimerRef 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。 CFRunLoopObserverRef 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个： 12345678typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Loop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出Loop&#125;; 上面的 Source/Timer/Observer 被统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。 RunLoop 的 ModeCFRunLoopMode 和 CFRunLoop 的结构大致如下： 12345678910111213141516struct __CFRunLoopMode &#123; CFStringRef _name; // Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot; CFMutableSetRef _sources0; // Set CFMutableSetRef _sources1; // Set CFMutableArrayRef _observers; // Array CFMutableArrayRef _timers; // Array ...&#125;; struct __CFRunLoop &#123; CFMutableSetRef _commonModes; // Set CFMutableSetRef _commonModeItems; // Set&lt;Source/Observer/Timer&gt; CFRunLoopModeRef _currentMode; // Current Runloop Mode CFMutableSetRef _modes; // Set ...&#125;; 这里有个概念叫 “CommonModes”：一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。 应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。 有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 “commonModeItems” 中。”commonModeItems” 被 RunLoop 自动更新到所有具有”Common”属性的 Mode 里去。 CFRunLoop对外暴露的管理 Mode 接口只有下面2个: 12CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);CFRunLoopRunInMode(CFStringRef modeName, ...); Mode 暴露的管理 mode item 的接口有下面几个： 123456CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode); 你只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop会自动帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。 苹果公开提供的 Mode 有两个：kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 和 UITrackingRunLoopMode，你可以用这两个 Mode Name 来操作其对应的 Mode。 同时苹果还提供了一个操作 Common 标记的字符串：kCFRunLoopCommonModes (NSRunLoopCommonModes)，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时注意区分这个字符串和其他 mode name。 RunLoop 的内部逻辑根据苹果在文档里的说明，RunLoop 内部的逻辑大致如下: 其内部代码整理如下 （太长了不想看可以直接跳过去，后面会有说明）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110/// 用DefaultMode启动void CFRunLoopRun(void) &#123; CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);&#125; /// 用指定的Mode启动，允许设置RunLoop超时时间int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) &#123; return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);&#125; /// RunLoop的实现int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) &#123; /// 首先根据modeName找到对应mode CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false); /// 如果mode里没有source/timer/observer, 直接返回。 if (__CFRunLoopModeIsEmpty(currentMode)) return; /// 1. 通知 Observers: RunLoop 即将进入 loop。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry); /// 内部函数，进入loop __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123; Boolean sourceHandledThisLoop = NO; int retVal = 0; do &#123; /// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers); /// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources); /// 执行被加入的block __CFRunLoopDoBlocks(runloop, currentMode); /// 4. RunLoop 触发 Source0 (非port) 回调。 sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle); /// 执行被加入的block __CFRunLoopDoBlocks(runloop, currentMode); /// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。 if (__Source0DidDispatchPortLastTime) &#123; Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg) if (hasMsg) goto handle_msg; &#125; /// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。 if (!sourceHandledThisLoop) &#123; __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting); &#125; /// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。 /// • 一个基于 port 的Source 的事件。 /// • 一个 Timer 到时间了 /// • RunLoop 自身的超时时间到了 /// • 被其他什么调用者手动唤醒 __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123; mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg &#125; /// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting); /// 收到消息，处理消息。 handle_msg: /// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。 if (msg_is_timer) &#123; __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time()) &#125; /// 9.2 如果有dispatch到main_queue的block，执行block。 else if (msg_is_dispatch) &#123; __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg); &#125; /// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件 else &#123; CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort); sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg); if (sourceHandledThisLoop) &#123; mach_msg(reply, MACH_SEND_MSG, reply); &#125; &#125; /// 执行加入到Loop的block __CFRunLoopDoBlocks(runloop, currentMode); if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123; /// 进入loop时参数说处理完事件就返回。 retVal = kCFRunLoopRunHandledSource; &#125; else if (timeout) &#123; /// 超出传入参数标记的超时时间了 retVal = kCFRunLoopRunTimedOut; &#125; else if (__CFRunLoopIsStopped(runloop)) &#123; /// 被外部调用者强制停止了 retVal = kCFRunLoopRunStopped; &#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123; /// source/timer/observer一个都没有了 retVal = kCFRunLoopRunFinished; &#125; /// 如果没超时，mode里没空，loop也没被停止，那继续loop。 &#125; while (retVal == 0); &#125; /// 10. 通知 Observers: RunLoop 即将退出。 __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);&#125; 可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。 RunLoop 的底层实现从上面代码可以看到，RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 mach_msg()。为了解释这个逻辑，下面稍微介绍一下 OSX/iOS 的系统架构。 苹果官方将整个系统大致划分为上述4个层次：应用层包括用户能接触到的图形应用，例如 Spotlight、Aqua、SpringBoard 等。应用框架层即开发人员接触到的 Cocoa 等框架。核心框架层包括各种核心框架、OpenGL 等内容。Darwin 即操作系统的核心，包括系统内核、驱动、Shell 等内容，这一层是开源的，其所有源码都可以在 opensource.apple.com 里找到。 我们在深入看一下 Darwin 这个核心的架构： 其中，在硬件层上面的三个组成部分：Mach、BSD、IOKit (还包括一些上面没标注的内容)，共同组成了 XNU 内核。XNU 内核的内环被称作 Mach，其作为一个微内核，仅提供了诸如处理器调度、IPC (进程间通信)等非常少量的基础服务。BSD 层可以看作围绕 Mach 层的一个外环，其提供了诸如进程管理、文件系统和网络等功能。IOKit 层是为设备驱动提供了一个面向对象(C++)的一个框架。 Mach 本身提供的 API 非常有限，而且苹果也不鼓励使用 Mach 的 API，但是这些API非常基础，如果没有这些API的话，其他任何工作都无法实施。在 Mach 中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为”对象”。和其他架构不同， Mach 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。”消息”是 Mach 中最基础的概念，消息在两个端口 (port) 之间传递，这就是 Mach 的 IPC (进程间通信) 的核心。 Mach 的消息定义是在 头文件的，很简单： 12345678910111213typedef struct &#123; mach_msg_header_t header; mach_msg_body_t body;&#125; mach_msg_base_t; typedef struct &#123; mach_msg_bits_t msgh_bits; mach_msg_size_t msgh_size; mach_port_t msgh_remote_port; mach_port_t msgh_local_port; mach_port_name_t msgh_voucher_port; mach_msg_id_t msgh_id;&#125; mach_msg_header_t; 一条 Mach 消息实际上就是一个二进制数据包 (BLOB)，其头部定义了当前端口 local_port 和目标端口 remote_port，发送和接受消息是通过同一个 API 进行的，其 option 标记了消息传递的方向： 12345678mach_msg_return_t mach_msg( mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify); 为了实现消息的发送和接收，mach_msg() 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数mach_msg_trap()，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会完成实际的工作，如下图： 这些概念可以参考维基百科: System_call、Trap_(computing))。 RunLoop 的核心就是一个 mach_msg() (见上面代码的第7步)，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 mach_msg_trap() 这个地方。 关于具体的如何利用 mach port 发送信息，可以看看 NSHipster 这一篇文章，或者这里的中文翻译 。 苹果用 RunLoop 实现的功能首先我们可以看一下 App 启动后 RunLoop 的状态： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899CFRunLoop &#123; current mode = kCFRunLoopDefaultMode common modes = &#123; UITrackingRunLoopMode kCFRunLoopDefaultMode &#125; common mode items = &#123; // source0 (manual) CFRunLoopSource &#123;order =-1, &#123; callout = _UIApplicationHandleEventQueue&#125;&#125; CFRunLoopSource &#123;order =-1, &#123; callout = PurpleEventSignalCallback &#125;&#125; CFRunLoopSource &#123;order = 0, &#123; callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125; // source1 (mach port) CFRunLoopSource &#123;order = 0, &#123;port = 17923&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 12039&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 16647&#125;&#125; CFRunLoopSource &#123;order =-1, &#123; callout = PurpleEventCallback&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 2407, callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 1c03, callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 1b03, callout = __IOHIDEventSystemClientQueueCallback&#125;&#125; CFRunLoopSource &#123;order = 1, &#123;port = 1903, callout = __IOMIGMachPortPortCallback&#125;&#125; // Ovserver CFRunLoopObserver &#123;order = -2147483647, activities = 0x1, // Entry callout = _wrapRunLoopWithAutoreleasePoolHandler&#125; CFRunLoopObserver &#123;order = 0, activities = 0x20, // BeforeWaiting callout = _UIGestureRecognizerUpdateObserver&#125; CFRunLoopObserver &#123;order = 1999000, activities = 0xa0, // BeforeWaiting | Exit callout = _afterCACommitHandler&#125; CFRunLoopObserver &#123;order = 2000000, activities = 0xa0, // BeforeWaiting | Exit callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125; CFRunLoopObserver &#123;order = 2147483647, activities = 0xa0, // BeforeWaiting | Exit callout = _wrapRunLoopWithAutoreleasePoolHandler&#125; // Timer CFRunLoopTimer &#123;firing = No, interval = 3.1536e+09, tolerance = 0, next fire date = 453098071 (-4421.76019 @ 96223387169499), callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125; &#125;, modes ＝ &#123; CFRunLoopMode &#123; sources0 = &#123; /* same as &apos;common mode items&apos; */ &#125;, sources1 = &#123; /* same as &apos;common mode items&apos; */ &#125;, observers = &#123; /* same as &apos;common mode items&apos; */ &#125;, timers = &#123; /* same as &apos;common mode items&apos; */ &#125;, &#125;, CFRunLoopMode &#123; sources0 = &#123; /* same as &apos;common mode items&apos; */ &#125;, sources1 = &#123; /* same as &apos;common mode items&apos; */ &#125;, observers = &#123; /* same as &apos;common mode items&apos; */ &#125;, timers = &#123; /* same as &apos;common mode items&apos; */ &#125;, &#125;, CFRunLoopMode &#123; sources0 = &#123; CFRunLoopSource &#123;order = 0, &#123; callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125; &#125;, sources1 = (null), observers = &#123; CFRunLoopObserver &gt;&#123;activities = 0xa0, order = 2000000, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125; )&#125;, timers = (null), &#125;, CFRunLoopMode &#123; sources0 = &#123; CFRunLoopSource &#123;order = -1, &#123; callout = PurpleEventSignalCallback&#125;&#125; &#125;, sources1 = &#123; CFRunLoopSource &#123;order = -1, &#123; callout = PurpleEventCallback&#125;&#125; &#125;, observers = (null), timers = (null), &#125;, CFRunLoopMode &#123; sources0 = (null), sources1 = (null), observers = (null), timers = (null), &#125; &#125;&#125; 可以看到，系统默认注册了5个Mode: kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。 UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。 UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。 GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。 kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。 你可以在这里看到更多的苹果内部的 Mode，但那些 Mode 在开发中就很难遇到了。 当 RunLoop 进行回调时，一般都是通过一个很长的函数调用出去 (call out), 当你在你的代码中下断点调试时，通常能在调用栈上看到这些函数。下面是这几个函数的整理版本，如果你在调用栈中看到这些长函数名，在这里查找一下就能定位到具体的调用地点了： 12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; /// 1. 通知Observers，即将进入RunLoop /// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush(); __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry); do &#123; /// 2. 通知 Observers: 即将触发 Timer 回调。 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers); /// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources); __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block); /// 4. 触发 Source0 (非基于port的) 回调。 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0); __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block); /// 6. 通知Observers，即将进入休眠 /// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush(); __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting); /// 7. sleep to wait msg. mach_msg() -&gt; mach_msg_trap(); /// 8. 通知Observers，线程被唤醒 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting); /// 9. 如果是被Timer唤醒的，回调Timer __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer); /// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block); /// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1); &#125; while (...); /// 10. 通知Observers，即将退出RunLoop /// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop(); __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);&#125; AutoreleasePoolApp启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。 第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。 第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。 在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。 事件响应苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。 当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。 _UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。 手势识别当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。 苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。 当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。 界面更新当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。 苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。 这个函数内部的调用栈大概是这样的： 1234567891011_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv() QuartzCore:CA::Transaction::observer_callback: CA::Transaction::commit(); CA::Context::commit_transaction(); CA::Layer::layout_and_display_if_needed(); CA::Layer::layout_if_needed(); [CALayer layoutSublayers]; [UIView layoutSubviews]; CA::Layer::display_if_needed(); [CALayer display]; [UIView drawRect]; 定时器NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。 如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。 CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop. PerformSelecter当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。 当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。 关于GCD当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。 关于网络请求iOS 中，关于网络请求的接口自下至上有如下几层: 1234CFSocketCFNetwork -&gt;ASIHttpRequestNSURLConnection -&gt;AFNetworkingNSURLSession -&gt;AFNetworking2, Alamofire CFSocket 是最底层的接口，只负责 socket 通信。 CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。 NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。 NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 (比如 com.apple.NSURLConnectionLoader 线程)，AFNetworking2 和 Alamofire 工作于这一层。 下面主要介绍下 NSURLConnection 的工作过程。 通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。 当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。 NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。 RunLoop 的实际应用举例AFNetworkingAFURLConnectionOperation 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop： 123456789101112131415161718+ (void)networkRequestThreadEntryPoint:(id)__unused object &#123; @autoreleasepool &#123; [[NSThread currentThread] setName:@&quot;AFNetworking&quot;]; NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; [runLoop run]; &#125;&#125; + (NSThread *)networkRequestThread &#123; static NSThread *_networkRequestThread = nil; static dispatch_once_t oncePredicate; dispatch_once(&amp;oncePredicate, ^&#123; _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil]; [_networkRequestThread start]; &#125;); return _networkRequestThread;&#125; RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。 12345678910- (void)start &#123; [self.lock lock]; if ([self isCancelled]) &#123; [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]]; &#125; else if ([self isReady]) &#123; self.state = AFOperationExecutingState; [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]]; &#125; [self.lock unlock];&#125; 当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。 AsyncDisplayKitAsyncDisplayKit是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下： UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，UI对象操作。 排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。 绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。 UI对象操作通常包括 UIView/CALayer 等 UI 对象的创建、设置属性和销毁。 其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果 （例如TextView创建时可能需要提前计算出文本的大小）。ASDK 所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟 (例如视图的创建、属性的调整)。 为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了 UIView/CALayer，它具有和 UIView/CALayer 相似的属性，例如 frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只通过 Node 来操作其内部的 UIView/CALayer，这样就可以将排版和绘制放入了后台线程。但是无论怎么操作，这些属性总需要在某个时刻同步到主线程的 UIView/CALayer 去。 ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS触摸事件的传递过程]]></title>
    <url>%2F2018%2F04%2F25%2FiOS%2FiOS%2FiOS%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BC%A0%E9%80%92%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[当指肚轻触屏幕，整个系统像沉睡的生灵突然被惊醒，然后经历过腥风血雨的一段奇幻旅行，最终又归于沉寂。 整个iOS触摸事件从产生到寂灭大致如下图： 起始阶段—&gt; cpu处于睡眠状态，等待事件发生—&gt; 手指触摸屏幕 系统响应阶段—&gt; 屏幕硬件感应到输入，并将感应到的事件传递给输入输出驱动IOKit—-&gt; IOKit.framework封装整个触摸事件为IOHIDEvent对象—-&gt; IOKit.framework通过IPC将事件转发给SpringBoard.app 以上是系统层的响应。系统感应到外界的输入，并将相应的输入封装成比较概括的IOHIDEvent对象，然后UIKit通过IOHIDEvent的类型，判断出相应事件应该由SpringBoard .app处理，直接通过mach port(IPC进程间通信)转发给SpringBoard.app。 SpringBoard.app就是iOS的系统桌面，当触摸事件发生时，也只有负责管理桌面的SpringBoard.app才知道如何正确的响应。因为触摸发生时，有可能用户正在桌面翻页找App，也有可能正处于在微信中刷朋友圈。 桌面响应阶段—-&gt; SpringBoard.app主线程Runloop收到IOKit.framework转发来的消息苏醒，并触发对应Mach Port的Source1回调__IOHIDEventSystemClientQueueCallback()。 —-&gt; 如果SpringBoard.app监测到有App在前台（记为xxxx.app），SpringBoard.app通过mach port(IPC进程间通信)转发给xxxx.app，如果SpringBoard.app监测到监测无前台App，则SpringBoard.app进入App内部响应阶段的第二段，记触发Source0回调。 App内部响应阶段—-&gt; 前台App主线程Runloop收到SpringBoard.app转发来的消息苏醒，并触发对应Mach Port的Source1回调__IOHIDEventSystemClientQueueCallback()。—-&gt; Source1回调内部触发Source0回调__UIApplicationHandleEventQueue()—-&gt; Soucre0回调内部，封装IOHIDEvent为UIEvent—-&gt; Soucre0回调内部调用UIApplication的sendEvent:方法，将UIEvent传给UIWindow—-&gt; 平时开发熟悉的触摸事件响应链从这开始了—-&gt; 通过递归调用UIView层级的hitTest(_:with:)，结合point(inside:with:)找到UIEvent中每一个UITouch所属的UIView（其实是想找到离触摸事件点最近的那个UIView）。这个过程是从UIView层级的最顶层往最底层递归查询，但这不是UIResponder响应链，事件响应是在UIEvent中每一个UITouch所属的UIView都确定之后方才开始。 但需要注意，以下三种情况UIView的hitTest(_:with:)不会被调用，也导致其子UIView的hitTest(_:with:)不会被调用，而之后响应事件是下向上传递的，这直接导致以下三种情况的UIView及其子UIView不接收任何触摸事件： userInteractionEnabled = NO hidden = YES alpha = 0.0~0.01之间 提示: UIImageView的userInteractionEnabled默认为NO,因此UIImageView以及它的子控件默认是不接收触摸事件的。 当把断点打在某个UIViewhitTest(_:with:)中时，对应的调用堆栈如下： —-&gt; 根据围绕UITouch所属的UIView及其祖先UIView的gesture recognizers，来确定一个UITouch的gestureRecognizers —-&gt; UITouch所属的UIView和gestureRecognizers收到此UITouch和相应的UIEvent，并按照UITouch所处的状态调用四大UITouch方法touchesBegan(_:with:) touchesMoved(_:with:) touchesEnded(_:with:) touchesCancelled(_:with:)中的一个。（事件响应开始） —-&gt; 对于UIView收到的UITouches事件（四大UITouch事件都是如此），则会按照UIResponder响应链一直往上传递，直到某个UIResponder因为主动响应触摸事件，切断了响应链（即不调用下一个UIResponder的响应方法），如果一直没有UIResponder做响应处理，则这些UITouches到达最后的响应者即UIApplication后，就被吃掉了，消失了。 —-&gt; 如果在事件响应过程中，有UIGestureRecognizer成功识别，则此UIGestureRecognizer将独自占有所需要的UITouches，这些UITouches所属的UIView及其他的UIGestureRecognizer的touchesCancelled(_:with:)方法将调用（如果在手势的代理中设置可以同时识别两个手势，则允许同时识别的手势均可以收到所需要的UITouches事件）。但与识别成功的UIGestureRecognizer无关的UITouches则会继续按照上述传递逻辑传递。也即允许两个手势同时识别，只要所占有的UITouches不相同。 —-&gt; 如果UIGestureRecognizer识别成功，则调用相应的action，处理对应的逻辑。如果某个UIResponder主动响应了触摸事件，则根据其本身的响应逻辑处理对应的业务，UIControl都是主动响应并切断UITouch的向上传递的。 —-&gt; UITouches事件流动完毕，整个系统重新进入睡眠等待下一个事件 总结从手指触碰到屏幕，UITouch大致经历三个阶段，系统处理阶段----&gt;SpringBoard.app处理阶段----&gt;前台App处理阶段，事实上日常开发只需知晓最后一个阶段即可，前两个阶段参考资料也不多，更多的还涉及系统底层，这里仅做简单介绍。]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIViewController和UIView不同加载方式的生命周期]]></title>
    <url>%2F2018%2F04%2F24%2FiOS%2FiOS%2FUIViewController%E5%92%8CUIView%E4%B8%8D%E5%90%8C%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[1 基本说明已经做了几年iOS开发了，对于UIViewController和UIView的生命周期一直不是太重视，导致有很多地方模糊。几天专门写了个Demo来来验证一下。 2 加载UIViewController每一种加载方式所调用的加载方法不同，而且还有一些细节地方不同。苹果为我们提供了四种默认的加载方式，接下来我们看看系统的四种方式，犹豫没有什么理论性的东西，我就直接上代码为主了： 通过XIB加载。 通过StoryBoard加载。 通过NSCoding协议加载。 通过代码加载。 2.1 用XIB加载UIViewController首先看初始化代码： 1234- (IBAction)loadControllerFromXIB:(id)sender &#123; XIBViewController *xibVC = [[XIBViewController alloc]initWithNibName:@&quot;XIBViewController&quot; bundle:[NSBundle mainBundle]]; [self.navigationController pushViewController:xibVC animated:YES];&#125; 当我们不实现loadView的时候打印结果: 1234567891011121314151617182018-04-24 17:26:08.799985+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] willMoveToSuperview2018-04-24 17:26:08.800237+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] willMoveToWindow2018-04-24 17:26:08.800931+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] didMoveToWindow2018-04-24 17:26:08.801165+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] didMoveToSuperview2018-04-24 17:26:08.801499+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] dealloc2018-04-24 17:30:25.472638+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] initWithNibName2018-04-24 17:30:25.474095+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] loadView2018-04-24 17:30:25.474368+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] viewDidLoad2018-04-24 17:30:25.474598+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] viewWillAppear2018-04-24 17:30:25.474752+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] loadViewIfNeeded2018-04-24 17:30:25.484713+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] viewWillLayoutSubviews2018-04-24 17:30:25.484896+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] viewDidLayoutSubviews2018-04-24 17:30:25.987213+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] viewDidAppear2018-04-24 17:30:25.987213+0800 UIViewController和UIView生命周期加载和卸载[59883:1192231] clickButton//pop以后2018-04-24 17:31:24.384741+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] viewWillDisappear2018-04-24 17:31:24.888131+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] viewDidDisappear2018-04-24 17:31:24.888403+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] dealloc 我发现一个很奇怪的现象。如果用XIB加载的控制器，并且实现了一个空loadView,那么我们在XIB设置的视图都失效了，应该是系统返回了一个默认的视图覆盖了。但是用Storyboard加载的视图，实现一个空的loadView则不会丢失Storyboard里面的视图，这个是用XIB和Storyboard的一个注意点。 1234-(void)loadView&#123; [super loadView]; NSLog(@&quot;loadView&quot;);&#125; 2.2 用Storyboard加载UIViewController初始化代码： 12345- (IBAction)laodControllerFromSB:(id)sender &#123; UIStoryboard *sb = [UIStoryboard storyboardWithName:@&quot;Second&quot; bundle:[NSBundle mainBundle]]; SBViewController *sbVC = [sb instantiateViewControllerWithIdentifier:@&quot;SBViewController&quot;]; [self.navigationController pushViewController:sbVC animated:YES];&#125; 运行结果： 123456789101112132018-04-24 17:31:49.174073+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] initWithCoder2018-04-24 17:31:49.174343+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] awakeFromNib2018-04-24 17:31:49.178285+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] loadView2018-04-24 17:31:49.178582+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] viewDidLoad2018-04-24 17:31:49.178791+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] viewWillAppear2018-04-24 17:31:49.178980+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] loadViewIfNeeded2018-04-24 17:31:49.188183+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] viewWillLayoutSubviews2018-04-24 17:31:49.188405+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] viewDidLayoutSubviews2018-04-24 17:31:49.691875+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] viewDidAppear//pop以后2018-04-24 17:32:04.990075+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] viewWillDisappear2018-04-24 17:32:05.493917+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] viewDidDisappear2018-04-24 17:32:05.494169+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] dealloc 对于Storyboard，使用一个空的loadView没有影响。 2.3 用NSCodeing加载UIViewController初始化代码： 12345//这里我就不实现NSCoding协议了，直接传入一个nil参数。- (IBAction)loadControllerFromCoder:(id)sender &#123; CoderViewController *coderVC = [[CoderViewController alloc]initWithCoder:nil]; [self.navigationController pushViewController:coderVC animated:YES];&#125; 运行结果： 1234567891011122018-04-24 17:32:24.710172+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] initWithCoder2018-04-24 17:32:24.711632+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] loadView2018-04-24 17:32:24.711926+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] viewDidLoad2018-04-24 17:32:24.712247+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] viewWillAppear2018-04-24 17:32:24.712434+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] loadViewIfNeeded2018-04-24 17:32:24.722093+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] viewWillLayoutSubviews2018-04-24 17:32:24.722220+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] viewDidLayoutSubviews2018-04-24 17:32:25.223966+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] viewDidAppear//pop以后2018-04-24 17:32:39.395215+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] viewWillDisappear2018-04-24 17:32:39.898003+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] viewDidDisappear2018-04-24 17:32:39.898269+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] dealloc 2.4 用代码加载UIViewController初始化代码: 1234- (IBAction)loadControllerWithNone:(id)sender &#123; CodeViewController *codeVC = [[CodeViewController alloc]init]; [self.navigationController pushViewController:codeVC animated:YES];&#125; 运行结果： 1234567891011122018-04-24 17:32:56.444591+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] initWithNibName2018-04-24 17:32:56.446164+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] loadView2018-04-24 17:32:56.446451+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] viewDidLoad2018-04-24 17:32:56.446689+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] viewWillAppear2018-04-24 17:32:56.446863+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] loadViewIfNeeded2018-04-24 17:32:56.456733+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] viewWillLayoutSubviews2018-04-24 17:32:56.456898+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] viewDidLayoutSubviews2018-04-24 17:32:56.958470+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] viewDidAppear//pop以后2018-04-24 17:33:06.696999+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] viewWillDisappear2018-04-24 17:33:07.200255+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] viewDidDisappear2018-04-24 17:33:07.200511+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] dealloc 3 加载UIView3.1 用XIB加载UIView初始化代码: 1234- (IBAction)loadViewFromXib:(id)sender &#123; XibView *xibView = [[[NSBundle mainBundle]loadNibNamed:@&quot;XIBView&quot; owner:self options:nil] lastObject]; [self.view addSubview:xibView];&#125; 运行结果： 12345678910111213142018-04-24 17:33:20.803998+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] initWithCoder2018-04-24 17:33:20.804249+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] awakeFromNib2018-04-24 17:33:20.804455+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] willMoveToWindow2018-04-24 17:33:20.804610+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] willMoveToSuperview2018-04-24 17:33:20.804996+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] didMoveToWindow2018-04-24 17:33:20.805238+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] didMoveToSuperview2018-04-24 17:33:20.805362+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] setNeedsLayout2018-04-24 17:33:20.805966+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] layoutSubviews//这里是点击移除以后2018-04-24 17:33:32.628030+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] willMoveToSuperview2018-04-24 17:33:32.628204+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] willMoveToWindow2018-04-24 17:33:32.628591+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] didMoveToWindow2018-04-24 17:33:32.628709+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] didMoveToSuperview2018-04-24 17:33:32.628892+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] dealloc 3.2 用代码加载UIView初始化代码： 123456- (IBAction)loadViewWithNone:(id)sender &#123; CodeView *codeView = [[CodeView alloc]init]; codeView.backgroundColor = [UIColor greenColor]; codeView.frame = CGRectMake(0, 500, 100, 50); [self.view addSubview:codeView];&#125; 运行结果： 12345678910111213142018-04-24 17:33:47.292690+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] initWithFrame2018-04-24 17:33:47.292908+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] init2018-04-24 17:33:47.293115+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] willMoveToWindow2018-04-24 17:33:47.293290+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] willMoveToSuperview2018-04-24 17:33:47.293542+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] didMoveToWindow2018-04-24 17:33:47.293773+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] didMoveToSuperview2018-04-24 17:33:47.294269+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] layoutSubviews//点击移除以后2018-04-24 17:34:03.861096+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] willMoveToSuperview2018-04-24 17:34:03.861271+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] willMoveToWindow2018-04-24 17:34:03.861589+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] didMoveToWindow2018-04-24 17:34:03.861691+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] didMoveToSuperview2018-04-24 17:34:03.861847+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] 点击移除2018-04-24 17:34:03.862060+0800 UIViewController和UIView生命周期加载和卸载[42121:1546481] dealloc 4 总结UIViewController不同加载方式钩子函数总结： XIB加载方式 initWithNibName loadView(注意：如果实现一个空的方法，则XIB设置的属性无效，会覆盖XIB中的设置) viewDidLoad viewWillAppear loadViewIfNeeded viewWillLayoutSubviews viewDidLayoutSubviews viewDidAppear Storyboard加载方式 initWithCoder awakeFromNib loadView(实现是一个空方法或者不实现没有影响) viewDidLoad viewWillAppear loadViewIfNeeded viewWillLayoutSubviews viewDidLayoutSubviews viewDidAppear NSCoding加载方式 initWithCoder loadView viewDidLoad viewWillAppear loadViewIfNeeded viewWillLayoutSubviews viewDidLayoutSubviews viewDidAppear 代码加载方式 initWithNibName init(这个是我初始化的时候主动调用,如果用initWithNibName传入nil参数则不会调用) loadView viewDidLoad viewWillAppear loadViewIfNeeded viewWillLayoutSubviews viewDidLayoutSubviews viewDidAppear 我们可以发现，代码加载方式和XIB加载方式一模一样，如果有XIB则加载XIB，如果没有XIB则可以代码添加视图。 UIView不同加载方式钩子函数总结： XIB加载方式 initWithCoder awakeFromNib willMoveToWindow willMoveToSuperview didMoveToWindow didMoveToSuperview setNeedsLayout layoutSubviews 代码加载方式 initWithFrame(设置frame。) init(init方法调用) willMoveToWindow willMoveToSuperview didMoveToWindow didMoveToSuperview setNeedsLayout layoutSubviews 我们发现，如果通过init初始化，然后手动设置Frame。则会导致上面的调用顺序。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS事件的传递和响应机制-原理篇]]></title>
    <url>%2F2018%2F04%2F23%2FiOS%2FiOS%2FiOS%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BC%A0%E9%80%92%E5%92%8C%E5%93%8D%E5%BA%94%E6%9C%BA%E5%88%B6-%E5%8E%9F%E6%9D%A5%E7%AF%87%2F</url>
    <content type="text"><![CDATA[前言按照时间顺序，事件的生命周期是这样的： 事件的产生和传递（事件如何从父控件传递到子控件并寻找到最合适的view、寻找最合适的view的底层实现、拦截时间的处理）-&gt;找到最合适的view后事件的处理（touches方法的重写，也就是事件的响应） 其中重点和难点是： 1. 如何寻找最合适的view 2. 寻找最合适的view的底层实现（hitTest：withEvent：底层实现） （一）iOS中的事件iOS中的事件可以分为3大类型： 触摸事件 加速计事件 远程控制事件这里我们只讲触摸事件。 响应者（UIResponder）学习触摸事件首先要了解一个比较重要的概念-响应者对象（UIResponder）。 在iOS中不是任何对象都能处理事件，只有继承了UIResponder的对象才能接受并处理事件，我们称之为“响应者对象”。以下都是继承自UIResponder的，所以都能接收并处理事件。 UIApplication UIViewController UIView 因为UIResponder中提供了以下4个对象方法来处理触摸事件。 1234567891011UIResponder内部提供了以下方法来处理事件触摸事件- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event; 加速计事件- (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event;- (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event;- (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event;远程控制事件- (void)remoteControlReceivedWithEvent:(UIEvent *)event; （二）事件的处理下面以UIView为例来说明触摸事件的处理。 12345678910// UIView是UIResponder的子类，可以覆盖下列4个方法处理不同的触摸事件// 一根或者多根手指开始触摸view，系统会自动调用view的下面方法- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event// 一根或者多根手指在view上移动，系统会自动调用view的下面方法（随着手指的移动，会持续调用该方法）- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event// 一根或者多根手指离开view，系统会自动调用view的下面方法- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event// 触摸结束前，某个系统事件(例如电话呼入)会打断触摸过程，系统会自动调用view的下面方法- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event// 提示：touches中存放的都是UITouch对象 需要注意的是：以上四个方法是由系统自动调用的，所以可以通过重写该方法来处理一些事件。 如果两根手指同时触摸一个view，那么view只会调用一次touchesBegan:withEvent:方法，touches参数中装着2个UITouch对象 如果这两根手指一前一后分开触摸同一个view，那么view会分别调用2次touchesBegan:withEvent:方法，并且每次调用时的touches参数中只包含一个UITouch对象 重写以上四个方法，如果是处理UIView的触摸事件。必须要自定义UIView子类继承自UIView。因为苹果不开源，没有把UIView的.m文件提 供给我们。我们只能通过子类继承父类，重写子类方法的方式处理UIView的触摸事件（注意：我说的是UIView触摸事件而不是说的 UIViewController的触摸事件）。 如果是处理UIViewController的触摸事件，那么在控制器的.m文件中直接重写那四个方法即可！ /**自定义UIView的.h文件**/ 1234#import &lt;UIKit/UIKit.h&gt;@interface WSView : UIView@end /**自定义UIView的.m文件*/ 12345678910111213141516#import &quot;WSView.h&quot;@implementation WSView// 开始触摸时就会调用一次这个方法- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; NSLog(@&quot;摸我干啥！&quot;);&#125;// 手指移动就会调用这个方法// 这个方法调用非常频繁- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event&#123; NSLog(@&quot;哎呀，不要拽人家！&quot;);&#125;// 手指离开屏幕时就会调用一次这个方法- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event&#123; NSLog(@&quot;手放开还能继续玩耍！&quot;);&#125;@end 注 意：有人认为，我要是处理控制器的自带的view的事件就不需要自定义UIView子类继承于UIView，因为可以在viewController.m 文件中重写touchBegan:withEvent:方法，但是，我们此处讨论的是处理UIView的触摸事件，而不是处理 UIViewController的触摸事件。你如果是在viewController.m文件中重写touchBegan:withEvent:方法，相当于处理的是viewController的触摸事件，因为viewController也是继承自UIResponder，所以会给人一种错觉。所以，还是那句话，想处理UIView的触摸事件，必须自定义UIView子类继承自UIView。 2.1.UIView的拖拽那么，如何实现UIView的拖拽呢?也就是让UIView随着手指的移动而移动。 - 重写touchsMoved:withEvent:方法此时需要用到参数touches，下面是UITouch的属性和方法： 12345678910111213141516171819202122NS_CLASS_AVAILABLE_IOS(2_0) @interface UITouch : NSObject@property(nonatomic,readonly) NSTimeInterval timestamp;@property(nonatomic,readonly) UITouchPhase phase;@property(nonatomic,readonly) NSUInteger tapCount; // touch down within a certain point within a certain amount of time// majorRadius and majorRadiusTolerance are in points// The majorRadius will be accurate +/- the majorRadiusTolerance@property(nonatomic,readonly) CGFloat majorRadius NS_AVAILABLE_IOS(8_0);@property(nonatomic,readonly) CGFloat majorRadiusTolerance NS_AVAILABLE_IOS(8_0);@property(nullable,nonatomic,readonly,strong) UIWindow *window;@property(nullable,nonatomic,readonly,strong) UIView *view;@property(nullable,nonatomic,readonly,copy) NSArray &lt;UIGestureRecognizer *&gt; *gestureRecognizers NS_AVAILABLE_IOS(3_2);- (CGPoint)locationInView:(nullable UIView *)view;- (CGPoint)previousLocationInView:(nullable UIView *)view;// Force of the touch, where 1.0 represents the force of an average touch@property(nonatomic,readonly) CGFloat force NS_AVAILABLE_IOS(9_0);// Maximum possible force with this input mechanism@property(nonatomic,readonly) CGFloat maximumPossibleForce NS_AVAILABLE_IOS(9_0); 2.1.1.UITouch对象 当用户用一根手指触摸屏幕时，会创建一个与手指相关的UITouch对象 一根手指对应一个UITouch对象 如果两根手指同时触摸一个view，那么view只会调用一次touchesBegan:withEvent:方法，touches参数中装着2个UITouch对象 如果这两根手指一前一后分开触摸同一个view，那么view会分别调用2次touchesBegan:withEvent:方法，并且每次调用时的touches参数中只包含一个UITouch对象 2.1.1.1.UITouch的作用 保存着跟手指相关的信息，比如触摸的位置、时间、阶段 当手指移动时，系统会更新同一个UITouch对象，使之能够一直保存该手指在的触摸位置 当手指离开屏幕时，系统会销毁相应的UITouch对象 提 示:iPhone开发中，要避免使用双击事件！ 2.1.1.2.UITouch的属性123456789101112131415触摸产生时所处的窗口@property(nonatomic,readonly,retain) UIWindow *window;触摸产生时所处的视图@property(nonatomic,readonly,retain) UIView *view;短时间内点按屏幕的次数，可以根据tapCount判断单击、双击或更多的点击@property(nonatomic,readonly) NSUInteger tapCount;记录了触摸事件产生或变化时的时间，单位是秒@property(nonatomic,readonly) NSTimeInterval timestamp;当前触摸事件所处的状态@property(nonatomic,readonly) UITouchPhase phase; 2.1.1.3.UITouch的方法1234567(CGPoint)locationInView:(UIView *)view;// 返回值表示触摸在view上的位置// 这里返回的位置是针对view的坐标系的（以view的左上角为原点(0, 0)）// 调用时传入的view参数为nil的话，返回的是触摸点在UIWindow的位置(CGPoint)previousLocationInView:(UIView *)view;// 该方法记录了前一个触摸点的位置 代码实现： 1234567891011121314151617181920- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event&#123; // 想让控件随着手指移动而移动,监听手指移动 // 获取UITouch对象 UITouch *touch = [touches anyObject]; // 获取当前点的位置 CGPoint curP = [touch locationInView:self]; // 获取上一个点的位置 CGPoint preP = [touch previousLocationInView:self]; // 获取它们x轴的偏移量,每次都是相对上一次 CGFloat offsetX = curP.x - preP.x; // 获取y轴的偏移量 CGFloat offsetY = curP.y - preP.y; // 修改控件的形变或者frame,center,就可以控制控件的位置 // 形变也是相对上一次形变(平移) // CGAffineTransformMakeTranslation:会把之前形变给清空,重新开始设置形变参数 // make:相对于最原始的位置形变 // CGAffineTransform t:相对这个t的形变的基础上再去形变 // 如果相对哪个形变再次形变,就传入它的形变 self.transform = CGAffineTransformTranslate(self.transform, offsetX, offsetY);&#125; （三）iOS中的事件的产生和传递3.1.事件的产生 发生触摸事件后，系统会将该事件加入到一个由UIApplication管理的事件队列中,为什么是队列而不是栈？因为队列的特点是FIFO，即先进先出，先产生的事件先处理才符合常理，所以把事件添加到队列。 UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口（keyWindow）。 主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件，这也是整个事件处理过程的第一步。找到合适的视图控件后，就会调用视图控件的touches方法来作具体的事件处理。 3.2.事件的传递 触摸事件的传递是从父控件传递到子控件 也就是UIApplication-&gt;window-&gt;寻找处理事件最合适的view 注 意: 如果父控件不能接受触摸事件，那么子控件就不可能接收到触摸事件 应用如何找到最合适的控件来处理事件？ 1.首先判断主窗口（keyWindow）自己是否能接受触摸事件 2.判断触摸点是否在自己身上 3.子控件数组中从后往前遍历子控件，重复前面的两个步骤（所谓从后往前遍历子控件，就是首先查找子控件数组中最后一个元素，然后执行1、2步骤） 4.view，比如叫做fitView，那么会把这个事件交给这个fitView，再遍历这个fitView的子控件，直至没有更合适的view为止。 5.如果没有符合条件的子控件，那么就认为自己最合适处理这个事件，也就是自己是最合适的view。 UIView不能接收触摸事件的三种情况： 不允许交互：userInteractionEnabled = NO 隐藏：如果把父控件隐藏，那么子控件也会隐藏，隐藏的控件不能接受事件 透明度：如果设置一个控件的透明度&lt;0.01，会直接影响子控件的透明度。alpha：0.0~0.01为透明。 注意：默认UIImageView不能接受触摸事件，因为不允许交互，即userInteractionEnabled = NO。所以如果希望UIImageView可以交互，需要设置UIImageView的userInteractionEnabled = YES。 总结一下 点击一个UIView或产生一个触摸事件A，这个触摸事件A就会被添加到由UIApplication管理的事件队列中（即，首先接收到事件的是UIApplication）。 UIApplication会从事件队列中取出最前面的事件（此处假设为触摸事件为A），把事件A传递到给应用的主窗口（keyWindow）。 窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件。（至此第一步已完成） 如果想让某个view不能处理事件（或者说，事件传递到某个view那里就断了），那么可以通过刚才提到的三种方式。比如，设置其userInteractionEnabled = NO;那么传递下来的事件就会由该view的父控件处理。例如，不想让蓝色的view接收事件，那么可以设置蓝色的view的userInteractionEnabled = NO;那么点击黄色的view或者蓝色的view所产生的事件，最终会由橙色的view处理，橙色的view就会成为最合适的view。所以，不管视图能不能处理事件，只要点击了视图就都会产生事件，关键在于该事件最终是由谁来处理！也就是说，如果蓝色视图不能处理事件，点击蓝色视图产生的触摸事件不会由被点击的视图（蓝色视图）处理！注意：如果设置父控件的透明度或者hidden，会直接影响到子控件的透明度和hidden。如果父控件的透明度为0或者hidden = YES，那么子控件也是不可见的！ 3.3.（重难点）如何寻找最合适的view应用如何找到最合适的控件来处理事件？ 首先判断主窗口（keyWindow）自己是否能接受触摸事件 触摸点是否在自己身上 从后往前遍历子控件，重复前面的两个步骤（首先查找数组中最后一个元素） 如果没有符合条件的子控件，那么就认为自己最合适处理 详述： 主窗口接收到应用程序传递过来的事件后，首先判断自己能否接手触摸事件。如果能，那么在判断触摸点在不在窗口自己身上 如果触摸点也在窗口身上，那么窗口会从后往前遍历自己的子控件（遍历自己的子控件只是为了寻找出来最合适的view） 遍历到每一个子控件后，又会重复上面的两个步骤（传递事件给子控件，1.判断子控件能否接受事件，2.点在不在子控件上） 如此循环遍历子控件，直到找到最合适的view，如果没有更合适的子控件，那么自己就成为最合适的view。 找到最合适的view后，就会调用该view的touches方法处理具体的事件。所以，只有找到最合适的view，把事件传递给最合适的view后，才会调用touches方法进行接下来的事件处理。找不到最合适的view，就不会调用touches方法进行事件处理。注意：之所以会采取从后往前遍历子控件的方式寻找最合适的view只是为了做一些循环优化。因为相比较之下，后添加的view在上面，降低循环次数。 3.3.1.寻找最合适的view底层剖析两个重要的方法： hitTest:withEvent:方法 pointInside方法 3.3.1.1.hitTest：withEvent：方法什么时候调用？ 只要事件一传递给一个控件,这个控件就会调用他自己的hitTest：withEvent：方法 作用 寻找并返回最合适的view(能够响应事件的那个最合适的view) 注 意：不管这个控件能不能处理事件，也不管触摸点在不在这个控件上，事件都会先传递给这个控件，随后再调用hitTest:withEvent:方法 拦截事件的处理 正因为hitTest：withEvent：方法可以返回最合适的view，所以可以通过重写hitTest：withEvent：方法，返回指定的view作为最合适的view。 不管点击哪里，最合适的view都是hitTest：withEvent：方法中返回的那个view。 通过重写hitTest：withEvent：，就可以拦截事件的传递过程，想让谁处理事件谁就处理事件。 事件传递给谁，就会调用谁的hitTest:withEvent:方法。 注 意：如果hitTest:withEvent:方法中返回nil，那么调用该方法的控件本身和其子控件都不是最合适的view，也就是在自己身上没有找到更合适的view。那么最合适的view就是该控件的父控件。 所以事件的传递顺序是这样的：产生触摸事件-&gt;UIApplication事件队列-&gt;[UIWindow hitTest:withEvent:]-&gt;返回更合适的view-&gt;[子控件 hitTest:withEvent:]-&gt;返回最合适的view 事件传递给窗口或控件的后，就调用hitTest:withEvent:方法寻找更合适的view。所以是，先传递事件，再根据事件在自己身上找更合适的view。不管子控件是不是最合适的view，系统默认都要先把事件传递给子控件，经过子控件调用子控件自己的hitTest:withEvent:方法验证后才知道有没有更合适的view。即便父控件是最合适的view了，子控件的hitTest:withEvent:方法还是会调用，不然怎么知道有没有更合适的！即，如果确定最终父控件是最合适的view，那么该父控件的子控件的hitTest:withEvent:方法也是会被调用的。 技巧：想让谁成为最合适的view就重写谁自己的父控件的hitTest:withEvent:方法返回指定的子控件，或者重写自己的hitTest:withEvent:方法 return self。但是，建议在父控件的hitTest:withEvent:中返回子控件作为最合适的view！ 原因：在于在自己的hitTest:withEvent:方法中返回自己有时候会出现问题。因为会存在这么一种情况：当遍历子控件时，如果触摸点不在子控件A自己身上而是在子控件B身上，还要要求返回子控件A作为最合适的view，采用返回自己的方法可能会导致还没有来得及遍历A自己，就有可能已经遍历了点真正所在的view，也就是B。这就导致了返回的不是自己而是触摸点真正所在的view。所以还是建议在父控件的hitTest:withEvent:中返回子控件作为最合适的view！ 例如：whiteView有redView和greenView两个子控件。redView先添加，greenView后添加。如果要求无论点击那里都要让redView作为最合适的view（把事件交给redView来处理）那么只能在whiteView的hitTest:withEvent:方法中return self.subViews[0];这种情况下在redView的hitTest:withEvent:方法中return self;是不好使的！ 123456789101112131415161718192021// 这里redView是whiteView的第0个子控件#import &quot;redView.h&quot;@implementation redView- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; return self;&#125;- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; NSLog(@&quot;red-touch&quot;);&#125;@end// 或者#import &quot;whiteView.h&quot;@implementation whiteView- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; return self.subviews[0];&#125;- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; NSLog(@&quot;white-touch&quot;);&#125;@end 特殊情况：谁都不能处理事件，窗口也不能处理。 重写window的hitTest：withEvent：方法return nil 只能有窗口处理事件。 控制器的view的hitTest：withEvent：方法return nil或者window的hitTest：withEvent：方法return self return nil的含义：hitTest：withEvent：中return nil的意思是调用当前hitTest：withEvent：方法的view不是合适的view，子控件也不是合适的view。如果同级的兄弟控件也没有合适的view，那么最合适的view就是父控件。 寻找最合适的view底层剖析之hitTest：withEvent：方法底层做法/* hitTest:withEvent:方法底层实现 */ 12345678910111213141516171819202122232425262728293031323334353637383940#import &quot;WSWindow.h&quot;@implementation WSWindow// 什么时候调用:只要事件一传递给一个控件，那么这个控件就会调用自己的这个方法// 作用:寻找并返回最合适的view// UIApplication -&gt; [UIWindow hitTest:withEvent:]寻找最合适的view告诉系统// point:当前手指触摸的点// point:是方法调用者坐标系上的点- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; // 1.判断下窗口能否接收事件 if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt;= 0.01) return nil; // 2.判断下点在不在窗口上 // 不在窗口上 if ([self pointInside:point withEvent:event] == NO) return nil; // 3.从后往前遍历子控件数组 int count = (int)self.subviews.count; for (int i = count - 1; i &gt;= 0; i--) &#123; // 获取子控件 UIView *childView = self.subviews[i]; // 坐标系的转换,把窗口上的点转换为子控件上的点 // 把自己控件上的点转换成子控件上的点 CGPoint childP = [self convertPoint:point toView:childView]; UIView *fitView = [childView hitTest:childP withEvent:event]; if (fitView) &#123; // 如果能找到最合适的view return fitView; &#125; &#125; // 4.没有找到更合适的view，也就是没有比自己更合适的view return self; &#125; // 作用:判断下传入过来的点在不在方法调用者的坐标系上 // point:是方法调用者坐标系上的点 //- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event //&#123; // return NO; //&#125; - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; NSLog(@&quot;%s&quot;,__func__); &#125; @end hit:withEvent:方法底层会调用pointInside:withEvent:方法判断点在不在方法调用者的坐标系上。 3.3.1.2.pointInside:withEvent:方法pointInside:withEvent:方法判断点在不在当前view上（方法调用者的坐标系上）如果返回YES，代表点在方法调用者的坐标系上;返回NO代表点不在方法调用者的坐标系上，那么方法调用者也就不能处理事件。 3.3.2.练习屏幕上现在有一个viewA，viewA有一个subView叫做viewB，要求触摸viewB时,viewB会响应事件，而触摸viewA本身，不会响应该事件。如何实现？ 1234567- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; UIView *view = [super hitTest:point withEvent:event]; if (view == self) &#123; return nil; &#125; return view;&#125; （四）事件的响应4.1.触摸事件处理的整体过程 用户点击屏幕后产生的一个触摸事件，经过一系列的传递过程后，会找到最合适的视图控件来处理这个事件 找到最合适的视图控件后，就会调用控件的touches方法来作具体的事件处理touchesBegan…touchesMoved…touchedEnded… 这些touches方法的默认做法是将事件顺着响应者链条向上传递（也就是touch方法默认不处理事件，只传递事件），将事件交给上一个响应者进行处理 4.2.响应者链条示意图响应者链条：在iOS程序中无论是最后面的UIWindow还是最前面的某个按钮，它们的摆放是有前后关系的，一个控件可以放到另一个控件上面或下面，那么用户点击某个控件时是触发上面的控件还是下面的控件呢，这种先后关系构成一个链条就叫“响应者链”。也可以说，响应者链是由多个响应者对象连接起来的链条。在iOS中响应者链的关系可以用下图表示： 响应者对象：能处理事件的对象，也就是继承自UIResponder的对象作用：能很清楚的看见每个响应者之间的联系，并且可以让一个事件多个对象处理。 如何判断上一个响应者 1.如果当前这个view是控制器的view,那么控制器就是上一个响应者 2.如果当前这个view不是控制器的view,那么父控件就是上一个响应者 响应者链的事件传递过程: 1.如果当前view是控制器的view，那么控制器就是上一个响应者，事件就传递给控制器；如果当前view不是控制器的view，那么父视图就是当前view的上一个响应者，事件就传递给它的父视图 2.在视图层次结构的最顶级视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理 3.如果window对象也不处理，则其将事件或消息传递给UIApplication对象 4.如果UIApplication也不能处理该事件或消息，则将其丢弃 事件处理的整个流程总结： 1.触摸屏幕产生触摸事件后，触摸事件会被添加到由UIApplication管理的事件队列中（即，首先接收到事件的是UIApplication）。 2.UIApplication会从事件队列中取出最前面的事件，把事件传递给应用程序的主窗口（keyWindow）。 3.主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件。（至此，第一步已完成) 4.最合适的view会调用自己的touches方法处理事件 5.touches默认做法是把事件顺着响应者链条向上抛。 touches的默认做法： 1234567891011#import &quot;WSView.h&quot;@implementation WSView //只要点击控件,就会调用touchBegin,如果没有重写这个方法,自己处理不了触摸事件// 上一个响应者可能是父控件- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; // 默认会把事件传递给上一个响应者,上一个响应者是父控件,交给父控件处理[super touchesBegan:touches withEvent:event]; // 注意不是调用父控件的touches方法，而是调用父类的touches方法// super是父类 superview是父控件 &#125;@end 事件的传递与响应： 1、当一个事件发生后，事件会从父控件传给子控件，也就是说由UIApplication -&gt; UIWindow -&gt; UIView -&gt; initial view,以上就是事件的传递，也就是寻找最合适的view的过程。 2、接下来是事件的响应。首先看initial view能否处理这个事件，如果不能则会将事件传递给其上级视图（inital view的superView）；如果上级视图仍然无法处理则会继续往上传递；一直传递到视图控制器view controller，首先判断视图控制器的根视图view是否能处理此事件；如果不能则接着判断该视图控制器能否处理此事件，如果还是不能则继续向上传递；（对于第二个图视图控制器本身还在另一个视图控制器中，则继续交给父视图控制器的根视图，如果根视图不能处理则交给父视图控制器处理）；一直到 window，如果window还是不能处理此事件则继续交给application处理，如果最后application还是不能处理此事件则将其丢弃 3、在事件的响应中，如果某个控件实现了touches…方法，则这个事件将由该控件来接受，如果调用了[supertouches….];就会将事件顺着响应者链条往上传递，传递给上一个响应者；接着就会调用上一个响应者的touches….方法 如何做到一个事件多个对象处理：因为系统默认做法是把事件上抛给父控件，所以可以通过重写自己的touches方法和父控件的touches方法来达到一个事件多个对象处理的目的。 123456- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; // 1.自己先处理事件...NSLog(@&quot;do somthing...&quot;);// 2.再调用系统的默认做法，再把事件交给上一个响应者处理[super touchesBegan:touches withEvent:event]; &#125; 事件的传递和响应的区别：事件的传递是从上到下（父控件到子控件），事件的响应是从下到上（顺着响应者链条向上传递：子控件到父控件。]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift访问控制]]></title>
    <url>%2F2018%2F04%2F18%2FiOS%2FSwift%E8%AF%AD%E6%B3%95%2FSwift%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[前言本文章主要让大家了解掌握Swift中一些关键字的作用。 模块和源文件Swift的访问控制模型基于模块和源文件的概念。 模块是单一的代码分配单元———— 一个框架或应用程序会作为独立的单元构建和发布并且可以使用Swift的import关键字导入另一个模块。 Xcode 中的每个构建目标（例如应用程序包或框架）在 Swift 中被视为一个独立的模块。 如果你将应用程序的代码作为独立的框架组合在一起——或许可以在多个应用程序中封装和重用该代码——那么当在一个应用程序中导入和使用时，在该框架中定义的所有内容都将作为独立模块的一部分 ，或是当它在另一个框架中使用时。 源文件是一个模块中的单个 Swift 源代码文件（实际上，是一个应用程序或是框架中的单个文件）。虽然通常在单独源文件中定义单个类型，但是一个源文件可以包含多个类型。函数等的定义。 访问级别Swift 为代码的实体提供个五个不同的访问级别。这些访问级别和定义实体的源文件相关，并且也和源文件所属的模块相关。 Open访问和public访问 允许实体被定义被模块中的任意源文件访问，同样可以被另一模块的源文件通过导入该定义模块来访问。在指定框架的公共接口时，通常使用open或public访问。open和public访问 之间的区别将在之后给出。 Internal访问 允许实体被定义模块中的任意源文件访问，但不能被该模块之外的任意源文件访问。通常在定义程序或是框架的内部结构时使用。 private访问 将实体的使用限制于封闭声明中。当一些细节仅在单独的声明中使用时，使用private访问隐藏特定功能的实现细节。 open访问时最高的（限制最少）访问级别，private是最低的（限制最多的）访问级别。 open访问仅适用于类和类成员，他与public访问区别如下： public访问，或任何更严格的访问级别的类，只能在其定义模块中被继承。 public访问，或任何更严格的访问级别的类成员，只能被其定义模块的子类重写。 open类可以在其定义的模块中被继承，也可在任何导入定义模块的其他模块中被继承。 open类成员可以在其定义的模块的子类重写，也可以被导入其定义模块的任何模块重写。 显式地标记类为 open 意味着你考虑过其他模块使用该类作为父类对代码的影响，并且相应地设计了类的代码。 访问级别的指导准则Swift 中的访问级别遵循一个总体指导准则：实体不可以被更低（限制更多）访问级别的实体定义。 例如： 一个 public 的变量其类型的访问级别不能是 internal, file-private 或是 private，因为在使用 public 变量的地方可能没有这些类型的访问权限。 一个函数不能比它的参数类型和返回类型访问级别高，因为函数可以使用的环境而其参数和返回类型却不能使用。 默认访问级别如果你不指明访问级别的话，你的代码中的所有实体（以及本章后续提及的少数例外）都会默认为 internal 级别。因此，大多数情况下你不需要明确指定访问级别。 单目标应用的访问级别当你编写一个简单的单目标应用时，你的应用中的代码都是在本应用中使用的并且不会在应用模块之外使用。默认的 internal 访问级别已经匹配了这种需求。因此，你不需要明确自定访问级别。但你可能会将代码的一些部分标注为 file private 或private 以对模块中的其他代码隐藏它们的实现细节。 框架的访问级别当你开发一个框架时，将该框架的面向公众的接口标注为 open 或 public，这样它就能被其他的模块看到或访问，比如导入该框架的应用。这个面相公众的接口就是该框架的应用编程接口（API）。 注意 你框架的任何内部实现细节仍可以使用 internal 默认访问级别，如果你想从框架的其他部分隐藏细节也可以将它们标注为 private 或 file private 。仅当你想将它设为框架的API时你才能将实体标注为 open 或 public 。 单元测试目标的访问级别当你在写一个有单元测试目标的应用时，你的代码应该能被模块访问到以进行测试。默认情况下只有标注为 open 或 public 的才可以被其他模块访问。但是，如果你使用 @testable 属性标注了导入的生产模块并且用使能测试的方式编译了这个模块，单元测试目标就能访问任何 internal 的实体。 访问控制语法通过在实体的引入之前添加 open ， public ， internal ， fileprivate ，或 private 修饰符来定义访问级别。 123456789public class SomePublicClass &#123;&#125;internal class SomeInternalClass &#123;&#125;fileprivate class SomeFilePrivateClass &#123;&#125;private class SomePrivateClass &#123;&#125; public var somePublicVariable = 0internal let someInternalConstant = 0fileprivate func someFilePrivateFunction() &#123;&#125;private func somePrivateFunction() &#123;&#125; 除非已经标注，否则都会使用默认的 internal 访问级别，这一点在[默认访问级别]一节已经说明。这意味着 SomeInternalClass 和 someInternalConstant 不需要指明访问级别也会是 internal 级别。 123class SomeInternalClass &#123;&#125; // implicitly internal let someInternalConstant = 0 // implicitly internal 自定类型如果你想给自定类型指明访问级别，那就在定义时指明。只要访问级别允许，新类型就可以被使用。例如，你定义了一个 file-private 的类，它就只能在定义文件中被当作属性类型、函数参数或返回类型使用。 类型的访问控制级别也会影响它的成员的默认访问级别（它的属性，方法，初始化方法，下标）。如果你将类型定义为 private 或 file private 级别，那么它的成员的默认访问级别也会是 private 或file private。如果你将类型定义为 internal 或 public级别（或直接使用默认级别而不显式指出），那么它的成员的默认访问级别会是 internal 。 重要public 的类型默认拥有 internal 级别的成员，而不是 public。如果你想让其中的一个类型成员是 public 的，你必须按实示例代码指明。这个要求确保类型的面向公众的 API 是你选择的，并且可以避免将类型的内部工作细节公开成 API 的失误。 123456789101112131415161718192021public class SomePublicClass &#123; // explicitly public class public var somePublicProperty = 0 // explicitly public class member var someInternalProperty = 0 // implicitly internal class member fileprivate func someFilePrivateMethod() &#123;&#125; // explicitly file-private class member private func somePrivateMethod() &#123;&#125; // explicitly private class member&#125; class SomeInternalClass &#123; // implicitly internal class var someInternalProperty = 0 // implicitly internal class member fileprivate func someFilePrivateMethod() &#123;&#125; // explicitly file-private class member private func somePrivateMethod() &#123;&#125; // explicitly private class member&#125; fileprivate class SomeFilePrivateClass &#123; // explicitly file-private class func someFilePrivateMethod() &#123;&#125; // implicitly file-private class member private func somePrivateMethod() &#123;&#125; // explicitly private class member&#125; private class SomePrivateClass &#123; // explicitly private class func somePrivateMethod() &#123;&#125; // implicitly private class member&#125; 元组类型元组类型的访问级别是所有类型里最严格的。例如，如果你将两个不同类型的元素组成一个元组，一个元素的访问级别是 internal，另一个是 private，那么这个元组类型是 private 级别的。 注意元组类型不像类、结构体、枚举和函数那样有一个单独的定义。元组类型的访问级别会在使用的时候被自动推断出来，不需要显式指明。 函数类型函数类型的访问级别由函数成员类型和返回类型中的最严格访问级别决定。如果函数的计算访问级别与上下文环境默认级别不匹配，你必须在函数定义时显式指出。 下面的例子定义了一个称为someFunction() 的全局函数，而没有指明它的访问级别。你或许以为它会是默认的 “internal” 级别，但事实不是这样。这样的 someFuniction()是无法通过编译的： 123func someFunction() -&gt; (SomeInternalClass, SomePrivateClass) &#123; // function implementation goes here&#125; 这个函数的返回类型是一个由两个在自定义类型里定义的类组成的元组。其中一个类是 “internal” 级别的，另一个是 “private”。因此，这个元组的访问级别是“private”（元组成员的最严级别）。 由于返回类型是 private 级别的，你必须使用 private 修饰符使其合法: 123private func someFunction() -&gt; (SomeInternalClass, SomePrivateClass) &#123; // function implementation goes here&#125; 使用 public 或 internal 标注someFunction() 的定义是无效的，使用默认的 internal 也是无效的，7的函数可能无法访问到 private 的函数返回值。 枚举类型枚举中的独立成员自动使用该枚举类型的访问级别。你不能给独立的成员指明一个不同的访问级别。 在下面的例子中 CompassPoint 有一个指明的“public”级别。里面的成员 north , south , east , 和 west因此是“public”： 123456public enum CompassPoint &#123; case north case south case east case west&#125; 原始值和关联值枚举定义中的原始值和关联值使用的类型必须有一个不低于枚举的访问级别。例如，你不能使用一个 private 类型作为一个 internal 级别的枚举类型中的原始值类型。 嵌套类型private 级别的类型中定义的嵌套类型自动为 private 级别。fileprivate 级别的类型中定义的嵌套类型自动为 fileprivate 级别。public 或 internal 级别的类型中定义的嵌套类型自动为 internal 级别。如果你想让嵌套类型是 public 级别的，你必须将其显式指明为 public。 子类你可以继承任何类只要是在当前可以访问的上下文环境中。但子类不能高于父类的访问级别，例如，你不能写一个 internal 父类的 public 子类。 而且，你可以重写任何类成员（方法，属性，初始化器或下标），只要是在确定的访问域中是可见的。 重写可以让一个继承类成员比它的父类中的更容易访问。在下例中，public 级别的类 A 有一个 fileprivate 级别的 someMethod() 函数。 B 是 A 的子类，有一个降低的“internal”级别。但是，类 B 对 someMethod() 函数进行了重写即改为“internal”级别，这比 someMethod() 的原本实现级别更高： 123456public class A &#123; fileprivate func someMethod() &#123;&#125;&#125;internal class B: A &#123; override internal func someMethod() &#123;&#125;&#125; 子类成员调用父类中比子类更低访问级别的成员，只要这个调用发生在一个允许的访问级别上下文中（即对 fileprivate 成员的调用要求父类在同一个源文件中，对 internal 成员的调用要求父类在同一个模块中）： 12345678public class A &#123; fileprivate func someMethod() &#123;&#125;&#125;internal class B: A &#123; override internal func someMethod() &#123; super.someMethod() &#125;&#125; 因为父类 A 和子类 B 定义在同一个源文件中，那么 B 类可以在 someMethod() 中调用父类的 someMethod()。 常量，变量，属性和下标常量、变量、属性不能拥有比它们类型更高的访问级别。例如，你不能写一个public 的属性而它的类型是 private 的。类似的，下标也不能拥有比它的索引类型和返回类型更高的访问级别。 如果常量、变量、属性或下标由private类型组成，那么常量、变量、属性或下标也要被标注为 private ： 1private var privateInstance = SomePrivateClass() Getters 和 Setters常量、变量、属性和下标的 getter 和 setter 自动接收它们所属常量、变量、属性和下标的访问级别。 你可以给 setter 函数一个比相对应 getter 函数更低的访问级别以限制变量、属性、下标的读写权限。你可以通过在 var 和 subscript 的置入器之前书写 fileprivate(set) , private(set), 或 internal(set) 来声明更低的访问级别。 注意这个规则应用于存储属性和计算属性。即使你没有给一个存储属性书写一个明确的 getter 和 setter，Swift 会为你合成一个 getter 和 setter 以访问到存储属性的隐式存储。使用 fileprivate(set) , private(set) 和 internal(set) 可以改变这个合成的 setter 的访问级别，同样也可以改变计算属性的访问级别。 下面的例子定义了一个称为 TrackedString 的结构体，它保持追踪一个字符串属性的修改次数： 12345678struct TrackedString &#123; private(set) var numberOfEdits = 0 var value: String = &quot;&quot; &#123; didSet &#123; numberOfEdits += 1 &#125; &#125;&#125; TrackedString 结构体定义了一个可存储字符串的属性 value ，它又一个初始值 “” （空字符串）。这个结构图同样定义了一个可存储整数的属性 numberOfEdits ，它被用于记录 value 的修改次数。这个记录由 value 属性中的didset属性实现，它会增加 numberOfEdits 的值一旦 value 被设为一个新值。 TrackedString 结构体和 value 属性都没有显式指出访问级别修饰符，因此它们都遵循默认的 internal 级别。 numberOfEdits 属性的访问级别已经标注为private(set) 以说明这个属性的 getter 是默认的 internal 级别，但是这个属性只能被 TrackedString 内的代码设置。这允许 TrackedString 在内部修改 numberOfEdits 属性，而且可以展示这个属性作为一个只读属性当在结构体定义之外使用时——包括 TrackedString 的扩展。 如果你创建了一个 TrackedString 的实例并修改了几次字符串的值，你可以看到 numberOfEdits 属性的值更新到匹配修改的次数： 123456var stringToEdit = TrackedString()stringToEdit.value = &quot;This string will be tracked.&quot;stringToEdit.value += &quot; This edit will increment numberOfEdits.&quot;stringToEdit.value += &quot; So will this one.&quot;print(&quot;The number of edits is \(stringToEdit.numberOfEdits)&quot;)// Prints &quot;The number of edits is 3&quot; 尽管你可以从别的源文件中询问到 numberOfEdits 属性的当前值，但你不能从别的源文件中修改该属性的值。这个限制保护了 TrackedString 编辑追踪功能的实现细节，并同时为该功能的一个方面提供方便的访问。 你若有必要也可以显式指明 getter 和 setter方法。下面的例子提供了一个定义为 public 级别的 TrackedString 结构体。结构体成员（包括 numberOfEdits 属性）因此有一个默认的 internal 级别。你可以设置 numberOfEdits 属性的getter方法为 public，setter 方法为 private 级别，通过结合 public 和 private(set) 访问级别修饰符： 123456789public struct TrackedString &#123; public private(set) var numberOfEdits = 0 public var value: String = &quot;&quot; &#123; didSet &#123; numberOfEdits += 1 &#125; &#125; public init() &#123;&#125;&#125; 初始化器我们可以给自定义初始化方法设置一个低于或等于它的所属的类的访问级别。唯一的例外是必要初始化器（定义在必要初始化器）。必要初始化器必须和它所属类的访问级别一致。 就像函数和方法的参数一样，初始化器的参数类型不能比初始化方法的访问级别还低。 默认初始化器正如默认初始化器中描述的那样，Swift 自动为任何结构体和类提供一个无参数的默认初始化方法，以给它的属性提供默认值但不会提供给初始化器自身。 默认初始化方法与所属类的访问级别一致，除非该类型定义为 public 。如果一个类定义为 public ，那么默认初始化方法为 internal 级别。如果你想一个 public 类可以被一个无参初始化器初始化当在另一个模块中使用时，你必须显式提供一个 public 的无参初始化方法。 结构体的默认成员初始化器如果结构体的存储属性时 private 的，那么它的默认成员初始化方法就是 private 级别。如果结构体的存储属性时 file private 的，那么它的默认成员初始化方法就是 file private 级别。否则就是默认的 internal 级别。正如以上默认初始化的描述，如果你想在另一个模块中使用结构体的成员初始化方法，你必须提供在定义中提供一个 public 的成员初始化方法。 协议如果你想给一个协议类型分配一个显式的访问级别，那就在定义时指明。这让你创建的协议可以在一个明确的访问上下文中被接受。 协议定义中的每一个要求的访问级别都自动设为与该协议相同。你不能将一个协议要求的访问级别设为与协议不同。这保证协议的所有要求都能被接受该协议的类型所见。 注意如果你定义了一个 public 的协议，该协议的规定要求在被实现时拥有一个 public 的访问级别。这个行为不同于其他类型，一个 public 的类型的成员时 internal 访问级别。 协议继承如果你定义了一个继承已有协议的协议，这个新协议最高与它继承的协议访问级别一致。例如你不能写一个 public 的协议继承一个 internal 的协议。 协议遵循类型可以遵循更低访问级别的协议。例如，你可以定义一个可在其他模块使用的 public 类型，但它就只能在定义模块中使用如果遵循一个 internal 的协议。 遵循了协议的类的访问级别取这个协议和该类的访问级别的最小者。如果这个类型是 public 级别的，它所遵循的协议是 internal 级别，这个类型就是 internal 级别的。 当你写或是扩张一个类型以遵循协议时，你必须确保该类按协议要求的实现方法与该协议的访问级别一致。例如，一个 public 的类遵循一个 internal 协议，该类的方法实现至少是 “internal” 的。 注意在 Swift 和 Objective-C 中协议遵循是全局的——一个类不可能在一个程序中用不同方法遵循一个协议。 扩展你可以在任何可访问的上下文环境中对类、结构体、或枚举进行扩展。在扩展中添加的任何类型成员都有着被扩展类型相同的访问权限。如果你扩展一个公开或者内部类型，你添加的任何新类型成员都拥有默认的内部访问权限。如果你扩展一个文件内私有的类型，你添加的任何新类型成员都拥有默认的私有访问权限。如果你扩展一个私有类型，你添加的任何新类型成员都拥有默认的私有访问权限。 或者，你可以显式标注扩展的访问级别（例如， private extension ）已给扩展中的成员设置新的默认访问级别。这个默认同样可以在扩展中为单个类型成员重写。 你不能给用于协议遵循的扩展显式标注访问权限修饰符。相反，在扩展中使用协议自身的访问权限作为协议实现的默认访问权限。 扩展中的私有成员在同一文件中的扩展比如类、结构体或者枚举，可以写成类似多个部分的类型声明。你可以： 在原本的声明中声明一个私有成员，然后在同一文件的扩展中访问它； 在扩展中声明一个私有成员，然后在同一文件的其他扩展中访问它； 在扩展中声明一个私有成员，然后在同一文件的原本声明中访问它。 这样的行为意味着你可以和组织代码一样使用扩展，无论你的类型是否拥有私有成员。比如说，假设下面这样的简单协议： 123protocol SomeProtocol &#123; func doSomething()&#125; 你可以使用扩展来添加协议遵循，比如这样： 123456789struct SomeStruct &#123; private var privateVariable = 12&#125; extension SomeStruct: SomeProtocol &#123; func doSomething() &#123; print(privateVariable) &#125;&#125; 泛型泛指类型和泛指函数的访问级别取泛指类型或函数以及泛型类型参数的访问级别的最小值。 类型别名任何你定义的类型同义名都被视为不同的类型以进行访问控制。一个类型同义名的访问级别不高于原类型。例如，一个 private 的类型同义名可联系到 private ，file-private ，internal ，public 或open 的类型，但 public 的类型同义名不可联系到 internal ，file-private 或 private 类型。 注意这条规则适用于为满足协议遵循而给类型别名关联值的情况。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[23个经典设计模式的Swift实现]]></title>
    <url>%2F2018%2F04%2F16%2FDesign%20Mode%2F23%E4%B8%AA%E7%BB%8F%E5%85%B8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84Swift%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[前言 这是一篇主观的文章，文字解释也尽可能简单，写作目的是一次团队内的知识分享，想让不了解设计模式的同事迅速对这些生词混个脸熟。所以本文适合懂Swift语法，想快速了解23个设计模式大概在讲什么的同学。 基本结构 比喻 让我联想到的一些事物 官方定义 原版定义 UML 不是原版UML 只保留了我觉得核心的部分 代码 Swift实现，这个是本体 讲解 假设已经看过代码的一些零散评注 目录 Creational 创建型 5 Abstract Factory 抽象工厂模式 Builder 建造者模式 Factory Method 工厂方法模式 Prototype 原型模式 Singleton 单例模式 Structural 结构型 7 Adapter 适配器模式 Bridge 桥接模式 Composite 组合模式 Decorator 装饰者模式 Facade 外观模式 Flyweight 享元模式 Proxy 代理模式 Behavioral 行为型 11 Chain of responsibility 责任链模式 Command 命令模式 Interpreter 解释器模式 Iterator 迭代器模式 Mediator 中介模式 Memento 备忘录模式 Observer 观察者模式 State 状态模式 Strategy 策略模式 Template Method 模板方法模式 Visitor 访问者模式 工厂模式 工厂模式顾名思义，就像一个工厂生产你所需要的产品 配图：http://cdn1.alphr.com/sites/alphr/files/2016/02/tesla_factory_tour_1.jpg 无工厂 Non-Factory也就是工厂问题想解决的原始问题。 12345678910111213141516protocol Product&#123;&#125;class ConcreteProductA: Produce &#123;&#125;class ConcreteProductB: Produce &#123;&#125;class Client &#123; func createProduct(type: Int) -&gt; Produce &#123; if type == 0 &#123; return ConcreteProductA() &#125; else &#123; return ConcreteProductB() &#125; &#125;&#125;let c = Client()c.createProduct(type: 0) // get ConcreteProductA 从代码和UML可以看出，为了得到产品A，调用者Client要同时依赖Product, ConcreteProductA和ConcreteProductB，并亲自写一个创建产品的方法。 每当需求新增一个产品，就要改动到调用方Client。如果这一堆创建代码如果可以抽离出去就好了，于是简单工厂出现了。 简单工厂 Simple Factory简单工厂就做了一件事，把Client要做的创建工作，挪到了另一个类里。 1234567891011121314151617181920protocol Product&#123;&#125;class ConcreteProductA: Produce &#123;&#125;class ConcreteProductB: Produce &#123;&#125;class Client &#123; let s = Factory()&#125;class Factory &#123; func createProduct(type: Int) -&gt; Product &#123; if type == 0 &#123; return ConcreteProductA() &#125; else &#123; return ConcreteProductA() &#125; &#125;&#125;let c = Client()c.s.createProduct(type: 0) // get ConcreteProductA Factory代替了Client对具体Product的依赖，那么当需求变化的时候，我们不再需要改动调用方。这固然有所进步，但无法避免的是，每次变动都要在createProduct的方法内部新增一个if-else分支，这显然违背了开闭原则。 为了解决这个问题，我们引入另一个模式。 工厂方法 Factory Method官方定义 定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。 123456789101112131415161718192021222324252627282930313233343536protocol Product&#123;&#125;class ConcreteProductA: Produce &#123;&#125;class ConcreteProductB: Produce &#123;&#125;class Client &#123; let f = Factory()&#125;class Factory &#123; func createProduct() -&gt; Product? &#123; return nil &#125; //用于继承 func createProduct(type: Int) -&gt; Product? &#123; //用于调用 if type == 0 &#123; return ConcreteFactoryA().createProduct() &#125; else &#123; return ConcreteFactoryB().createProduct() &#125; &#125;&#125;class ConcreteFactoryA: Factory &#123; override func createProduct() -&gt; Product? &#123; // ... 产品加工过程 return ConcreteProductA() &#125;&#125;class ConcreteFactoryB: Factory &#123; override func createProduct() -&gt; Product? &#123; // ... 产品加工过程 return ConcreteProductB() &#125;&#125;let c = Client()c.f.createProduct(type: 0) // get ConcreteProductA 对于工厂方法的实现，有众多不同的解法，比如Factory只保留一个createProduct让子类实现，让Client来选择生成哪个具体工厂实例；或是引入一个FactoryMaker的中间层，作为生产工厂的“简单工厂”。我这里采用的方式是Factory既作为工厂父类，让具体工厂决定生产生么产品，又作为接口类，让Client可以通过依赖注入选择特定工厂。我这样做的目的是，在不引入新的中间层的情况下，最小化Client的依赖。 工厂方法在简单工厂的基础上做了两件事： 多了一层抽象，把生产产品的工作延迟到子类执行。 把“选择如何生产产品的工作”转化为“选择让哪个具体工厂生产”。 工厂方法的贡献在于，这样做虽然不能完美避免对一个if-else的扩展，但是这个扩展规模被极大限制住了（只需要new一个类）。 工厂方法着重点是解决了单一产品线的派生问题。那如果有多个相关产品线呢？ 抽象工厂 Abstract Factory官方定义 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758protocol ProductA &#123;&#125;class ConcreteProductA1: ProductA &#123;&#125;class ConcreteProductA2: ProductA &#123;&#125;protocol ProductB &#123;&#125;class ConcreteProductB1: ProductB &#123;&#125;class ConcreteProductB2: ProductB &#123;&#125;class Client &#123; let f = Factory()&#125;class Factory &#123; func createProductA() -&gt; ProductA? &#123; return nil &#125; // 用于继承 func createProductB() -&gt; ProductB? &#123; return nil &#125; // 用于继承 func createProductA(type: Int) -&gt; ProductA? &#123; // 用于调用 if type == 0 &#123; return ConcreteFactory1().createProductA() &#125; else &#123; return ConcreteFactory2().createProductA() &#125; &#125; func createProductB(type: Int) -&gt; ProductB? &#123; // 用于调用 if type == 0 &#123; return ConcreteFactory1().createProductB() &#125; else &#123; return ConcreteFactory2().createProductB() &#125; &#125;&#125;class ConcreteFactory1: Factory &#123; override func createProductA() -&gt; ProductA? &#123; // ... 产品加工过程 return ConcreteProductA1() &#125; override func createProductB() -&gt; ProductB? &#123; // ... 产品加工过程 return ConcreteProductB1() &#125;&#125;class ConcreteFactory2: Factory &#123; override func createProductA() -&gt; ProductA? &#123; // ... 产品加工过程 return ConcreteProductA2() &#125; override func createProductB() -&gt; ProductB? &#123; // ... 产品加工过程 return ConcreteProductB2() &#125;&#125;let c = Client()c.f.createProductA(type: 0) // get ConcreteProductA1c.f.createProductA(type: 1) // get ConcreteProductA2c.f.createProductB(type: 0) // get ConcreteProductB1c.f.createProductB(type: 1) // get ConcreteProductB2 图很吓人，其实很简单。 当我们有两个相关的产品线ProductA和ProductB, 例如螺丝和螺母，他们派生出ProductA1，ProductB1 和 ProductA2，ProductB2，前者我们由工厂ConcreteFactory1来制作，后者由 ConcreteFactory2来制作。 对于Client来说，他只需要知道有一个抽象的工厂能同时生产ProductA和ProductB就行了，那就是图中的Factory。 重点来了，这个抽象的Factory是通过“工厂方法”模式把构造过程延迟到子类执行的，也就是说，抽象工厂是建立在工厂方法的基础上的模式。所以抽象工厂，换句话说，就是多个产品线需要绑定在一起，形成一个抽象的综合工厂，由具体的综合工厂来批量实现“工厂方法”的一种更“高级”的模式。 总结有点绕，说完这些感觉我已经中文十级了。总之，我想表达的观点是：这些工厂模式并不是割裂的存在，而是一个递进的思想。 Builder 建造者模式 建造者模式就像你委托一个室内设计师装修你的新家 配图: http://tse2.mm.bing.net/th?id=OIP.N3hIhcOq32Bh6Ezi6q6kGwHaFj&amp;pid=Api 官方定义 将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。 如果说之前的谈到的工厂模式是把创建产品(对象)的工作抽离出去的话，这次要聊的建造者模式，就是把产品内部的组件生产工作抽离出去。这样做的场景，适用于那些有着复杂、规则模块的对象生成流程。换句话说，工厂模式是一个类(工厂)创建另一个类(产品)，而建造者是一个类(产品)自身的属性(组件)构造过程。 对于建造者模式的实现网上也是版本不一：复杂点的版本会引入一个Director的角色，做一个整体上下文，组装更傻瓜化的builder和product。或是抽象一层Builder协议，用不同的具体Builder来构造不同的产品。但我认为这些都模糊了这个模式要传达的焦点，对理解没有帮助，所以这里我选择一个极简的模型。 123456789101112131415161718struct Builder &#123; var partA: String var partB: String&#125;struct Product &#123; var partA: String var partB: String init(builder: Builder) &#123; partA = builder.partA partB = builder.partB &#125;&#125;// 通过builder完成产品创建工作let b = Builder(partA: &quot;A&quot;, partB: &quot;B&quot;)// 这样产品只需要一个builder就可以完成制作let p = Product(builder: b) 我们让Product的生成由自己发起，但是它的组件(属性)全都委托给Builder来实现，而它只需要依赖一个Builder就完成了自身的生产工作。 Prototype 原型模式 原型模式让你有了一个可以源源不断自我赋值的类。 配图: http://thumbs.dreamstime.com/z/cell-division-two-cells-divide-osmosis-background-other-cells-48181492.jpg 官方定义 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 原型模式很简单，你只要实现一个返回你自己的新对象的方法即可。这里我采用的实现还不是最简单的，这个interface并不是必须的。 原型模式实现了深拷贝。 1234567891011121314protocol Prototype &#123; func clone() -&gt; Prototype&#125;struct Product: Prototype &#123; var title: String func clone() -&gt; Prototype &#123; return Product(title: title) &#125;&#125;let p1 = Product(title: &quot;p1&quot;)let p2 = p1.clone()(p2 as? Product)?.title // OUTPUT: p1 Singleton 单例模式 单例就像一个公司的IT部门，他们是唯一的存在，并且被所有人直接访问。 配图：The IT Crowd 官方定义 保证一个类仅有一个实例，并提供一个访问它的全局访问点。 因为第二点常常被忽视，所以过度使用的危害极大，你无从知道调用从何而来，这种goto一般的存在会变成维护的噩梦。 单例比较常见的应用是例如数据库，网络框架的全局访问点。 单例其实就是变种的原型模式，只不过原型每次返回的是一个拷贝。 Swift的简单实现： 12345678class Singleton &#123; static let sharedInstance = Singleton() private init() &#123; // 用private防止被new &#125;&#125;let s = Singleton.sharedInstancelet s2 = Singleton() // ERROR: initializer is inaccessible due to &apos;private&apos; protection level Swift的完整实现： 12345678910111213class Singleton &#123; static var singleton: Singleton? = nil private init() &#123;&#125; static func sharedInstance() -&gt; Singleton &#123; if singleton == nil &#123; singleton = Singleton() &#125; return singleton! &#125;&#125;let s = Singleton.sharedInstance()let s2 = Singleton() // ERROR: initializer is inaccessible due to &apos;private&apos; protection level Adapter 适配器模式 适配器就像一个电源转换插头。 配图: http://www.wap135.com/270/timg08/uploaded/i8/TB2452gtpXXXXaLXXXXXXXXXXXX_!!622114048.jpg 官方定义 将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 一个类能称之为适配器，就是指它能把另一个类进行某种变形，让其能和实际需求对接。 比如一个底层数据模型，可以通过不同的UI适配器，对应不同的展现需要。 12345678910111213141516171819protocol Target &#123; var value: String &#123; get &#125;&#125;struct Adapter: Target &#123; let adaptee: Adaptee var value: String &#123; return &quot;\(adaptee.value)&quot; &#125; init(_ adaptee: Adaptee) &#123; self.adaptee = adaptee &#125;&#125;struct Adaptee &#123; var value: Int&#125;Adapter(Adaptee(value: 1)).value // &quot;1&quot; Bridge 桥接模式 桥接模式就是这么一座桥，它矗立在具体和抽象之间，当你调用的时候只看到了抽象，但是它内部实现时“桥接”到了具体。 配图: https://user-gold-cdn.xitu.io/2018/3/15/16228c4c4b5fc92c?imageView2/0/w/1280/h/960/ignore-error/1 官方定义 将抽象部分与实现部分分离，使它们都可以独立的变化。 桥接模式是继工厂模式之后另一个有点绕的概念，为了不一言不合就抛概念把大家绕晕，我们直接来看一下这个模式最终成型的样子。 首先假设我们封装了一个“开关能力”的接口。 123protocol 开关能力 &#123; func turnOn(_ on: Bool)&#125; 这个接口只有一个方法，实现者需要提供打开/关闭开关会触发什么操作。 然后我们抽象一个叫“设备”的类出来，这个类就有意思了： 首先他有一个实现了开关能力的实例变量，并通过初始化赋好值。 他有一个方法的实现就是直接提供了开关能力里的实现。 123456789class 设备 &#123; let obj: 开关能力 func turnOn(_ on: Bool) &#123; obj.turnOn(on) &#125; init(_ obj: 开关能力) &#123; self.obj = obj &#125;&#125; 这样，其实一个桥接模式就已经搭建完了。再讲解之前，我们直接看一下如何应用它： 12345678910111213141516171819202122232425class 电视: 开关能力 &#123; func turnOn(_ on: Bool) &#123; if on &#123; // 打开电视 &#125; else &#123; // 关闭电视 &#125; &#125;&#125;class 空调: 开关能力 &#123; func turnOn(_ on: Bool) &#123; if on &#123; // 打开空调 &#125; else &#123; // 关闭空调 &#125; &#125;&#125;let tv = 设备(电视())tv.turnOn(true) // 打开电视let aircon = 设备(空调())aircon.turnOn(false) // 关闭空调 通过这段代码可以看出： 在把抽象的设备应用到具体的业务的时候，这个模式采用的是组合了一个实现了开关能力接口的实例，而没用继承。最终调用的时候，是由统一的设备作为接入点的，而不是电视，空调这些具体类，具体的实现是通过组合的方式注入到设备里的。 了解了这个流程后，一个事情就明朗了： 这不就是在用组合代替继承吗？ 没错，它把需要变化的代码通过接口代理出去，而避免了继承。 但是，桥接模式的桥在哪里？ 这时，要搬出他的概念了： Bridge pattern - Wikipedia： The bridge pattern is a design pattern used in software engineering which is meant to “decouple an abstraction from its implementation so that the two can vary independently”.桥接模式解耦了抽象和具体，让它们可以独立变化。 从代码去寻找具体和抽象，就可以发现： 这座桥能走通的关键就是这个组合在抽象类里的变量。 最后，你会发现，这不就是Adapter和Adaptee吗？ 没错，设计模式其实是连续剧来着。 不同在于适配器的关注点是如何让两个不兼容的类对接， 而桥接模式关注点是解耦。 Composite 组合模式 组合模式就像一个公司的组织架构，存在基层员工(Leaf)和管理者(Composite)，他们都实现了组件(Component)的work方法，这种树状结构的每一级都是一个功能完备的个体。 配图：https://realtimeboard.com/static/images/page/examples/detail/organizational-chart.png 官方定义 将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。 这个组合模式不是“组合优于继承”的那种“组合”，这里是狭义的指代一种特定场景，就是如配图描述的一种树状结构。 理解这个模式要知道三个设定： Component：一个有功能性的组件。 Leaf：它实现了组件。 Composite：它既实现了组件，他又包含多个组件。 1234567891011121314151617181920212223protocol Component &#123; func someMethod()&#125;class Leaf: Component &#123; func someMethod() &#123; // Leaf &#125;&#125;class Composite: Component &#123; var components = [Component]() func someMethod() &#123; // Composite &#125;&#125;let leaf = Leaf()let composite = Composite()composite.components += [leaf]composite.someMethod()leaf.someMethod() 这个模式的精髓就是Composite这个角色，事实上Leaf可以看做一个特殊的Compostie。由于他即可以是一个功能执行者，又可以包含其它节点，这个特性可以派生出泛用度很高的树状结构。 Decorator 装饰者模式 如果点咖啡时价格的计算是牛奶(糖(咖啡(价格: 19元)))就好了 配图：http://cdn.marksdailyapple.com/wordpress/wp-content/themes/Marks-Daily-Apple-Responsive/images/blog2/coffee.jpg 官方定义 动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。 下面我们就用装饰者模式的思想来设计这个点咖啡程序: 代码12345678910111213141516171819202122232425262728293031323334protocol Component &#123; var cost: Int &#123; get &#125;&#125;protocol Decorator: Component &#123; var component: Component &#123; get &#125; init(_ component: Component)&#125;struct Coffee: Component &#123; var cost: Int&#125;struct Sugar: Decorator &#123; var cost: Int &#123; return component.cost + 1 &#125; var component: Component init(_ component: Component) &#123; self.component = component &#125;&#125;struct Milk: Decorator &#123; var cost: Int &#123; return component.cost + 2 &#125; var component: Component init(_ component: Component) &#123; self.component = component &#125;&#125;Milk(Sugar(Coffee(cost: 19))).cost 当你的需求是零散的不断给“主菜加点佐料”的时候，并且这些佐料会经常变化，那么这个模式就可以有效的解决排列组合产生的类爆炸 理解的一个关键点就是区分组件Component和装饰者Decorator两个角色，单纯组件的实现者（咖啡）是被装饰的对象，他不再能装饰别人。 这个模式没有一个集中的计算器，每一个装饰者都参与了部分计算并输出当下的结果。 Facade 外观模式 外观模式就是化繁为简。 配图：http://www.3dmgame.com/news/201709/3684484.html 官方定义 为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 值得一提的是，这个单词读音很怪。 在谈起外观模式的时候，常常是指对一个复杂的(旧)代码库在不改变其内在的情况下，包装一层易于调用的表层API。 外观模式不会采用继承，而是用接口和组合。 12345678910111213141516171819202122protocol Facade &#123; func simpleMethod()&#125;class LegacyCode &#123; func someMethod1() &#123; &#125; func someMethod2() &#123; &#125;&#125;extension LegacyCode: Facade &#123; func simpleMethod() &#123; someMethod1() someMethod2() &#125;&#125;class Client &#123; let f: Facade = LegacyCode()&#125;let c = Client()c.f.simpleMethod() Flyweight 享元模式 享元模式就像CPU的Cache Memory，它通过对缓存的命中来实现速度的提升和内存的降低。 配图：http://www.computerhope.com/issues/pictures/cpu_cache_die.jpg 官方定义 运用共享技术有效地支持大量细粒度的对象。 享元模式其实就是指一套缓存系统。 显然他是一种复合模式，使用工厂模式来创造实例。 适用场景是系统中存在重复的对象创建过程。 好处是节省了内存加快了速度。 123456789101112131415161718192021struct TargetObject &#123; var title: String? func printTitle() &#123; print(title) &#125;&#125;class Cache &#123; var targetObjects = [String: TargetObject]() func lookup(key: String) -&gt; TargetObject &#123; if targetObjects.index(forKey: key) == nil &#123; return TargetObject() &#125; return targetObjects[key]! &#125;&#125;let c = Cache()c.targetObjects[&quot;Test&quot;] = TargetObject(title: &quot;Test&quot;)c.lookup(key: &quot;123&quot;).printTitle() // nilc.lookup(key: &quot;Test&quot;).printTitle() // Test Proxy 代理模式 代理模式让一个类成为了另一个类的实际接口。 官方定义 为其他对象提供一种代理以控制对这个对象的访问。 有两种常见的代理场景： Protection proxy： 出于安全考虑，通过一个表层的类间接调用底层的类。 Virtual proxy：出于性能考虑，通过一个低耗的类延迟调用一个高耗的类。 但他们的实现是类似的： 12345678910111213141516171819protocol Subject &#123; mutating func operation()&#125;struct SecretObject: Subject &#123; func operation() &#123; // real implementation &#125;&#125;struct PublicObject: Subject &#123; private lazy var s = SecretObject() mutating func operation() &#123; s.operation() &#125;&#125;var p = PublicObject()p.operation() SecretObject既可以看做一个隐藏类，又可以看做一个高费的类。通过PublicObject对他的代理，可以实现信息隐藏和延迟加载两个特性。 Chain of responsibility 责任链模式 责任链模式就像去取钱，每一面值都参与了计算和职责传递。 配图：http://www.joezimjs.com/wp-content/uploads/chain_of_responsibility_atm.png 官方定义 1避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。 UIKit的touch事件就应用了责任链模式 这个模式的实现就是既实现一个接口，又组合这个接口，这样自己执行完毕后就可以调用下一个执行者。 12345678910111213141516171819202122232425262728protocol ChainTouchable &#123; var next: ChainTouchable? &#123; get &#125; func touch()&#125;class ViewA: ChainTouchable &#123; var next: ChainTouchable? = ViewB() func touch() &#123; next?.touch() &#125;&#125;class ViewB: ChainTouchable &#123; var next: ChainTouchable? = ViewC() func touch() &#123; next?.touch() &#125;&#125;class ViewC: ChainTouchable &#123; var next: ChainTouchable? = nil func touch() &#123; print(&quot;C&quot;) &#125;&#125;let a = ViewA()a.touch() // OUTPUT: C Command 命令模式 命令模式就是一种指令系统。 配图：http://cdn.wikimg.net/strategywiki/images/thumb/e/e3/Light-bot_2-3.jpg/914px-Light-bot_2-3.jpg 官方定义 将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。 命令模式有两个特征： 命令逻辑对象化，这个命令对象可以从外界通过参数传入，也可内部实现。 支持undo，因为每个命令对象自己知道如何撤销（反命令），所以可以封装到命令对象内部。 123456789101112131415161718192021222324252627282930313233343536protocol Command &#123; var operation: () -&gt; Void &#123; get &#125; var backup: String &#123; get &#125; func undo()&#125;struct ConcreteCommand: Command &#123; var backup: String var operation: () -&gt; Void func undo() &#123; print(backup) &#125;&#125;struct Invoker &#123; var command: Command func execute() &#123; command.operation() &#125; func undo() &#123; command.undo() &#125;&#125;let printA = ConcreteCommand(backup: &quot;Default A&quot;) &#123; print(&quot;A&quot;)&#125;let i1 = Invoker(command: printA)i1.execute() // OUTPUT: Alet printB = ConcreteCommand(backup: &quot;Default B&quot;) &#123; print(&quot;B&quot;)&#125;let i2 = Invoker(command: printB)i2.execute() // OUTPUT: Bi2.undo() // OUTPUT: Default B Interpreter 解释器模式 有了解释器，Skyrim的龙语也不在话下。 配图：https://staticdelivery.nexusmods.com/mods/110/images/thumbnails/32821-3-1362476170.jpg 官方定义 给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。 我们可以实现一个能计算文本“1加1”的解释器。 1234567891011121314protocol Expression &#123; func evaluate(_ context: String) -&gt; Int&#125;struct MyAdditionExpression: Expression &#123; func evaluate(_ context: String) -&gt; Int &#123; return context.components(separatedBy: &quot;加&quot;) .flatMap &#123; Int($0) &#125; .reduce(0, +) &#125;&#125;let c = MyAdditionExpression()c.evaluate(&quot;1加1&quot;) // OUTPUT: 2 Iterator 迭代器模式 迭代器就像回转寿司，保证每一道菜品都能得到展示。 配图：http://www.sohu.com/a/207894434_99978064 官方定义 提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。 迭代器就是能用hasNext和Next来遍历的一种集合元素。 他很像责任链，但是责任链是一个随时可断的链条（有可能在某一个节点不再把责任下放），他不强调一次完整的遍历。迭代器更像一次次的循环，每次循环都强调完整性，所以更适合集合的场景。 还有一个区别是迭代器是提供元素，而责任链在每一个经手人那做业务。 123456789101112131415161718192021222324252627282930313233343536373839404142434445protocol AbstractIterator &#123; func hasNext() -&gt; Bool func next() -&gt; Int?&#125;class ConcreteIterator: AbstractIterator &#123; private var currentIndex = 0 var elements = [Int]() func next() -&gt; Int? &#123; guard currentIndex &lt; elements.count else &#123; currentIndex = 0; return nil &#125; defer &#123; currentIndex += 1 &#125; return elements[currentIndex] &#125; func hasNext() -&gt; Bool &#123; guard currentIndex &lt; elements.count else &#123; currentIndex = 0; return false &#125; return elements[currentIndex] != nil &#125;&#125;protocol AbstractCollection &#123; func makeIterator() -&gt; AbstractIterator&#125;class ConcreteCollection: AbstractCollection &#123; let iterator = ConcreteIterator() func add(_ e: Int) &#123; iterator.elements.append(e) &#125; func makeIterator() -&gt; AbstractIterator &#123; return iterator &#125;&#125;let c = ConcreteCollection()c.add(1)c.add(2)c.add(3)let iterator = c.makeIterator()while iterator.hasNext() &#123; print(iterator.next() as Any)&#125; Mediator 中介模式 中介模式是对象间发消息的传话筒。 配图：http://www.quanjing.com/imgbuy/top-959496.html 官方定义 用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 中介模式对于通信关系复杂的系统有很好的解耦效果 它和观察者模式很像，区别在于观察者是不关心接受方的广播，中介者是介入两个（或多个）对象之间的定点消息传递。 123456789101112131415161718192021222324252627282930313233343536373839404142434445protocol Receiver &#123; func receive(message: String)&#125;protocol Mediator: class &#123; func notify(message: String) func addReceiver(_ receiver: Receiver)&#125;class ConcreteMediator: Mediator &#123; var recipients = [Receiver]() func notify(message: String) &#123; recipients.forEach &#123; $0.receive(message: message) &#125; &#125; func addReceiver(_ receiver: Receiver) &#123; recipients.append(receiver) &#125;&#125;protocol Component: Receiver &#123; var mediator: Mediator? &#123; get &#125;&#125;struct ConcreteComponent: Component &#123; weak var mediator: Mediator? var name: String func receive(message: String) &#123; print(name, &quot; receive: &quot;, message) &#125;&#125;var mediator = ConcreteMediator()let c1 = ConcreteComponent(mediator: mediator, name: &quot;c1&quot;)let c2 = ConcreteComponent(mediator: mediator, name: &quot;c2&quot;)let c3 = ConcreteComponent(mediator: mediator, name: &quot;c3&quot;)mediator.addReceiver(c1)mediator.addReceiver(c2)mediator.addReceiver(c3)//c1 receive: hi//c2 receive: hi//c3 receive: hic1.mediator?.notify(message: &quot;hi&quot;) Memento 备忘录模式 备忘录就是游戏存档。 配图：http://gearnuke.com/wp-content/uploads/2015/05/witcher3-ps4-savedata-2.jpg 官方定义 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。 这个模式有两个角色，一个是要存储的类型本身(Memento)和执行存储操作的保管人(Caretaker)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950typealias Memento = [String: String] // chatper: levelprotocol MementoConvertible &#123; var memento: Memento &#123; get &#125; init?(memento: Memento)&#125;class GameState: MementoConvertible &#123; var memento: Memento &#123; return [chapter: level] &#125; var chapter: String var level: String required init?(memento: Memento) &#123; self.chapter = memento.keys.first ?? &quot;&quot; self.level = memento.values.first ?? &quot;&quot; &#125; init(chapter: String, level: String) &#123; self.chapter = chapter self.level = level &#125;&#125;protocol CaretakerConvertible &#123; static func save(memonto: Memento, for key: String) static func loadMemonto(for key: String) -&gt; Memento?&#125;class Caretaker: CaretakerConvertible &#123; static func save(memonto: Memento, for key: String) &#123; let defaults = UserDefaults.standard defaults.set(memonto, forKey: key) defaults.synchronize() &#125; static func loadMemonto(for key: String) -&gt; Memento? &#123; let defaults = UserDefaults.standard return defaults.object(forKey: key) as? Memento &#125;&#125;let g = GameState(chapter: &quot;Prologue&quot;, level: &quot;0&quot;)// after a whileg.chapter = &quot;Second&quot;g.level = &quot;20&quot;// want a breakCaretaker.save(memonto: g.memento, for: &quot;gamename&quot;)// load gamelet gameState = Caretaker.loadMemonto(for: &quot;gamename&quot;) // [&quot;Second&quot;: &quot;20&quot;] Observer 观察者模式 观察者模式就像预购，支付了就坐等收货，省心省力。 ![](http://images.pushsquare.com/news/2015/01/what_the_hecks_going_on_with_playstation_store_pre-orders_in_europe/attachment/0/original.jpg 配图：http://images.pushsquare.com/news/2015/01/what_the_hecks_going_on_with_playstation_store_pre-orders_in_europe/attachment/0/original.jpg 官方定义 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 观察者模式适用在一个被观察者（数据源）要通知多个观察者的场景。 这个模式主要通过添加一层接口，来把观察者的具体类型擦除，从何实现松耦合。（针对接口编程，而非实现） 观察者模式一个最重要的特点就是它是一种推模型(PUSH)，在很多情况下比拉模型更高效和即时。 123456789101112131415161718192021222324252627282930313233343536373839404142434445protocol Observable &#123; var observers: [Observer] &#123; get &#125; func add(observer: Observer) func remove(observer: Observer) func notifyObservers()&#125;class ConcreteObservable: Observable &#123; var observers = [Observer]() func add(observer: Observer) &#123; observers.append(observer) &#125; func remove(observer: Observer) &#123; if let index = observers.index(where: &#123; $0 === observer &#125;) &#123; observers.remove(at: index) &#125; &#125; func notifyObservers() &#123; observers.forEach &#123; $0.update() &#125; &#125;&#125;protocol Observer: class &#123; func update()&#125;class ConcreteObserverA: Observer &#123; func update() &#123; print(&quot;A&quot;) &#125;&#125;class ConcreteObserverB: Observer &#123; func update() &#123; print(&quot;B&quot;) &#125;&#125;//////////////////////////////////let observable = ConcreteObservable()let a = ConcreteObserverA()let b = ConcreteObserverB()observable.add(observer: a)observable.add(observer: b)observable.notifyObservers() // output: A Bobservable.remove(observer: b)observable.notifyObservers() // output: A State 状态模式 状态模式就像马里奥吃了各种蘑菇后的变身。 配图：http://www.superluigibros.com/images/super_mario_bros_3_power_ups.jpg 官方定义 允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。 状态模式很像策略模式，但是他封装的不是算法，而是一个一个本体下的不同状态。 123456789101112131415161718192021222324252627protocol State &#123; func operation()&#125;class ConcreteStateA: State &#123; func operation() &#123; print(&quot;A&quot;) &#125;&#125;class ConcreteStateB: State &#123; func operation() &#123; print(&quot;B&quot;) &#125;&#125;class Context &#123; var state: State = ConcreteStateA() func someMethod() &#123; state.operation() &#125;&#125;let c = Context()c.someMethod() // OUTPUT: Ac.state = ConcreteStateB() // switch statec.someMethod() // OUTPUT: B Strategy 策略模式 策略模式就像不同的交通路线，可以相互替换，都能达到终点。 配图：高德地图iOS 官方定义 定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。 这个模式主要还是在解决一个稳定的继承树当遇到需求变化时的狼狈。他把变化的几种情况分门别类的封装好，然后把自己变化的部分隔离成一个接口实例(interface/protocol)，让子类继承后来做选择题。 一个需要转变的思维就是：建模一个类的时候不能只局限于物体（object），也可以是行为（behavior）的封装。 用继承来替换interface实现多态的behavior也是理论可行的。这个模式还有一个强大之处：他是动态的。就是至于子类选择了什么行为，不见得是写代码的时候写死的；也可以是类似用户点击一下切换了算法。 1234567891011121314151617181920212223242526272829303132333435protocol WeaponBehavior &#123; func use()&#125;class SwordBehavior: WeaponBehavior &#123; func use() &#123; print(&quot;sword&quot;) &#125;&#125;class BowBehavior: WeaponBehavior &#123; func use() &#123; print(&quot;bow&quot;) &#125;&#125;class Character &#123; var weapon: WeaponBehavior? func attack() &#123; weapon?.use() &#125;&#125;class Knight: Character &#123; override init() &#123; super.init() weapon = SwordBehavior() &#125;&#125;class Archer: Character &#123; override init() &#123; super.init() weapon = BowBehavior() &#125;&#125;///////////////////////////////////Knight().attack() // output: swordArcher().attack() // output: bow Template Method 模板方法模式 模板方法就是抽象类衍生出来的继承树。 配图：https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3167143621,3882552175&amp;fm=27&amp;gp=0.jpg 官方定义 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 模板方法指的就是存在在抽象类中的方法声明，由子类具体实现。这样这套方法产生了一套模具不同产品的派生效果。 通过抽象类和子类实现多态。 很可惜Swift/Objective-C都没有抽象类, 所以用一般的class来实现 12345678910111213141516class Soldier &#123; func attack() &#123;&#125; // &lt;-- Template Method private init() &#123;&#125; // &lt;-- avoid creation&#125;class Paladin: Soldier &#123; override func attack() &#123; print(&quot;hammer&quot;) &#125;&#125;class Archer: Soldier &#123; override func attack() &#123; print(&quot;bow&quot;) &#125;&#125; Visitor 访问者模式 访问者模式就像一个个酒店，他们都有接待你的接口，你入住后又会利用它的基础设施。 配图：https://marketingland.com/wp-content/ml-loads/2014/08/hotel-bell-customer-service-ss-1920.jpg 官方定义 主要将数据结构与数据操作分离。 号称最复杂的设计模式，先看一下实现代码。 12345678910111213141516171819202122232425262728293031323334353637383940protocol Visitor &#123; func visit(_ c: ComponentA) func visit(_ c: ComponentB)&#125;struct ConcreteVisitor: Visitor &#123; func visit(_ c: ComponentA) &#123; c.featureA() &#125; func visit(_ c: ComponentB) &#123; c.featureB() &#125;&#125;protocol Component &#123; func accept(_ v: Visitor)&#125;struct ComponentA: Component &#123; func featureA() &#123; print(&quot;Feature A&quot;) &#125; func accept(_ v: Visitor) &#123; v.visit(self) &#125;&#125;struct ComponentB: Component &#123; func featureB() &#123; print(&quot;Feature B&quot;) &#125; func accept(_ v: Visitor) &#123; v.visit(self) &#125;&#125;let components: [Component] = [ComponentA(), ComponentB()]components.forEach &#123; $0.accept(ConcreteVisitor())&#125; 要理解这个模式需要了解一些概念： 通过这篇文章可以了解到， 其实设计模式（GoF)中的Visitor模式就是Java解决Double Dispatch的一种应用。， 我们用Swift实现一下文中双重派发问题 12345678910111213141516171819202122protocol Event &#123;&#125;class BlueEvent: Event &#123;&#125;class RedEvent: Event &#123;&#125;class Handler &#123; func handle(_ e: Event) &#123; print(&quot;Event&quot;) &#125; func handle(_ r: RedEvent) &#123; print(&quot;RedEvent&quot;) &#125; func handle(_ b: BlueEvent) &#123; print(&quot;BlueEvent&quot;) &#125;&#125;let b = BlueEvent()let r = RedEvent()let c = Handler()c.handle(b) // OUTPUT: BlueEventc.handle(r) // OUTPUT: RedEvent 验证发现，Swift是支持双重派发的。 那什么是双重派发（Double Dispatch）？ 要解释这个，要先搞清楚什么是派发（Dispatch）。 派发或者说Single Dispatch，Dynamic Dispatch，wiki是这样解释的： In most object-oriented systems, the concrete function that is called from a function call in the code depends on the dynamic type of a single object and therefore they are known as single dispatch calls, or simply virtual function calls.抓要点说，就是多态的情况下，在运行时，虚方法是由哪个具体实现执行了，这样的绑定动作就是派发。 那什么虚方法？ 看一下wiki的解释： In short, a virtual function defines a target function to be executed, but the target might not be known at compile time.虚方法就是编译期还没确定实现的方法，我们可以理解成接口中声明的方法。 好，我们现在知道了一次虚方法的绑定就是派发，双重派发就是两次绑定操作。 那双重派发的代码是如何触发派发的呢？ overload 重载 重载产生的多态引起一次派发 override 重写 接口实现的多态引起第二次派发 理解这些就知道这个模式在折腾什么了。 当然他也有另外的好处，就是可以让具体的业务类可以丢到集合里批量的执行accept visitor。]]></content>
      <categories>
        <category>Design Mode</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
        <tag>Design Mode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[YTKNetwork源码解析]]></title>
    <url>%2F2018%2F04%2F10%2FiOS%2F%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2FYTKNetwork%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[作为一名iOS开发工作者，大家应该都听过YTKNetwork框架吧。它是猿题库技术团队开源的一个网络请求框架，内部封装了AFNetworking。它把每个请求实例化，管理它的生命周期，也可以管理多个请求。 在正式讲解源码之前，我会先讲一下该框架所用的架构和设计模式。我总觉得对架构和设计有一定的了解的话，会有助于对源码的理解。 1. 架构 先上图： 在这里简单说明一下： YTKNetwork框架将每一个请求实例化，YTKBaseRequest是所有请求类的基类，YTKRequest是它的子类。所以如果我们想要发送一个请求，则需要创建并实例化一个继承于YTKRequest的自定义的请求类（CustomRequest）并发送请求。 YTKNetworkAgent是一个单例，负责管理所有的请求类（例如CustomRequest）。当CustomRequest发送请求以后，会把自己放在YTKNetworkAgent持有的一个字典里，让其管理自己。 我们说YTKNetwork封装了AFNetworking，实际上是YTKNetworkAgent封装了AFNetworking，由它负责AFNetworking请求的发送和AFNetworking的回调处理。所以如果我们想更换一个第三方网络请求库，就可以在这里更换一下。而YTKRequest更多的是只是负责缓存的处理。 YTKNetworkConfig与YTKPriviate的具体职能现在不做介绍，会在后文给出。 OK，现在我们知道了YTKNetwork中类与类之间的关系以及关键类的大致职能，接下来我会告诉你YTKNetwork为什么会采用这种关系来架构，以及采用这种架构会有什么好处。 2. 设计模式 YTKNetwork框架采用的设计模式是命令模式（Command Pattern）。 首先看一下命令模式的定义： 命令模式将请求封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。摘自：《Head First 设计模式》 看一下命令模式的类图： 图中英文的含义： 英文 中文 Command 抽象命令类 ConcreteCommand 命令类的实现类（子类） Invoker 调用者 Receiver 命令接收者（执行者) Client 客户端 详细介绍一下： 命令模式的本质是对命令的封装，将发出命令的责任和执行命令的责任分割开。 命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。 可能还是觉得有点抽象，在这里举一个《Head First 设计模式》里的例子，一个客人在餐厅点餐的过程： 你将点的菜写在订单里，交给了服务员。 服务员将订单交给厨师。 厨师做好菜之后将做好的菜交给服务员。 最后服务员把菜递给你。 在这里，命令就好比是订单，而你是命令的发起者。你的命令（订单）通过服务员（调用者）交给了命令的执行者（厨师）。所以至于这道菜具体是谁做，怎么做，你是不知道的，你做的只是发出命令和接受结果。而且对于餐厅来说，厨师是可以随便换的，而你可能对此一无所知。反过来，厨师只需要好好把菜做好，至于是谁点的菜也不需要他考虑。 结合上面命令模式的类图以及餐厅点餐的例子，我们来理清一下YTKNetwork内部的职能 场景 Command ConcreteCommand Invoker Receiver Client 餐厅 空白订单 填入菜名的订单 服务员 厨师 客人 YTKNetwork YTKBaseRequest CustomRequest YTKNetworkAgent AFNetworking ViewController/ViewModel 可以看到，YTKNetwork对命令模式的实现是很符合其设计标准的，它将请求的发起者和接收者分离开来(中间隔着调用者)，可以让我们随时更换接受者。 另外，因为封装了请求，我们既可以管理单个请求，也可以同时管理多个请求，甚至实现琏式请求的发送。关于多个请求的发送，我们也可以想象在餐厅里，你可以在吃的过程中还想起来要吃别的东西，例如点心，饮料之类的，你就可以填多个订单（当然也可以写在一起）交给服务员。 相信到这里，大家应该对YTKNetwork的设计与架构有了足够的认识了，下面进入到真正的源码解析，我们结合一下它的代码来看一下YTKNetwork是如何实现和管理网络请求的。 3. 源码解析 在真正讲解源码之前，我先详细说一下各个类的职责: 3.1 责任介绍 类名 职责 YTKBaseRequest 所有请求类的基类。持有NSURLSessionTask实例，responseData，responseObject，error等重要数据，提供一些需要子类实现的与网络请求相关的方法，处理回调的代理和block，命令YTKNetworkAgent发起网络请求。 YTKRequest YTKBaseRequest的子类。负责缓存的处理：请求前查询缓存；请求后写入缓存。 YTKNetworkConfig 被YTKRequest和YTKNetworkAgent访问。负责所有请求的全局配置，例如baseUrl和CDNUrl等等。 YTKNetworkPrivate 提供JSON验证，appVersion等辅助性的方法；给YTKBaseRequest增加一些分类。 YTKNetworkAgent 真正发起请求的类。负责发起请求，结束请求，并持有一个字典来存储正在执行的请求。 YTKBatchRequest 可以发起批量请求，持有一个数组来保存所有的请求类。在请求执行后遍历这个数组来发起请求，如果其中有一个请求返回失败，则认定本组请求失败。 YTKBatchRequestAgent 负责管理多个YTKBatchRequest实例，持有一个数组来保存YTKBatchRequest。支持添加和删除YTKBatchRequest实例。 YTKChainRequest 可以发起链式请求，持有一个数组来保存所有的请求类。当某个请求结束后才能发起下一个请求，如果其中有一个请求返回失败，则认定本请求链失败。 YTKChainRequestAgent 负责管理多个YTKChainRequestAgent实例，持有一个数组来保存YTKChainRequest。支持添加和删除YTKChainRequest实例。 OK，现在知道了YTKNetwork内部的责任分配，下面我们先从单个请求的全部流程（配置，发起，结束）来看一下YTKNetwork都做了什么。 3.2 单个请求3.21 单个请求的配置官方的教程建议我们将请求的全局配置是在AppDelegate.m文件里，设定baseUrl以及cdnUrl等参数。 1234567- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; YTKNetworkConfig *config = [YTKNetworkConfig sharedConfig]; config.baseUrl = @&quot;http://yuantiku.com&quot;; config.cdnUrl = @&quot;http://fen.bi&quot;;&#125; 如果我们需要新建一个注册的请求，则需要创建一个继承于YTKRequest的注册接口的类RegisterApi，并将针对该请求参数配置好： 12345678910111213141516171819202122232425262728293031323334353637// RegisterApi.h#import &quot;YTKRequest.h&quot;@interface RegisterApi : YTKRequest- (id)initWithUsername:(NSString *)username password:(NSString *)password;@end// RegisterApi.m#import &quot;RegisterApi.h&quot;@implementation RegisterApi &#123; NSString *_username; NSString *_password;&#125;//初始化的时候将两个参数值传入- (id)initWithUsername:(NSString *)username password:(NSString *)password &#123; self = [super init]; if (self) &#123; _username = username; _password = password; &#125; return self;&#125;//需要和baseUrl拼接的地址- (NSString *)requestUrl &#123; // “ http://www.yuantiku.com ” 在 YTKNetworkConfig 中设置，这里只填除去域名剩余的网址信息 return @&quot;/iphone/register&quot;;&#125;//请求方法，某人是GET- (YTKRequestMethod)requestMethod &#123; return YTKRequestMethodPOST;&#125;//请求体- (id)requestArgument &#123; return @&#123; @&quot;username&quot;: _username, @&quot;password&quot;: _password &#125;;&#125;@end 现在我们知道如何配置全局的参数和针对某个请求的参数了，接下来看一下单个请求是如何发起的。 3.22 单个请求的发起还是刚才的注册API，在实例化以后，直接调用startWithCompletionBlockWithSuccess:failure方法（或start方法）就可以发起它： 123456789101112131415//LoginViewController.m- (void)loginButtonPressed:(id)sender &#123; NSString *username = self.UserNameTextField.text; NSString *password = self.PasswordTextField.text; if (username.length &gt; 0 &amp;&amp; password.length &gt; 0) &#123; RegisterApi *api = [[RegisterApi alloc] initWithUsername:username password:password]; [api startWithCompletionBlockWithSuccess:^(YTKBaseRequest *request) &#123; // 你可以直接在这里使用 self NSLog(@&quot;succeed&quot;); &#125; failure:^(YTKBaseRequest *request) &#123; // 你可以直接在这里使用 self NSLog(@&quot;failed&quot;); &#125;]; &#125;&#125; 上面是以block的形式回调，YTKNetwork也支持代理的回调： 12345678910111213141516//LoginViewController.m- (void)loginButtonPressed:(id)sender &#123; NSString *username = self.UserNameTextField.text; NSString *password = self.PasswordTextField.text; if (username.length &gt; 0 &amp;&amp; password.length &gt; 0) &#123; RegisterApi *api = [[RegisterApi alloc] initWithUsername:username password:password]; api.delegate = self; [api start]; &#125;&#125;- (void)requestFinished:(YTKBaseRequest *)request &#123; NSLog(@&quot;succeed&quot;);&#125;- (void)requestFailed:(YTKBaseRequest *)request &#123; NSLog(@&quot;failed&quot;);&#125; 有两点需要注意的是： 必须给自定义请求类（RegisterApi）调用startWithCompletionBlockWithSuccess:failure方法（或start方法），才能真正发起请求。 在同时设置了回调代理和回调block的情况下，首先回调的是回调代理方法，然后再走回调block。 知道了YTKRequest请求是如何在外部发起的，我们现在从startWithCompletionBlockWithSuccess:failure方法开始，来看一下YTKNetwork都做了什么： 首先来到YTKBaseRequest类（因为最早是由它定义的该方法）： 123456789101112131415//YTKBaseRequest.m//传入成功和失败的block,并保存起来- (void)startWithCompletionBlockWithSuccess:(YTKRequestCompletionBlock)success failure:(YTKRequestCompletionBlock)failure &#123; //保存成功和失败的回调block，便于将来调用 [self setCompletionBlockWithSuccess:success failure:failure]; //发起请求 [self start];&#125;//保存成功和失败的block- (void)setCompletionBlockWithSuccess:(YTKRequestCompletionBlock)success failure:(YTKRequestCompletionBlock)failure &#123; self.successCompletionBlock = success; self.failureCompletionBlock = failure;&#125; 当保存完成功和失败的block以后，调用start方法，于是来到了YTKRequest类（注意，虽然YTKBaseRequest也实现了start方法，但是由于YTKRequest类是它的子类并也实现了start方法，所以这里最先走的是YTKRequest类的start方法）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344//YTKRequest.m- (void)start &#123; //1. 如果忽略缓存 -&gt; 请求 if (self.ignoreCache) &#123; [self startWithoutCache]; return; &#125; //2. 如果存在下载未完成的文件 -&gt; 请求 if (self.resumableDownloadPath) &#123; [self startWithoutCache]; return; &#125; //3. 获取缓存失败 -&gt; 请求 if (![self loadCacheWithError:nil]) &#123; [self startWithoutCache]; return; &#125; //4. 到这里，说明一定能拿到可用的缓存，可以直接回调了（因为一定能拿到可用的缓存，所以一定是调用成功的block和代理） _dataFromCache = YES; dispatch_async(dispatch_get_main_queue(), ^&#123; //5. 回调之前的操作 //5.1 缓存处理 [self requestCompletePreprocessor]; //5.2 用户可以在这里进行真正回调前的操作 [self requestCompleteFilter]; YTKRequest *strongSelf = self; //6. 执行回调 //6.1 请求完成的代理 [strongSelf.delegate requestFinished:strongSelf]; //6.2 请求成功的block if (strongSelf.successCompletionBlock) &#123; strongSelf.successCompletionBlock(strongSelf); &#125; //7. 把成功和失败的block都设置为nil，避免循环引用 [strongSelf clearCompletionBlock]; &#125;);&#125; 我们之前说过YTKRequest负责缓存的相关处理，所以在上面这个start方法里，它做的是请求之前缓存的查询和检查工作: 如果忽略缓存，或者缓存获取失败，调用startWithoutCache方法（参考1-3的情况），发起请求。 如果能成功获取到缓存，则直接回调（参考4-7的情况）。 我们来看一下每一步的具体实现： ignoreCache属性是用户手动设置的，如果用户强制忽略缓存，则无论是否缓存是否存在，直接发送请求。 resumableDownloadPath是断点下载路径，如果该路径不为空，说明有未完成的下载任务，则直接发送请求继续下载。 loadCacheWithError：方法验证了加载缓存是否成功的方法（返回值为YES，说明可以加载缓存；反之亦然），看一下具体实现： 123456789101112131415161718192021222324252627282930//YTKRequest.m- (BOOL)loadCacheWithError:(NSError * _Nullable __autoreleasing *)error &#123; // 缓存时间小于0，则返回（缓存时间默认为-1，需要用户手动设置，单位是秒） if ([self cacheTimeInSeconds] &lt; 0) &#123; if (error) &#123; *error = [NSError errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorInvalidCacheTime userInfo:@&#123; NSLocalizedDescriptionKey:@&quot;Invalid cache time&quot;&#125;]; &#125; return NO; &#125; // 是否有缓存的元数据，如果没有，返回错误 if (![self loadCacheMetadata]) &#123; if (error) &#123; *error = [NSError errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorInvalidMetadata userInfo:@&#123; NSLocalizedDescriptionKey:@&quot;Invalid metadata. Cache may not exist&quot;&#125;]; &#125; return NO; &#125; // 有缓存，再验证是否有效 if (![self validateCacheWithError:error]) &#123; return NO; &#125; // 有缓存，而且有效，再验证是否能取出来 if (![self loadCacheData]) &#123; if (error) &#123; *error = [NSError errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorInvalidCacheData userInfo:@&#123; NSLocalizedDescriptionKey:@&quot;Invalid cache data&quot;&#125;]; &#125; return NO; &#125; return YES;&#125; 先讲一下什么是元数据：元数据是指数据的数据，在这里描述了缓存数据本身的一些特征：包括版本号，缓存时间，敏感信息等等， 稍后会做详细介绍。 我们来看一下上面关于缓存的元数据的获取方法：loadCacheMetadata方法 1234567891011121314151617//YTKRequest.m- (BOOL)loadCacheMetadata &#123; NSString *path = [self cacheMetadataFilePath]; NSFileManager * fileManager = [NSFileManager defaultManager]; if ([fileManager fileExistsAtPath:path isDirectory:nil]) &#123; @try &#123; //将序列化之后被保存在磁盘里的文件反序列化到当前对象的属性cacheMetadata _cacheMetadata = [NSKeyedUnarchiver unarchiveObjectWithFile:path]; return YES; &#125; @catch (NSException *exception) &#123; YTKLog(@&quot;Load cache metadata failed, reason = %@&quot;, exception.reason); return NO; &#125; &#125; return NO;&#125; cacheMetadata（YTKCacheMetadata） 是当前reqeust类用来保存缓存元数据的属性。 YTKCacheMetadata类被定义在YTKRequest.m文件里面： 12345678910//YTKRequest.m@interface YTKCacheMetadata : NSObject&lt;NSSecureCoding&gt;@property (nonatomic, assign) long long version;@property (nonatomic, strong) NSString *sensitiveDataString;@property (nonatomic, assign) NSStringEncoding stringEncoding;@property (nonatomic, strong) NSDate *creationDate;@property (nonatomic, strong) NSString *appVersionString;@end 它描述的是缓存的版本号，敏感信息，创建时间，app版本等信息，并支持序列化处理，可以保存在磁盘里。因此，loadCacheMetadata方法的目的是将之前被序列化保存的缓存元数据信息反序列化，赋给自身的cacheMetadata属性上。 现在获取了缓存的元数据并赋给了自身的cacheMetadata属性上，那么接下来就要逐一验证元数据里的各项信息是否符合要求，在下面的validateCacheWithError：里面验证： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//YTKRequest.m- (BOOL)validateCacheWithError:(NSError * _Nullable __autoreleasing *)error &#123; // 是否大于过期时间 NSDate *creationDate = self.cacheMetadata.creationDate; NSTimeInterval duration = -[creationDate timeIntervalSinceNow]; if (duration &lt; 0 || duration &gt; [self cacheTimeInSeconds]) &#123; if (error) &#123; *error = [NSError errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorExpired userInfo:@&#123; NSLocalizedDescriptionKey:@&quot;Cache expired&quot;&#125;]; &#125; return NO; &#125; // 缓存的版本号是否符合 long long cacheVersionFileContent = self.cacheMetadata.version; if (cacheVersionFileContent != [self cacheVersion]) &#123; if (error) &#123; *error = [NSError errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorVersionMismatch userInfo:@&#123; NSLocalizedDescriptionKey:@&quot;Cache version mismatch&quot;&#125;]; &#125; return NO; &#125; // 敏感信息是否符合 NSString *sensitiveDataString = self.cacheMetadata.sensitiveDataString; NSString *currentSensitiveDataString = ((NSObject *)[self cacheSensitiveData]).description; if (sensitiveDataString || currentSensitiveDataString) &#123; // If one of the strings is nil, short-circuit evaluation will trigger if (sensitiveDataString.length != currentSensitiveDataString.length || ![sensitiveDataString isEqualToString:currentSensitiveDataString]) &#123; if (error) &#123; *error = [NSError errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorSensitiveDataMismatch userInfo:@&#123; NSLocalizedDescriptionKey:@&quot;Cache sensitive data mismatch&quot;&#125;]; &#125; return NO; &#125; &#125; // app的版本是否符合 NSString *appVersionString = self.cacheMetadata.appVersionString; NSString *currentAppVersionString = [YTKNetworkUtils appVersionString]; if (appVersionString || currentAppVersionString) &#123; if (appVersionString.length != currentAppVersionString.length || ![appVersionString isEqualToString:currentAppVersionString]) &#123; if (error) &#123; *error = [NSError errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorAppVersionMismatch userInfo:@&#123; NSLocalizedDescriptionKey:@&quot;App version mismatch&quot;&#125;]; &#125; return NO; &#125; &#125; return YES;&#125; 如果每项元数据信息都能通过，再在loadCacheData方法里面验证缓存是否能被取出来： 123456789101112131415161718192021222324//YTKRequest.m- (BOOL)loadCacheData &#123; NSString *path = [self cacheFilePath]; NSFileManager *fileManager = [NSFileManager defaultManager]; NSError *error = nil; if ([fileManager fileExistsAtPath:path isDirectory:nil]) &#123; NSData *data = [NSData dataWithContentsOfFile:path]; _cacheData = data; _cacheString = [[NSString alloc] initWithData:_cacheData encoding:self.cacheMetadata.stringEncoding]; switch (self.responseSerializerType) &#123; case YTKResponseSerializerTypeHTTP: // Do nothing. return YES; case YTKResponseSerializerTypeJSON: _cacheJSON = [NSJSONSerialization JSONObjectWithData:_cacheData options:(NSJSONReadingOptions)0 error:&amp;error]; return error == nil; case YTKResponseSerializerTypeXMLParser: _cacheXML = [[NSXMLParser alloc] initWithData:_cacheData]; return YES; &#125; &#125; return NO;&#125; 如果通过了最终的考验，则说明当前请求对应的缓存是符合各项要求并可以被成功取出，也就是可以直接进行回调了。 当确认缓存可以成功取出后，手动设置dataFromCache属性为 YES，说明当前的请求结果是来自于缓存，而没有通过网络请求。 然后在真正回调之前做了如下处理： 12345678910//YTKRequest.m：- (void)start&#123; .... //5. 回调之前的操作 //5.1 缓存处理 [self requestCompletePreprocessor]; //5.2 用户可以在这里进行真正回调前的操作 [self requestCompleteFilter]; ....&#125; 5.1：requestCompletePreprocessor方法: 1234567891011121314151617//YTKRequest.m：- (void)requestCompletePreprocessor &#123; [super requestCompletePreprocessor]; //是否异步将responseData写入缓存（写入缓存的任务放在专门的队列ytkrequest_cache_writing_queue进行） if (self.writeCacheAsynchronously) &#123; dispatch_async(ytkrequest_cache_writing_queue(), ^&#123; //保存响应数据到缓存 [self saveResponseDataToCacheFile:[super responseData]]; &#125;); &#125; else &#123; //保存响应数据到缓存 [self saveResponseDataToCacheFile:[super responseData]]; &#125;&#125; 1234567891011121314151617181920212223//YTKRequest.m：//保存响应数据到缓存- (void)saveResponseDataToCacheFile:(NSData *)data &#123; if ([self cacheTimeInSeconds] &gt; 0 &amp;&amp; ![self isDataFromCache]) &#123; if (data != nil) &#123; @try &#123; // New data will always overwrite old data. [data writeToFile:[self cacheFilePath] atomically:YES]; YTKCacheMetadata *metadata = [[YTKCacheMetadata alloc] init]; metadata.version = [self cacheVersion]; metadata.sensitiveDataString = ((NSObject *)[self cacheSensitiveData]).description; metadata.stringEncoding = [YTKNetworkUtils stringEncodingWithRequest:self]; metadata.creationDate = [NSDate date]; metadata.appVersionString = [YTKNetworkUtils appVersionString]; [NSKeyedArchiver archiveRootObject:metadata toFile:[self cacheMetadataFilePath]]; &#125; @catch (NSException *exception) &#123; YTKLog(@&quot;Save cache failed, reason = %@&quot;, exception.reason); &#125; &#125; &#125;&#125; 我们可以看到, requestCompletePreprocessor方法的任务是将响应数据保存起来，也就是做缓存。但是，缓存的保存有两个条件，一个是需要cacheTimeInSeconds方法返回正整数（缓存时间，单位是秒，后续会详细说明）；另一个条件是isDataFromCache方法返回NO。但是我们知道，如果缓存可用，就会将这个属性设置为YES，所以走到这里的时候，就不做缓存了。 接着看下5.2：requestCompleteFilter方法则是需要用户自己提供具体实现的，专门作为回调成功之前的一些处理： 123//YTKBaseRequest.m- (void)requestCompleteFilter &#123;&#125; 到这里，回调之前的处理都结束了，下面来看一下在缓存可用的情况下的回调： 123456789101112131415161718//YTKRequest.m- (void)start&#123; ... YTKRequest *strongSelf = self; //6. 执行回调 //6.1 请求完成的代理 [strongSelf.delegate requestFinished:strongSelf]; //6.2 请求成功的block if (strongSelf.successCompletionBlock) &#123; strongSelf.successCompletionBlock(strongSelf); &#125; //7. 把成功和失败的block都设置为nil，避免循环引用 [strongSelf clearCompletionBlock];&#125; 我们可以看到 ，这里面同时存在两种回调：代理的回调和block的回调。先执行的是代理的回调，然后执行的是block的回调。而且在回调结束之后，YTKNetwork会帮助我们清空回调的block： 123456//YTKBaseRequest.m- (void)clearCompletionBlock &#123; // 清空请求结束的block，避免循环引用 self.successCompletionBlock = nil; self.failureCompletionBlock = nil;&#125; 注意，在用户同时实现了代理和block的情况下，二者都会被调用。 到这里，我们了解了YTKNetwork在网络请求之前是如何验证缓存，以及在缓存有效的情况下是如何回调的。 反过来，如果缓存无效（或忽略缓存）时，需要立即请求网络。那么我们现在来看一看在这个时候YTKNetwork都做了什么： 仔细看一下上面的start方法，我们会发现，如果缓存不满足条件时，会直接调用startWithoutCache方法： 1234567891011121314151617181920//YTKRequest.m- (void)start&#123; //1. 如果忽略缓存 -&gt; 请求 if (self.ignoreCache) &#123; [self startWithoutCache]; return; &#125; //2. 如果存在下载未完成的文件 -&gt; 请求 if (self.resumableDownloadPath) &#123; [self startWithoutCache]; return; &#125; //3. 获取缓存失败 -&gt; 请求 if (![self loadCacheWithError:nil]) &#123; [self startWithoutCache]; return; &#125; ......&#125; 那么在startWithoutCache方法里都做了什么呢？ 123456789101112131415161718//YTKRequest.m- (void)startWithoutCache &#123; //1. 清除缓存 [self clearCacheVariables]; //2. 调用父类的发起请求 [super start];&#125;//清除当前请求对应的所有缓存- (void)clearCacheVariables &#123; _cacheData = nil; _cacheXML = nil; _cacheJSON = nil; _cacheString = nil; _cacheMetadata = nil; _dataFromCache = NO;&#125; 在这里，首先清除了关于缓存的所有数据，然后调用父类的start方法: 12345678//YTKBaseRequest.m:- (void)start &#123; //1. 告诉Accessories即将回调了（其实是即将发起请求） [self toggleAccessoriesWillStartCallBack]; //2. 令agent添加请求并发起请求，在这里并不是组合关系，agent只是一个单例 [[YTKNetworkAgent sharedAgent] addRequest:self];&#125; 第一步里的Accessories是一些遵从代理的对象。这个代理定义了一些用来追踪请求状况的方法。它被定义在了YTKBaseRequest.h文件里： 123456789101112131415161718//用来跟踪请求的状态的代理。@protocol YTKRequestAccessory &lt;NSObject&gt;@optional/// Inform the accessory that the request is about to start.////// @param request The corresponding request.- (void)requestWillStart:(id)request;/// Inform the accessory that the request is about to stop. This method is called/// before executing `requestFinished` and `successCompletionBlock`.////// @param request The corresponding request.- (void)requestWillStop:(id)request;/// Inform the accessory that the request has already stoped. This method is called/// after executing `requestFinished` and `successCompletionBlock`.////// @param request The corresponding request.- (void)requestDidStop:(id)request;@end 所以只要某个对象遵从了这个代理，就可以追踪到请求将要开始，将要结束，已经结束的状态。 接着看一下第二步：YTKNetworkAgent把当前的请求对象添加到了自己身上并发送请求。来看一下它的具体实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//YTKNetworkAgent.m- (void)addRequest:(YTKBaseRequest *)request &#123; //1. 获取task NSParameterAssert(request != nil); NSError * __autoreleasing requestSerializationError = nil; //获取用户自定义的requestURL NSURLRequest *customUrlRequest= [request buildCustomUrlRequest]; if (customUrlRequest) &#123; __block NSURLSessionDataTask *dataTask = nil; //如果存在用户自定义request，则直接走AFNetworking的dataTaskWithRequest:方法 dataTask = [_manager dataTaskWithRequest:customUrlRequest completionHandler:^(NSURLResponse * _Nonnull response, id _Nullable responseObject, NSError * _Nullable error) &#123; //响应的统一处理 [self handleRequestResult:dataTask responseObject:responseObject error:error]; &#125;]; request.requestTask = dataTask; &#125; else &#123; //如果用户没有自定义url，则直接走这里 request.requestTask = [self sessionTaskForRequest:request error:&amp;requestSerializationError]; &#125; //序列化失败，则认定为请求失败 if (requestSerializationError) &#123; //请求失败的处理 [self requestDidFailWithRequest:request error:requestSerializationError]; return; &#125; NSAssert(request.requestTask != nil, @&quot;requestTask should not be nil&quot;); // 优先级的映射 // !!Available on iOS 8 + if ([request.requestTask respondsToSelector:@selector(priority)]) &#123; switch (request.requestPriority) &#123; case YTKRequestPriorityHigh: request.requestTask.priority = NSURLSessionTaskPriorityHigh; break; case YTKRequestPriorityLow: request.requestTask.priority = NSURLSessionTaskPriorityLow; break; case YTKRequestPriorityDefault: /*!!fall through*/ default: request.requestTask.priority = NSURLSessionTaskPriorityDefault; break; &#125; &#125; // Retain request YTKLog(@&quot;Add request: %@&quot;, NSStringFromClass([request class])); //2. 将request放入保存请求的字典中，taskIdentifier为key，request为值 [self addRequestToRecord:request]; //3. 开始task [request.requestTask resume];&#125; 这个方法挺长的，但是请不要被吓到，它总共分为三个部分： 第一部分是获取当前请求对应的task并赋给request的requestTask属性（以后提到的request，都为用户自定义的当前请求类的实例）。 第二部分是把request放入专门用来保存请求的字典中，key为taskIdentifier。 第三部分是启动task。 下面我来依次讲解每个部分： 第一部分：获取当前请求对应的task并赋给request： 123456789101112131415161718192021//YTKNetworkAgent.m- (void)addRequest:(YTKBaseRequest *)request &#123; ... if (customUrlRequest) &#123; __block NSURLSessionDataTask *dataTask = nil; //如果存在用户自定义request，则直接走AFNetworking的dataTaskWithRequest:方法 dataTask = [_manager dataTaskWithRequest:customUrlRequest completionHandler:^(NSURLResponse * _Nonnull response, id _Nullable responseObject, NSError * _Nullable error) &#123; //统一处理请求响应 [self handleRequestResult:dataTask responseObject:responseObject error:error]; &#125;]; request.requestTask = dataTask; &#125; else &#123; //如果用户没有自定义url，则直接走这里 request.requestTask = [self sessionTaskForRequest:request error:&amp;requestSerializationError]; &#125; ...&#125; 在这里判断了用户是否自定义了request： 如果是，则直接调用AFNetworking的dataTaskWithRequest:方法。 如果不是，则调用YTKRequest自己的生成task的方法。 第一种情况就不说了，因为AF帮我们做好了。在这里看一下第二种情况，sessionTaskForRequest: error :方法内部： 从这个方法最后的switch语句可以看出，这个方法的作用是返回当前request的NSURLSessionTask的实例。而且最终生成NSURLSessionTask实例的方法都是通过dataTaskWithHTTPMethod:requestSerializer:URLString:parameters:error:这个私有方法来实现的。在讲解这个关键的私有方法之前，先来逐步讲解一下这个私有方法需要的每个参数的获取方法： 获得请求类型（GET，POST等）： 123456//YTKNetworkAgent.m- (NSURLSessionTask *)sessionTaskForRequest:(YTKBaseRequest *)request error:(NSError * _Nullable __autoreleasing *)error &#123; ... YTKRequestMethod method = [request requestMethod]; ...&#125; requestMethod方法最初在YTKBaseRequest里面已经实现了，默认返回了YTKRequestMethodGET。 它的枚举类型在YTKBaseRequest.h里面定义： 12345678910//YTKBaseRequest.h/// HTTP Request method.typedef NS_ENUM(NSInteger, YTKRequestMethod) &#123; YTKRequestMethodGET = 0, YTKRequestMethodPOST, YTKRequestMethodHEAD, YTKRequestMethodPUT, YTKRequestMethodDELETE, YTKRequestMethodPATCH,&#125;; 用户可以根据实际的需求在自定义request类里面重写这个方法： 1234//RegisterAPI.m- (YTKRequestMethod)requestMethod &#123; return YTKRequestMethodPOST;&#125; 获得请求url： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//YTKNetworkAgent.m- (NSURLSessionTask *)sessionTaskForRequest:(YTKBaseRequest *)request error:(NSError * _Nullable __autoreleasing *)error &#123; ... NSString *url = [self buildRequestUrl:request]; ...&#125;//返回当前请求url- (NSString *)buildRequestUrl:(YTKBaseRequest *)request &#123; NSParameterAssert(request != nil); //用户自定义的url（不包括在YTKConfig里面设置的base_url） NSString *detailUrl = [request requestUrl]; NSURL *temp = [NSURL URLWithString:detailUrl]; // 存在host和scheme的url立即返回正确 if (temp &amp;&amp; temp.host &amp;&amp; temp.scheme) &#123; return detailUrl; &#125; // 如果需要过滤url，则过滤 NSArray *filters = [_config urlFilters]; for (id&lt;YTKUrlFilterProtocol&gt; f in filters) &#123; detailUrl = [f filterUrl:detailUrl withRequest:request]; &#125; NSString *baseUrl; if ([request useCDN]) &#123; //如果使用CDN，在当前请求没有配置CDN地址的情况下，返回全局配置的CDN if ([request cdnUrl].length &gt; 0) &#123; baseUrl = [request cdnUrl]; &#125; else &#123; baseUrl = [_config cdnUrl]; &#125; &#125; else &#123; //如果使用baseUrl，在当前请求没有配置baseUrl，返回全局配置的baseUrl if ([request baseUrl].length &gt; 0) &#123; baseUrl = [request baseUrl]; &#125; else &#123; baseUrl = [_config baseUrl]; &#125; &#125; // 如果末尾没有/，则在末尾添加一个／ NSURL *url = [NSURL URLWithString:baseUrl]; if (baseUrl.length &gt; 0 &amp;&amp; ![baseUrl hasSuffix:@&quot;/&quot;]) &#123; url = [url URLByAppendingPathComponent:@&quot;&quot;]; &#125; return [NSURL URLWithString:detailUrl relativeToURL:url].absoluteString;&#125; 获得请求参数 123456789//YTKNetworkAgent.m- (NSURLSessionTask *)sessionTaskForRequest:(YTKBaseRequest *)request error:(NSError * _Nullable __autoreleasing *)error &#123; ... //获取用户提供的请求参数 id param = request.requestArgument; //获取用户提供的构造请求体的block（默认是没有的） AFConstructingBlock constructingBlock = [request constructingBodyBlock]; ...&#125; 在这里，requestArgument是一个get方法，需要用户自己定义请求体，例如在RegisterAPI里面就定义了两个请求参数： 1234567//RegisterApi.m- (id)requestArgument &#123; return @&#123; @&quot;username&quot;: _username, @&quot;password&quot;: _password &#125;;&#125; 获得request serializer 123456789101112131415161718192021222324252627282930313233343536373839//YTKNetworkAgent.m- (NSURLSessionTask *)sessionTaskForRequest:(YTKBaseRequest *)request error:(NSError * _Nullable __autoreleasing *)error &#123; ... //4. 获得request serializer AFHTTPRequestSerializer *requestSerializer = [self requestSerializerForRequest:request]; ...&#125;- (AFHTTPRequestSerializer *)requestSerializerForRequest:(YTKBaseRequest *)request &#123; AFHTTPRequestSerializer *requestSerializer = nil; //HTTP or JSON if (request.requestSerializerType == YTKRequestSerializerTypeHTTP) &#123; requestSerializer = [AFHTTPRequestSerializer serializer]; &#125; else if (request.requestSerializerType == YTKRequestSerializerTypeJSON) &#123; requestSerializer = [AFJSONRequestSerializer serializer]; &#125; //超时时间 requestSerializer.timeoutInterval = [request requestTimeoutInterval]; //是否允许数据服务 requestSerializer.allowsCellularAccess = [request allowsCellularAccess]; //如果当前请求需要验证 NSArray&lt;NSString *&gt; *authorizationHeaderFieldArray = [request requestAuthorizationHeaderFieldArray]; if (authorizationHeaderFieldArray != nil) &#123; [requestSerializer setAuthorizationHeaderFieldWithUsername:authorizationHeaderFieldArray.firstObject password:authorizationHeaderFieldArray.lastObject]; &#125; //如果当前请求需要自定义 HTTPHeaderField NSDictionary&lt;NSString *, NSString *&gt; *headerFieldValueDictionary = [request requestHeaderFieldValueDictionary]; if (headerFieldValueDictionary != nil) &#123; for (NSString *httpHeaderField in headerFieldValueDictionary.allKeys) &#123; NSString *value = headerFieldValueDictionary[httpHeaderField]; [requestSerializer setValue:value forHTTPHeaderField:httpHeaderField]; &#125; &#125; return requestSerializer;&#125; 上面这个方法通过传入的request实例，根据它的一些配置（用户提供）来获取AFHTTPRequestSerializer的实例。 到现在为止，获取NSURLSessionTask实例的几个参数都拿到了，剩下的就是调用dataTaskWithHTTPMethod:requestSerializer:URLString:parameters:error:方法来获取NSURLSessionTask实例了。我们来看一下这个方法的具体实现： 12345678910111213141516171819202122232425262728293031//YTKNetworkAgent.m- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method requestSerializer:(AFHTTPRequestSerializer *)requestSerializer URLString:(NSString *)URLString parameters:(id)parameters error:(NSError * _Nullable __autoreleasing *)error &#123; return [self dataTaskWithHTTPMethod:method requestSerializer:requestSerializer URLString:URLString parameters:parameters constructingBodyWithBlock:nil error:error];&#125;//最终返回NSURLSessionDataTask实例- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method requestSerializer:(AFHTTPRequestSerializer *)requestSerializer URLString:(NSString *)URLString parameters:(id)parameters constructingBodyWithBlock:(nullable void (^)(id &lt;AFMultipartFormData&gt; formData))block error:(NSError * _Nullable __autoreleasing *)error &#123; NSMutableURLRequest *request = nil; //根据有无构造请求体的block的情况来获取request if (block) &#123; request = [requestSerializer multipartFormRequestWithMethod:method URLString:URLString parameters:parameters constructingBodyWithBlock:block error:error]; &#125; else &#123; request = [requestSerializer requestWithMethod:method URLString:URLString parameters:parameters error:error]; &#125; //获得request以后来获取dataTask __block NSURLSessionDataTask *dataTask = nil; dataTask = [_manager dataTaskWithRequest:request completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *_error) &#123; //响应的统一处理 [self handleRequestResult:dataTask responseObject:responseObject error:_error]; &#125;]; return dataTask;&#125; 这两个方法，上面的方法调用了下面的来获取最终的NSURLSessionDataTask实例。 OK，现在我们已经知道了NSURLSessionDataTask实例是如何获取的，再来看一下在addRequest：方法里接下来做的是对序列化失败的处理： 123456789101112//YTKNetworkAgent.m- (void)addRequest:(YTKBaseRequest *)request &#123; ... //序列化失败 if (requestSerializationError) &#123; //请求失败的处理 [self requestDidFailWithRequest:request error:requestSerializationError]; return; &#125; ...&#125; requestDidFailWithRequest:方法专门处理请求失败的情况，因为它被包含在统一处理请求回调的方法中，所以在稍后会在讲解统一处理请求回调的方法的时候再详细讲解这个方法。 继续往下走，到了优先级的映射部分： 1234567891011121314151617181920212223//YTKNetworkAgent.m- (void)addRequest:(YTKBaseRequest *)request &#123; ... // 优先级的映射 // !!Available on iOS 8 + if ([request.requestTask respondsToSelector:@selector(priority)]) &#123; switch (request.requestPriority) &#123; case YTKRequestPriorityHigh: request.requestTask.priority = NSURLSessionTaskPriorityHigh; break; case YTKRequestPriorityLow: request.requestTask.priority = NSURLSessionTaskPriorityLow; break; case YTKRequestPriorityDefault: /*!!fall through*/ default: request.requestTask.priority = NSURLSessionTaskPriorityDefault; break; &#125; &#125; ...&#125; requestPriority是YTKBaseRequest的一个枚举属性，它的枚举在YTKBaseRequest.h里面被定义： 12345typedef NS_ENUM(NSInteger, YTKRequestPriority) &#123; YTKRequestPriorityLow = -4L, YTKRequestPriorityDefault = 0, YTKRequestPriorityHigh = 4,&#125;; 在这里，将用户设置的YTKRequestPriority映射到NSURLSessionTask的priority上。 到这里，我们拿到了task的实例并设置好了优先级，紧接着就是addRequest:方法里的第二个部分：YTKNetworkAgent将request实例放在了一个字典中，保存起来： 第二部分：把request放入专门用来保存请求的字典中，key为taskIdentifier： 123456789101112131415161718//YTKNetworkAgent.m- (void)addRequest:(YTKBaseRequest *)request &#123; ... ... //将request实例放入保存请求的字典中，taskIdentifier为key，request为值 [self addRequestToRecord:request]; ...&#125;- (void)addRequestToRecord:(YTKBaseRequest *)request &#123; //加锁 Lock(); _requestsRecord[@(request.requestTask.taskIdentifier)] = request; Unlock();&#125;#define Lock() pthread_mutex_lock(&amp;_lock)#define Unlock() pthread_mutex_unlock(&amp;_lock) 可以看到，在添加前和添加后是进行了加锁和解锁的处理的。而且request实例被保存的时候，将其task的identifier作为key来保存。 在当前的request被保存以后，就到了最后一步，正式发起请求： 第三部分：启动task 1234567//YTKNetworkAgent.m- (NSURLSessionTask *)sessionTaskForRequest:(YTKBaseRequest *)request error:(NSError * _Nullable __autoreleasing *)error &#123; ... [request.requestTask resume]; ...&#125; 到现在为止，我们了解了YTKNetwork里面，一个请求开始之前做的事情：查找可用缓存，生成NSURLSessionTask实例，获取url，requestSerializer，将request放到YTKNetworkAgent的一个字典里等等（详细流程会在稍后给出）。 那么接下来我们看一下YTKNetwork是如何处理请求的回调的。 眼尖的同学们可能会注意到，在获取NSURLSessionTask实例的时候，出现了两次“响应的统一处理”的注释，大家可以搜索这个注释就可以找到这个方法：handleRequestResult:responseObject:error:。这个方法负责的是对请求回调的处理，当然包括了成功和失败的情况。我们来看一下在这个方法里都做了什么： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//YTKNetworkAgent.m//统一处理请求结果，包括成功和失败的情况- (void)handleRequestResult:(NSURLSessionTask *)task responseObject:(id)responseObject error:(NSError *)error &#123; //1. 获取task对应的request Lock(); YTKBaseRequest *request = _requestsRecord[@(task.taskIdentifier)]; Unlock(); //如果不存在对应的request，则立即返回 if (!request) &#123; return; &#125; 。。。 //2. 获取request对应的response request.responseObject = responseObject; //3. 获取responseObject，responseData和responseString if ([request.responseObject isKindOfClass:[NSData class]]) &#123; //3.1 获取 responseData request.responseData = responseObject; //3.2 获取responseString request.responseString = [[NSString alloc] initWithData:responseObject encoding:[YTKNetworkUtils stringEncodingWithRequest:request]]; //3.3 获取responseObject（或responseJSONObject） //根据返回的响应的序列化的类型来得到对应类型的响应 switch (request.responseSerializerType) &#123; case YTKResponseSerializerTypeHTTP: // Default serializer. Do nothing. break; case YTKResponseSerializerTypeJSON: request.responseObject = [self.jsonResponseSerializer responseObjectForResponse:task.response data:request.responseData error:&amp;serializationError]; request.responseJSONObject = request.responseObject; break; case YTKResponseSerializerTypeXMLParser: request.responseObject = [self.xmlParserResponseSerialzier responseObjectForResponse:task.response data:request.responseData error:&amp;serializationError]; break; &#125; &#125; //4. 判断是否有错误，将错误对象赋值给requestError，改变succeed的布尔值。目的是根据succeed的值来判断到底是进行成功的回调还是失败的回调 if (error) &#123; //如果该方法传入的error不为nil succeed = NO; requestError = error; &#125; else if (serializationError) &#123; //如果序列化失败了 succeed = NO; requestError = serializationError; &#125; else &#123; //即使没有error而且序列化通过，也要验证request是否有效 succeed = [self validateResult:request error:&amp;validationError]; requestError = validationError; &#125; //5. 根据succeed的布尔值来调用相应的处理 if (succeed) &#123; //请求成功的处理 [self requestDidSucceedWithRequest:request]; &#125; else &#123; //请求失败的处理 [self requestDidFailWithRequest:request error:requestError]; &#125; //6. 回调完成的处理 dispatch_async(dispatch_get_main_queue(), ^&#123; //6.1 在字典里移除当前request [self removeRequestFromRecord:request]; //6.2 清除所有block [request clearCompletionBlock]; &#125;);&#125; 简单讲解一下上面的代码： 首先通过task的identifier值从YTKNetworkAgent保存的字典里获取对应的请求。 然后将获得的responseObject进行处理，将处理后获得的responseObject，responseData和responseString赋值给当前的请求实例request。 再根据这些值的获取情况来判断最终回调的成败（改变succeed的值）。 最后根据succeed的值来进行成功和失败的回调。 这里先重点介绍一下是如何判断json的有效性的： 1234567891011121314151617181920212223242526272829303132//YTKNetworkAgent.m//判断code是否符合范围和json的有效性- (BOOL)validateResult:(YTKBaseRequest *)request error:(NSError * _Nullable __autoreleasing *)error &#123; //1. 判断code是否在200~299之间 BOOL result = [request statusCodeValidator]; if (!result) &#123; if (error) &#123; *error = [NSError errorWithDomain:YTKRequestValidationErrorDomain code:YTKRequestValidationErrorInvalidStatusCode userInfo:@&#123;NSLocalizedDescriptionKey:@&quot;Invalid status code&quot;&#125;]; &#125; return result; &#125; //2. result 存在的情况判断json是否有效 id json = [request responseJSONObject]; id validator = [request jsonValidator]; if (json &amp;&amp; validator) &#123; //通过json和validator来判断json是否有效 result = [YTKNetworkUtils validateJSON:json withValidator:validator]; //如果json无效 if (!result) &#123; if (error) &#123; *error = [NSError errorWithDomain:YTKRequestValidationErrorDomain code:YTKRequestValidationErrorInvalidJSONFormat userInfo:@&#123;NSLocalizedDescriptionKey:@&quot;Invalid JSON format&quot;&#125;]; &#125; return result; &#125; &#125; return YES;&#125; 在这里，首先，用statusCodeValidator方法判断响应的code是否在正确的范围: 12345678//YTKBaseReqiest.m- (BOOL)statusCodeValidator &#123; NSInteger statusCode = [self responseStatusCode]; return (statusCode &gt;= 200 &amp;&amp; statusCode &lt;= 299);&#125;- (NSInteger)responseStatusCode &#123; return self.response.statusCode;&#125; 然后再判断json的有效性： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//YTKNetworkUtils.m//判断json的有效性+ (BOOL)validateJSON:(id)json withValidator:(id)jsonValidator &#123; if ([json isKindOfClass:[NSDictionary class]] &amp;&amp; [jsonValidator isKindOfClass:[NSDictionary class]]) &#123; NSDictionary * dict = json; NSDictionary * validator = jsonValidator; BOOL result = YES; NSEnumerator * enumerator = [validator keyEnumerator]; NSString * key; while ((key = [enumerator nextObject]) != nil) &#123; id value = dict[key]; id format = validator[key]; if ([value isKindOfClass:[NSDictionary class]] || [value isKindOfClass:[NSArray class]]) &#123; result = [self validateJSON:value withValidator:format]; if (!result) &#123; break; &#125; &#125; else &#123; if ([value isKindOfClass:format] == NO &amp;&amp; [value isKindOfClass:[NSNull class]] == NO) &#123; result = NO; break; &#125; &#125; &#125; return result; &#125; else if ([json isKindOfClass:[NSArray class]] &amp;&amp; [jsonValidator isKindOfClass:[NSArray class]]) &#123; NSArray * validatorArray = (NSArray *)jsonValidator; if (validatorArray.count &gt; 0) &#123; NSArray * array = json; NSDictionary * validator = jsonValidator[0]; for (id item in array) &#123; BOOL result = [self validateJSON:item withValidator:validator]; if (!result) &#123; return NO; &#125; &#125; &#125; return YES; &#125; else if ([json isKindOfClass:jsonValidator]) &#123; return YES; &#125; else &#123; return NO; &#125;&#125; 注意，YTKNetworkUtils这个类是在YTKNetworkPirvate里面定义的，YTKNetworkPirvate里面有一些工具类的方法，在后面还会遇到。 在验证返回的JSON数据是否有效以后，就可以进行回调了： 123456789101112131415161718192021//YTKNetworkAgent.m- (void)handleRequestResult:(NSURLSessionTask *)task responseObject:(id)responseObject error:(NSError *)error &#123; ... //5. 根据succeed的布尔值来调用相应的处理 if (succeed) &#123; //请求成功的处理 [self requestDidSucceedWithRequest:request]; &#125; else &#123; //请求失败的处理 [self requestDidFailWithRequest:request error:requestError]; &#125; //6. 回调完成的处理 dispatch_async(dispatch_get_main_queue(), ^&#123; //6.1 在字典里移除当前request [self removeRequestFromRecord:request]; //6.2 清除所有block [request clearCompletionBlock]; &#125;); ...&#125; 我们先来分别看一下请求成功的处理和失败的处理： 请求成功的处理： 123456789101112131415161718192021222324252627282930//YTKNetworkAgent.m//请求成功：主要负责将结果写入缓存&amp;回调成功的代理和block- (void)requestDidSucceedWithRequest:(YTKBaseRequest *)request &#123; @autoreleasepool &#123; //写入缓存 [request requestCompletePreprocessor]; &#125; dispatch_async(dispatch_get_main_queue(), ^&#123; //告诉Accessories请求就要停止了 [request toggleAccessoriesWillStopCallBack]; //在真正的回调之前做的处理,用户自定义 [request requestCompleteFilter]; //如果有代理，则调用成功的代理 if (request.delegate != nil) &#123; [request.delegate requestFinished:request]; &#125; //如果传入了成功回调的代码，则调用 if (request.successCompletionBlock) &#123; request.successCompletionBlock(request); &#125; //告诉Accessories请求已经结束了 [request toggleAccessoriesDidStopCallBack]; &#125;);&#125; 我么可以看到，在请求成功以后，第一个做的是写入缓存，我们来看一下requestCompletePreprocessor方法的实现： 12345678910111213141516171819202122232425262728293031323334353637383940//YTKRequest.m- (void)requestCompletePreprocessor &#123; [super requestCompletePreprocessor]; //是否异步将responseData写入缓存（写入缓存的任务放在专门的队列进行） if (self.writeCacheAsynchronously) &#123; dispatch_async(ytkrequest_cache_writing_queue(), ^&#123; //写入缓存文件 [self saveResponseDataToCacheFile:[super responseData]]; &#125;); &#125; else &#123; //写入缓存文件 [self saveResponseDataToCacheFile:[super responseData]]; &#125;&#125;//写入缓存文件- (void)saveResponseDataToCacheFile:(NSData *)data &#123; if ([self cacheTimeInSeconds] &gt; 0 &amp;&amp; ![self isDataFromCache]) &#123; if (data != nil) &#123; @try &#123; // 1. 保存request的responseData到cacheFilePath [data writeToFile:[self cacheFilePath] atomically:YES]; // 2. 保存request的metadata到cacheMetadataFilePath YTKCacheMetadata *metadata = [[YTKCacheMetadata alloc] init]; metadata.version = [self cacheVersion]; metadata.sensitiveDataString = ((NSObject *)[self cacheSensitiveData]).description; metadata.stringEncoding = [YTKNetworkUtils stringEncodingWithRequest:self]; metadata.creationDate = [NSDate date]; metadata.appVersionString = [YTKNetworkUtils appVersionString]; [NSKeyedArchiver archiveRootObject:metadata toFile:[self cacheMetadataFilePath]]; &#125; @catch (NSException *exception) &#123; YTKLog(@&quot;Save cache failed, reason = %@&quot;, exception.reason); &#125; &#125; &#125;&#125; 首先看一下写入缓存操作的执行条件：当cacheTimeInSeconds方法返回大于0并且isDataFromCache为NO的时候会进行写入缓存。 cacheTimeInSeconds方法返回的是缓存保存的时间，它最初定义在YTKBaseRquest里面，默认返回是-1： 1234//YTKBaseRequest.m- (NSInteger)cacheTimeInSeconds &#123; return -1;&#125; 所以说YTKNetwork默认是不进行缓存的，如果用户需要做缓存，则需要在自定义的request类里面返回一个大于0的整数，这个整数的单位是秒。 isDataFromCache属性在上面讲解发送请求部分里的查询缓存的步骤里有介绍。在这里再强调一下：isDataFromCache的默认值是NO。在请求发起之前，查询缓存的时候： 如果发现缓存不可用（或忽略缓存），则立即发送请求，这个时候，isDataFromCache的值不做更改，仍然是NO。 如果发现缓存可用（在不忽略缓存的情况下），就要将isDataFromCache属性设置为YES，说明将不需要发送请求，直接在里获取数据了。 即是说，如果发送了请求，则isDataFromCache一定是NO的，那么在上面这个判断里面，(!isDataFromCache)就一定为YES了。 因此，如果用户设置了缓存保存的时间，在请求返回成功后，就会写入缓存。 我们接着往下看，对于缓存，YTKNetwork保存的是两种缓存：第一种是纯粹的NSData类型的实例。第二种是描述当前NSData实例的元数据YTKCacheMetadata的实例，从它的属性来看，分为这几种： 缓存的版本，默认返回为0，用户可以自定义。 敏感数据，类型为id，默认返回nil，用户可以自定义。 NSString的编码格式，在YTKNetworkPrivate内的YTKNetworkUtils实现。 元数据的创建时间。 app的版本号，在YTKNetworkPrivate内的YTKNetworkUtils实现。 在将元数据的实例的这些属性都被赋值以后，将元数据实例序列化写入磁盘中。保存的路径通过cacheMetadataFilePath方法获取。 现在知道了YTKRequest的缓存内容，我们来看一下这两种缓存的位置： 12345678910111213141516171819202122232425262728293031323334353637383940414243//YTKRequest.m//纯NSData数据缓存的文件名- (NSString *)cacheFileName &#123; NSString *requestUrl = [self requestUrl]; NSString *baseUrl = [YTKNetworkConfig sharedConfig].baseUrl; id argument = [self cacheFileNameFilterForRequestArgument:[self requestArgument]]; NSString *requestInfo = [NSString stringWithFormat:@&quot;Method:%ld Host:%@ Url:%@ Argument:%@&quot;, (long)[self requestMethod], baseUrl, requestUrl, argument]; NSString *cacheFileName = [YTKNetworkUtils md5StringFromString:requestInfo]; return cacheFileName;&#125;//纯NSData数据的缓存位置- (NSString *)cacheFilePath &#123; NSString *cacheFileName = [self cacheFileName]; NSString *path = [self cacheBasePath]; path = [path stringByAppendingPathComponent:cacheFileName]; return path;&#125;//元数据的缓存位置- (NSString *)cacheMetadataFilePath &#123; NSString *cacheMetadataFileName = [NSString stringWithFormat:@&quot;%@.metadata&quot;, [self cacheFileName]]; NSString *path = [self cacheBasePath]; path = [path stringByAppendingPathComponent:cacheMetadataFileName]; return path;&#125;//创建用户保存所有YTKNetwork缓存的文件夹- (NSString *)cacheBasePath &#123; //获取全路径 NSString *pathOfLibrary = [NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES) objectAtIndex:0]; NSString *path = [pathOfLibrary stringByAppendingPathComponent:@&quot;LazyRequestCache&quot;]; // YTKCacheDirPathFilterProtocol定义了用户可以自定义存储位置的代理方法 NSArray&lt;id&lt;YTKCacheDirPathFilterProtocol&gt;&gt; *filters = [[YTKNetworkConfig sharedConfig] cacheDirPathFilters]; if (filters.count &gt; 0) &#123; for (id&lt;YTKCacheDirPathFilterProtocol&gt; f in filters) &#123; path = [f filterCacheDirPath:path withRequest:self]; &#125; &#125; //创建文件夹 [self createDirectoryIfNeeded:path]; return path;&#125; 可以看出，纯NSData数据缓存的文件名包含了请求方法（GET,POST..），baseURL，requestURL，请求参数拼接的字符串再进行md5加密而成。 而元数据的的文件名则在纯NSData数据缓存的文件名后面加上了.metadata后缀。 为了更形象地看到这两种缓存，我将缓存的保存时间设置为200秒之后再请求一次，然后打开文件夹找到了它们： 而且我们也确认了保存所有YTKNetwork缓存的文件夹的名字为LazyRequestCache。 OK，现在我们知道了在请求成功回调后的缓存写入，接下来看一下是如何回调的： 1234567891011121314//YTKNetworkAgent.m- (void)handleRequestResult:(NSURLSessionTask *)task responseObject:(id)responseObject error:(NSError *)error &#123; ... YTKRequest *strongSelf = self; //6. 执行回调 //6.1 请求完成的代理 [strongSelf.delegate requestFinished:strongSelf]; //6.2 请求成功的block if (strongSelf.successCompletionBlock) &#123; strongSelf.successCompletionBlock(strongSelf); &#125; //7. 把成功和失败的block都设置为nil，避免循环引用 [strongSelf clearCompletionBlock];&#125; 我们可以看到,代理的回调是先于block的回调的。而且在block回调结束以后，会立即调用clearCompletionBlock方法将block清空。该方法的实现是在YTKBaseRequest里： 123456//YTKBaseRequest.m- (void)clearCompletionBlock &#123; // 清空请求结束的block，避免循环引用 self.successCompletionBlock = nil; self.failureCompletionBlock = nil;&#125; 现在我们知道了请求成功的处理，那么再来看一下请求失败时的处理： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//YTKNetworkAgent.m//请求失败- (void)requestDidFailWithRequest:(YTKBaseRequest *)request error:(NSError *)error &#123; request.error = error; YTKLog(@&quot;Request %@ failed, status code = %ld, error = %@&quot;, NSStringFromClass([request class]), (long)request.responseStatusCode, error.localizedDescription); // 储存未完成的下载数据 NSData *incompleteDownloadData = error.userInfo[NSURLSessionDownloadTaskResumeData]; if (incompleteDownloadData) &#123; [incompleteDownloadData writeToURL:[self incompleteDownloadTempPathForDownloadPath:request.resumableDownloadPath] atomically:YES]; &#125; // Load response from file and clean up if download task failed. //如果下载任务失败，则取出对应的响应文件并清空 if ([request.responseObject isKindOfClass:[NSURL class]]) &#123; NSURL *url = request.responseObject; //isFileURL：是否是文件，如果是，则可以再isFileURL获取；&amp;&amp;后面是再次确认是否存在改url对应的文件 if (url.isFileURL &amp;&amp; [[NSFileManager defaultManager] fileExistsAtPath:url.path]) &#123; //将url的data和string赋给request request.responseData = [NSData dataWithContentsOfURL:url]; request.responseString = [[NSString alloc] initWithData:request.responseData encoding:[YTKNetworkUtils stringEncodingWithRequest:request]]; [[NSFileManager defaultManager] removeItemAtURL:url error:nil]; &#125; //清空request request.responseObject = nil; &#125; @autoreleasepool &#123; //请求失败的预处理，YTK没有定义，需要用户定义 [request requestFailedPreprocessor]; &#125; dispatch_async(dispatch_get_main_queue(), ^&#123; //告诉Accessories请求就要停止了 [request toggleAccessoriesWillStopCallBack]; //在真正的回调之前做的处理 [request requestFailedFilter]; //如果有代理，就调用代理 if (request.delegate != nil) &#123; [request.delegate requestFailed:request]; &#125; //如果传入了失败回调的block代码，就调用block if (request.failureCompletionBlock) &#123; request.failureCompletionBlock(request); &#125; //告诉Accessories请求已经停止了 [request toggleAccessoriesDidStopCallBack]; &#125;);&#125; 在这个方法里，首先判断了当前任务是否为下载任务，如果是，则储存当前已经下载好的data到resumableDownloadPath里面。而如果下载任务失败，则将其对应的在本地保存的路径上的文件清空。 到这里，我已经把单个请求从配置，发送，响应，回调的步骤都讲解完了。为了帮助大家理解整个过程，这里提供了整个的流程图： 我们说YTKNetworkAgent是请求的发送者，既然有发送，也就会有取消等操作，这就不得不提它的另外两个接口： 12345//YTKNetworkAgent.h/// 取消某个request- (void)cancelRequest:(YTKBaseRequest *)request;/// 取消所有添加的request- (void)cancelAllRequests; 首先我们看下取消某个request这个方法的实现： 1234567891011121314151617181920//YTKNetworkAgent.m/// 取消某个request- (void)cancelRequest:(YTKBaseRequest *)request &#123; NSParameterAssert(request != nil); //获取request的task，并取消 [request.requestTask cancel]; //从字典里移除当前request [self removeRequestFromRecord:request]; //清理所有block [request clearCompletionBlock];&#125;//从字典里移除某request- (void)removeRequestFromRecord:(YTKBaseRequest *)request &#123; //加锁 Lock(); [_requestsRecord removeObjectForKey:@(request.requestTask.taskIdentifier)]; YTKLog(@&quot;Request queue size = %zd&quot;, [_requestsRecord count]); Unlock();&#125; 取消所有在字典里添加的request： 12345678910111213141516//YTKNetworkAgent.m- (void)cancelAllRequests &#123; Lock(); NSArray *allKeys = [_requestsRecord allKeys]; Unlock(); if (allKeys &amp;&amp; allKeys.count &gt; 0) &#123; NSArray *copiedKeys = [allKeys copy]; for (NSNumber *key in copiedKeys) &#123; Lock(); YTKBaseRequest *request = _requestsRecord[key]; Unlock(); //stop每个请求 [request stop]; &#125; &#125;&#125; 这个stop方法是在YTKBaseRequest里面定义的： 123456789101112131415//YTKBaseRequest.m- (void)stop &#123; //告诉Accessories将要回调了 [self toggleAccessoriesWillStopCallBack]; //清空代理 self.delegate = nil; //调用agent的取消某个request的方法 [[YTKNetworkAgent sharedAgent] cancelRequest:self]; //告诉Accessories回调完成了 [self toggleAccessoriesDidStopCallBack];&#125; OK，看到这里，相信你对YTKNetwork单个请求的流程有了比较好的了解了，下面我们来看一下YTKNetwork的高级功能：批量请求和链式请求。 3.3 批量请求和链式请求YTKNetwork支持的批量请求有两种： 批量请求：多个请求几乎同时发起。 链式请求：当前个请求结束后才能发起下一个请求。 其实无论是批量请求，还是链式请求，我们都可以想到很可能是用一个数组将这些请求管理了起来。那么具体是如何实现的呢？ 我们首先来看一下YTKNetwork是如何实现批量请求的。 3.31批量请求YTKNetwork 使用YTKBatchRequest类来发送无序的批量请求，它需要用一个含有YTKRequest子类的数组来初始化，并将这个数组保存起来赋给它的_requestArray实例变量： 1234567891011121314151617181920//YTKBatchRequest.m- (instancetype)initWithRequestArray:(NSArray&lt;YTKRequest *&gt; *)requestArray &#123; self = [super init]; if (self) &#123; //保存为属性 _requestArray = [requestArray copy]; //批量请求完成的数量初始化为0 _finishedCount = 0; //类型检查，所有元素都必须为YTKRequest或的它的子类，否则强制初始化失败 for (YTKRequest * req in _requestArray) &#123; if (![req isKindOfClass:[YTKRequest class]]) &#123; YTKLog(@&quot;Error, request item must be YTKRequest instance.&quot;); return nil; &#125; &#125; &#125; return self;&#125; 初始化以后，我们就可以调用start方法来发起当前YTKBatchRequest实例所管理的所有请求了： 1234567891011121314151617181920212223242526272829303132333435//YTKBatchRequest.m//batch请求开始- (void)startWithCompletionBlockWithSuccess:(void (^)(YTKBatchRequest *batchRequest))success failure:(void (^)(YTKBatchRequest *batchRequest))failure &#123; [self setCompletionBlockWithSuccess:success failure:failure]; [self start];&#125;//设置成功和失败的block- (void)setCompletionBlockWithSuccess:(void (^)(YTKBatchRequest *batchRequest))success failure:(void (^)(YTKBatchRequest *batchRequest))failure &#123; self.successCompletionBlock = success; self.failureCompletionBlock = failure;&#125;- (void)start &#123; //如果batch里第一个请求已经成功结束，则不能再start if (_finishedCount &gt; 0) &#123; YTKLog(@&quot;Error! Batch request has already started.&quot;); return; &#125; //最开始设定失败的request为nil _failedRequest = nil; //使用YTKBatchRequestAgent来管理当前的批量请求 [[YTKBatchRequestAgent sharedAgent] addBatchRequest:self]; [self toggleAccessoriesWillStartCallBack]; //遍历所有request，并开始请求 for (YTKRequest * req in _requestArray) &#123; req.delegate = self; [req clearCompletionBlock]; [req start]; &#125;&#125; 在这里，我们可以看出： 在至少完成了其中一个请求以后，调用当前YTKBatchRequest实例的start方法会立即返回，否则可以无限制start。 YTKBatchRequest的实例是需要在发起请求之前，要被添加在YTKBatchRequestAgent里的数组里： 123456//YTKBatchRequestAgent.m- (void)addBatchRequest:(YTKBatchRequest *)request &#123; @synchronized(self) &#123; [_requestArray addObject:request]; &#125;&#125; 因为是批量发送请求，所以在这里是遍历YTKBatchRequest实例的_requestArray并逐一发送请求。因为已经封装好了单个的请求，所以在这里直接start就好了。 发起请求以后，在每个请求回调的代理方法里，来判断这次批量请求是否成功。 YTKRequest子类成功的回调： 123456789101112131415161718192021222324252627282930313233//YTKBatchRequest.m#pragma mark - Network Request Delegate- (void)requestFinished:(YTKRequest *)request &#123; //某个request成功后，首先让_finishedCount + 1 _finishedCount++; //如果_finishedCount等于_requestArray的个数，则判定当前batch请求成功 if (_finishedCount == _requestArray.count) &#123; //调用即将结束的代理 [self toggleAccessoriesWillStopCallBack]; //调用请求成功的代理 if ([_delegate respondsToSelector:@selector(batchRequestFinished:)]) &#123; [_delegate batchRequestFinished:self]; &#125; //调用批量请求成功的block if (_successCompletionBlock) &#123; _successCompletionBlock(self); &#125; //清空成功和失败的block [self clearCompletionBlock]; //调用请求结束的代理 [self toggleAccessoriesDidStopCallBack]; //从YTKBatchRequestAgent里移除当前的batch [[YTKBatchRequestAgent sharedAgent] removeBatchRequest:self]; &#125;&#125; 我们可以看到，在某个请求的回调成功以后，会让成功计数+1。在+1以后，如果成功计数和当前批量请求数组里元素的个数相等，则判定当前批量请求成功，并进行当前批量请求的成功回调。 接下来我们看一下某个请求失败的处理： YTKReques子类失败的回调： 12345678910111213141516171819202122232425262728293031//YTKBatchRequest.m- (void)requestFailed:(YTKRequest *)request &#123; _failedRequest = request; //调用即将结束的代理 [self toggleAccessoriesWillStopCallBack]; //停止batch里所有的请求 for (YTKRequest *req in _requestArray) &#123; [req stop]; &#125; //调用请求失败的代理 if ([_delegate respondsToSelector:@selector(batchRequestFailed:)]) &#123; [_delegate batchRequestFailed:self]; &#125; //调用请求失败的block if (_failureCompletionBlock) &#123; _failureCompletionBlock(self); &#125; //清空成功和失败的block [self clearCompletionBlock]; //调用请求结束的代理 [self toggleAccessoriesDidStopCallBack]; //从YTKBatchRequestAgent里移除当前的batch [[YTKBatchRequestAgent sharedAgent] removeBatchRequest:self];&#125; 在这里不难看出，当前批量请求里面只要有一个request失败了，则判定当前批量请求失败。而当前批量请求失败的回调（代理和block）会传入这个失败的request的实例。而且这个失败的request会先被赋给_failedRequest这个实例变量里。 总的来说，YTKBatchRequest类用一个数组来保存当前批量请求所要处理的所有request实例。而且用一个成功计数来判定当前批量请求整体是否成功。而当前批量请求的失败则是由这些request实例里面第一个失败的实例导致的：只要有一个request回调失败了，则立即停止其他的所有请求并调用当前批量请求的失败回调。 现在讲完了批量请求的处理，我们接下来看一下链式请求的处理。 3.32链式请求和批量请求类似，处理链式请求的类是YTKChainRequest，并且用YTKChainRequestAgent单例来管理YTKChainRequest的实例。 但是和批量请求不同的是，YTKChainRequest实例的初始化是不需要传入一个含有request的数组的： 12345678910111213141516171819202122//YTKChainRequest.m- (instancetype)init &#123; self = [super init]; if (self) &#123; //下一个请求的index _nextRequestIndex = 0; //保存链式请求的数组 _requestArray = [NSMutableArray array]; //保存回调的数组 _requestCallbackArray = [NSMutableArray array]; //空回调，用来填充用户没有定义的回调block _emptyCallback = ^(YTKChainRequest *chainRequest, YTKBaseRequest *baseRequest) &#123; // do nothing &#125;; &#125; return self;&#125; 但是它提供了添加和删除request的接口： 1234567891011121314//YTKChainRequest.m//在当前chain添加request和callback- (void)addRequest:(YTKBaseRequest *)request callback:(YTKChainCallback)callback &#123; //保存当前请求 [_requestArray addObject:request]; if (callback != nil) &#123; [_requestCallbackArray addObject:callback]; &#125; else &#123; //之所以特意弄一个空的callback，是为了避免在用户没有给当前request的callback传值的情况下，造成request数组和callback数组的不对称 [_requestCallbackArray addObject:_emptyCallback]; &#125;&#125; 注意，在给YTKChainRequest实例添加request实例的同时，还可以传入回调的block。当然也可以不传，但是为了保持request数组和callback数组的对称性（因为回调的时候是需要根据request数组里的index来获取callback数组里对应的callback的），YTKNetwork给我们提供了一个空的block。 我们接着看一下链式请求的发起： 123456789101112131415161718//YTKChainRequest.m- (void)start &#123; //如果第1个请求已经结束，就不再重复start了 if (_nextRequestIndex &gt; 0) &#123; YTKLog(@&quot;Error! Chain request has already started.&quot;); return; &#125; //如果请求队列数组里面还有request，则取出并start if ([_requestArray count] &gt; 0) &#123; [self toggleAccessoriesWillStartCallBack]; //取出当前request并start [self startNextRequest]; //在当前的_requestArray添加当前的chain（YTKChainRequestAgent允许有多个chain） [[YTKChainRequestAgent sharedAgent] addChainRequest:self]; &#125; else &#123; YTKLog(@&quot;Error! Chain request array is empty.&quot;); &#125;&#125; 我们可以看到，YTKChainRequest用_nextRequestIndex来保存下一个请求的index，它的默认值是0。而它的值的累加是在当前请求结束后，发起下面的请求之前进行的。所以说，如果已经完成了请求队列里的第一个请求，就无法在启动当前的请求队列了，会立即返回。 这里startNextRequest方法比较重要：在判断请求队列数组里面还有request的话，就会调用这个方法： 12345678910111213//YTKChainRequest.m- (BOOL)startNextRequest &#123; if (_nextRequestIndex &lt; [_requestArray count]) &#123; YTKBaseRequest *request = _requestArray[_nextRequestIndex]; _nextRequestIndex++; request.delegate = self; [request clearCompletionBlock]; [request start]; return YES; &#125; else &#123; return NO; &#125;&#125; 这个方法有两个作用： 第一个作用是判断是否能进行下一个request（如果index 大于或等于 request数组的count的话就不能在request数组里取出request，因为会造成数组越界） 第二个作用是如果可以进行下一个request，则发起该request。并将_nextRequestIndex+1。 所以和批量请求不同的是，链式请求的请求队列是可以变动的，用户可以无限制地添加请求。只要请求队列里面有请求存在，则YTKChainRequest就会继续发送它们。 现在我们知道了YTKChainRequest的发送，接下来看一下回调部分: 和YTKBatchRequest相同的是，YTKChainRequest也实现了YTKRequest的代理： 12345678910111213141516171819//某个request请求成功的代理的实现//YTKChainRequest.m- (void)requestFinished:(YTKBaseRequest *)request &#123; //1. 取出当前的request和callback，进行回调 NSUInteger currentRequestIndex = _nextRequestIndex - 1; YTKChainCallback callback = _requestCallbackArray[currentRequestIndex]; callback(self, request);//注意：这个回调只是当前request的回调，而不是当前chain全部完成的回调。当前chain的回调在下面 //2. 如果不能再继续请求了，说明当前成功的request已经是chain里最后一个request，也就是说当前chain里所有的回调都成功了，即这个chain请求成功了。 if (![self startNextRequest]) &#123; [self toggleAccessoriesWillStopCallBack]; if ([_delegate respondsToSelector:@selector(chainRequestFinished:)]) &#123; [_delegate chainRequestFinished:self]; [[YTKChainRequestAgent sharedAgent] removeChainRequest:self]; &#125; [self toggleAccessoriesDidStopCallBack]; &#125;&#125; 我们可以看到，在某个request回调成功以后，会根据当前请求的index（_nextRequestIndex-1）来获取其对应的block并调用。接着，再调用startNextRequest方法来判断当前的YTKChainRequest的请求队列里面是否还有其他的请求了： 如果没有了，则调用当前YTKChainRequest的最终成功的回调。 如果还有，则发起接下来的request（按顺序）。 接下来我们再看一下某个request失败的代理的实现： 123456789101112//YTKChainRequest.m//某个reqeust请求失败的代理- (void)requestFailed:(YTKBaseRequest *)request &#123; //如果当前 chain里的某个request失败了，则判定当前chain失败。调用当前chain失败的回调 [self toggleAccessoriesWillStopCallBack]; if ([_delegate respondsToSelector:@selector(chainRequestFailed:failedBaseRequest:)]) &#123; [_delegate chainRequestFailed:self failedBaseRequest:request]; [[YTKChainRequestAgent sharedAgent] removeChainRequest:self]; &#125; [self toggleAccessoriesDidStopCallBack];&#125; 如果当前的request请求失败了，则判定当前链式请求是失败的，则立即调用当前链式请求的失败回调。 现在我们知道了链式请求的请求和回调，再来看一下链式请求的终止： 123456789101112//YTKChainRequest.m//终止当前的chain- (void)stop &#123; //首先调用即将停止的callback [self toggleAccessoriesWillStopCallBack]; //然后stop当前的请求，再清空chain里所有的请求和回掉block [self clearRequest]; //在YTKChainRequestAgent里移除当前的chain [[YTKChainRequestAgent sharedAgent] removeChainRequest:self]; //最后调用已经结束的callback [self toggleAccessoriesDidStopCallBack];&#125; 这个stop方法是可以在外部调用的，所以用户可以随时终止当前链式请求的进行。它首先调用clearReuqest方法，将当前request停止，再将请求队列数组和callback数组清空。 1234567891011//YTKChainRequest.m- (void)clearRequest &#123; //获取当前请求的index NSUInteger currentRequestIndex = _nextRequestIndex - 1; if (currentRequestIndex &lt; [_requestArray count]) &#123; YTKBaseRequest *request = _requestArray[currentRequestIndex]; [request stop]; &#125; [_requestArray removeAllObjects]; [_requestCallbackArray removeAllObjects];&#125; 然后在YTKChainRequestAgent单例里面，将自己移除掉。 4. 最后的话阅读这个框架的源码我的收获是：加深了对命令模式，对Block的理解，知道了一个网络请求都需要什么元素组成，知道了网络缓存该怎么设计，也知道了链式请求怎么设计等等。 我还记得当初听说YTKNetwork能发起链式请求的时候觉得毫无思路的感觉，不过现在应该没什么问题了。 所以说多阅读源码对技术水平的提升是很有帮助的，除了能增多对本语言API的了解，其实更有意义的是它能让你接触到一些新的设计和解决问题的办法，这些都是脱离某个语言本身的东西，也是作为一名程序员所必不可少的东西。 希望这篇文章能对读者们有所帮助~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构&算法 in Swift]]></title>
    <url>%2F2018%2F04%2F08%2FData%20Structure%20%26%20Algorithm%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[写在前面作为该系列的开篇，本文分为一下几个部分： Swift语法基础：讲解一下后续连载中讲到的数据结构和算法所涉及到的Swift语法知识（并不是很全面，也不是很深入，但是在实现数据结构和算法这块应该是够了）。 数据结构：简单介绍数据结构和算法的相关概念，以及用Swift来实现几个简单的数据结构（链表，栈，队列） 算法基础：简单介绍算法的概念，时间复杂度与空间复杂度，递归，作为本文第二部分的背景知识。 排序算法：结合Swift的代码实现来讲解冒泡排序，选择排序，插入排序，归并排序，快速排序。 Swift 语法基础Swift语法基础从以下几点来展开： 循环语句 泛型 guard 函数 集合 循环语句循环条件的开闭区间Swift将循环的开闭区间做了语法上的简化： 闭区间： 12345678for index in 1...5 &#123; print(&quot;index: \(index)&quot;)&#125;// index : 1// index : 2// index : 3// index : 4// index : 5 半开闭区间： 1234567for index in 1..&lt;5 &#123; print(&quot;index: \(index)&quot;)&#125;// index : 1// index : 2// index : 3// index : 4 循环的升序与降序 上面两个例子都是升序的（index从小到大），我们来看一下降序的写法： 1234567for index in (1..&lt;5).reversed() &#123; print(&quot;index: \(index)&quot;)&#125;// index : 4// index : 3// index : 2// index : 1 降序的应用可以在下篇的冒泡排序算法中可以看到。 泛型使用泛型可以定义一些可复用的函数或类型，Swift中的Array和Dictionary都是泛型的集合。 为了体现出泛型的意义，下面举一个例子来说明一下： 实现这样一个功能:将传入该函数的两个参数互换。 整型的交换： 12345func swapTwoInts(_ a: inout Int, _ b: inout Int) &#123; let tmp = a a = b b = tmp&#125; 字符串的交换： 12345func swapTwoStrings(_ a: inout String, _ b: inout String) &#123; let tmp = a a = b b = tmp&#125; 浮点型的交换： 12345func swapTwoDoubles(_ a: inout Double, _ b: inout Double) &#123; let tmp = a a = b b = tmp&#125; 上面这三种情况的实现部分其实都是一样的，但仅仅是因为传入类型的不一致，导致对于不同的类型还要定义一个新的函数。所以如果类型有很多的话，定义的新函数也会很多，这样显然是不够优雅的。 此类问题可以使用泛型来解决： 12345func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T) &#123; let tmp = a a = b b = tmp&#125; 上面函数中的T是泛型的固定写法，可以理解为“所有类型”。这样一来，我们可以传入任何相同的类型来作交换了。 泛型还有其他比较强大的功能，由于在后续的数据结构和算法的讲解里面可能不会涉及到，所以在这里先不赘述了。有兴趣的朋友可以参考官方文档：Swift：Generics guard guard是 swift 2.0推出的新的判断语句的用法。 与if语句相同的是，guard也是基于一个表达式的布尔值去判断一段代码是否该被执行。与if语句不同的是，guard只有在条件不满足的时候才会执行这段代码。你可以把guard近似的看做是Assert，但是你可以优雅的退出而非崩溃 使用guard语法，可以先对每个条件逐一做检查，如果不符合条件判断就退出（或者进行其他操作）。这就会让人容易看出来什么条件会让这个函数退出（或者进行其他某些操作）。 可以用一个例子来分别使用if和guard来实现，体会二者的区别： 使用if-else1234567891011121314151617181920212223242526//money: holding moneny (用户持有的钱数)//price: product price (商品的价格)//capacity: bag capacity (用户用来装商品的袋子容量)//volume: product size (商品的大小)func buying1( money: Int , price: Int , capacity: Int , volume: Int)&#123; if money &gt;= price &#123; if capacity &gt;= volume&#123; print(&quot;Start buying...&quot;) print(&quot;\(money-price) money left after buying.&quot;) print(&quot;\(capacity-volume) capacity left after buying.&quot;) &#125;else&#123; print(&quot;No enough capacity&quot;) &#125; &#125;else&#123; print(&quot;No enough money&quot;) &#125;&#125; 从上面的逻辑可以看出，当同时满足： 1. 用户的钱数&gt;商品价格 2. 用户用来装商品的袋子容量&gt;商品的大小 这两个情况的时候，购买才会进行，其他所有情况都无法引发购买。 对于大多数习惯使用if-else的朋友来说，上面的代码立即起来并没有难度，但是相同的逻辑，我们看一下使用guard之后的效果： 使用guard12345678910111213141516func buying2( money: Int , price: Int , capacity: Int , volume: Int)&#123; guard money &gt;= price else&#123; print(&quot;No enough money&quot;) return &#125; guard capacity &gt;= volume else&#123; print(&quot;No enough capacity&quot;) return &#125; print(&quot;Start buying...&quot;) print(&quot;\(money-price) money after buying.&quot;) print(&quot;\(capacity-volume) capacity left after buying.&quot;)&#125; 从上面的实现可以看出： 使用guard以后，将money &lt; price和capacity &lt; volume 这两个情况首先排除掉并填上了相应的处理代码。 在两个guard下面才是真正正确逻辑后的处理代码。 因此通过两个guard判断的语句，我们知道该函数所处理的正确逻辑是什么，非常清晰。 函数因为后续的数据结构和算法的讲解是离不开函数的使用的，所以在这里简单介绍一下Swift中函数的使用。 无返回值的函数 有返回值的函数 省略函数的外部参数名 值传递和引用传递 无返回值的函数12345func log(message: String) &#123; print(&quot;log: \(message)!&quot;)&#125;log(message: &quot;memory warning&quot;)// output: log: memory warning! 有返回值的函数123456func logString(string: String) -&gt; String &#123; return &quot;log: &quot; + string&#125;let logStr = logString(string: &quot;memory warning!&quot;)print(&quot;\(logStr)&quot;)// output: log: memory warning! 省略函数外部参数名通过在函数形参前面加上_,可以起到在调用时省略外部参数的作用： 12345func logMessage(_ message: String) &#123; print(&quot;log: \(message)!&quot;)&#125;logMessage(&quot;memory warning&quot;)// output: log: memory warning! 再来看一下两个参数的情况： 12345func addInt(_ a : Int ,_ b : Int)&#123; print(&quot;sum is \(a + b)&quot;)&#125;addInt(3, 4)//output : sum is 7 值传递和引用传递Swift中，struct是按值传递，class是按引用传递。数组和字典在Swift里是属于struct，所以需要如果在一个函数里要修改传入的数组，需要做特殊处理： 123456789var originalArr = [2,1,3]func removeLastInArray(_ array: inout [Int])&#123; array.removeLast()&#125;print(&quot;\n============ before removing: \(originalArr)&quot;)//[2, 1, 3]removeLastInArray(&amp;originalArr)print(&quot;============ after removing: \(originalArr)&quot;)//[2, 1] 在这里使用的inout关键字就是将传入的数组改为引用传递了。 集合Swift里的集合类型有：数组，集合，字典，下面来分别讲一下。 这三种类型都只支持泛型，也就是说里面的元素可以是整数，字符串，浮点，对象等等。 数组 Swift’s Array type is bridged to Foundation’s NSArray class. 可变数组与不可变数组1234// immutable arraylet immutableNumbers: [Int] = [1, 3, 5, 4, 4, 1]// mutable arrayvar mutableNumbers : [Int] = [2, 1, 5, 4, 1, 3] Swift中可以用let和var来分别声明可变和不可变数组：数组的添加删除等操作只能作用于可变数组。 数组的遍历12345678910111213141516// iteration 1for value in mutableNumbers &#123; if let index = mutableNumbers.index(of: value) &#123; print(&quot;Index of \(value) is \(index)&quot;) &#125;&#125;// iteration 2mutableNumbers.forEach &#123; value in if let index = mutableNumbers.index(of: value) &#123; print(&quot;Index of \(value) is \(index)&quot;) &#125;&#125;// iteration 3for (index, value) in mutableNumbers.enumerated() &#123; print(&quot;Item \(index + 1): \(value)&quot;)&#125; 数组的操作1234567891011121314mutableNumbers.append(11)// Output: [2, 1, 5, 4, 1, 3, 11]mutableNumbers.insert(42, at: 4)// Output: [2, 1, 5, 4, 42, 1, 3, 11]mutableNumbers.swapAt(0, 1)// Output: [1, 2, 5, 4, 42, 1, 3, 11]mutableNumbers.remove(at: 1)// Output: [2, 5, 4, 42, 1, 3, 11]mutableNumbers.removeFirst()// Output: [5, 4, 42, 1, 3, 11]mutableNumbers.removeLast()// Output: [5, 4, 42, 1, 3]mutableNumbers.removeAll()//[] append函数的作用是在数组的末尾添加元素 swapAt函数的作用是交换在传入的两个index上的元素，该方法在下篇的排序算法中使用得非常频繁。 集合 Swift’s Set type is bridged to Foundation’s NSSet class. 集合的无序性，值的唯一性关于集合与数组的区别，除了数组有序，集合无序以外，数组内部的元素的数值可以不是唯一的；但是集合里元素的数值必须是唯一的，如果有重复的数值会算作是一个： 1234567//value in set is uniquelet onesSet: Set = [1, 1, 1, 1]print(onesSet)// Output: [1]let onesArray: Array = [1, 1, 1, 1]print(onesArray)// Output: [1, 1, 1, 1] 集合的遍历12345678910111213let numbersSet: Set = [1, 2, 3, 4, 5]print(numbersSet)// Output: undefined order, e.g. [5, 2, 3, 1, 4]// iteration 1for value in numbersSet &#123; print(value)&#125;// output is in undefined order// iteration 2numbersSet.forEach &#123; value in print(value)&#125;// output is in undefined order 集合的操作12345678910111213141516171819202122232425262728293031var mutableStringSet: Set = [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]let item = &quot;Two&quot;//containsif mutableStringSet.contains(item) &#123; print(&quot;\(item) found in the set&quot;)&#125; else &#123; print(&quot;\(item) not found in the set&quot;)&#125;//isEmptylet strings = Set&lt;String&gt;()if strings.isEmpty &#123; print(&quot;Set is empty&quot;)&#125;//countlet emptyStrings = Set&lt;String&gt;()if emptyStrings.count == 0 &#123; print(&quot;Set has no elements&quot;)&#125;//insertmutableStringSet.insert(&quot;Four&quot;)//remove 1mutableStringSet.remove(&quot;Three&quot;)//remove 2if let removedElement = mutableStringSet.remove(&quot;Six&quot;) &#123; print(&quot;\(removedElement) was removed from the Set&quot;)&#125; else &#123; print(&quot;Six is not found in the Set&quot;)&#125;//removeAll()mutableStringSet.removeAll()// [] 字典 A dictionary Key type must conform to the Hashable protocol, like a set’s value type. 字典的声明12345678//empty dictionaryvar dayOfWeek = Dictionary&lt;Int, String&gt;()var dayOfWeek2 = [Int: String]()//not empty dictionaryvar dayOfWeek3: [Int: String] = [0: &quot;Sun&quot;, 1: &quot;Mon&quot;, 2: &quot;Tue&quot;]print(dayOfWeek3)//output:[2: &quot;Tue&quot;, 0: &quot;Sun&quot;, 1: &quot;Mon&quot;] 可以看到字典的键值对也是无序的，它与声明时的顺序不一定一致。 字典的遍历123456789101112// iteration 1for (key, value) in dayOfWeek &#123; print(&quot;\(key): \(value)&quot;)&#125;// iteration 2for key in dayOfWeek.keys &#123; print(key)&#125;// iteration 3for value in dayOfWeek.values &#123; print(value)&#125; 字典的操作1234567891011121314151617181920212223242526272829303132333435// find valuedayOfWeek = [0: &quot;Sun&quot;, 1: &quot;Mon&quot;, 2: &quot;Tue&quot;]if let day = dayOfWeek[2] &#123; print(day)&#125;// addValue 1dayOfWeek[3] = &quot;Wed&quot;print(dayOfWeek)// Prints: [2: &quot;Tue&quot;, 0: &quot;Sun&quot;, 1: &quot;Mon&quot;, 3: &quot;Wed&quot;]// updateValue 1dayOfWeek[2] = &quot;Mardi&quot;print(dayOfWeek)// Prints: [2: &quot;Mardi&quot;, 0: &quot;Sun&quot;, 1: &quot;Mon&quot;, 3: &quot;Wed&quot;]// updateValue 2dayOfWeek.updateValue(&quot;Tue&quot;, forKey: 2)print(dayOfWeek)// Prints: [2: &quot;Tue&quot;, 0: &quot;Sun&quot;, 1: &quot;Mon&quot;, 3: &quot;Wed&quot;]// removeValue 1dayOfWeek[1] = nilprint(dayOfWeek)// Prints: [2: &quot;Tue&quot;, 0: &quot;Sun&quot;, 3: &quot;Wed&quot;]// removeValue 2dayOfWeek.removeValue(forKey: 2)print(dayOfWeek)// Prints: [0: &quot;Sun&quot;, 3: &quot;Wed&quot;]// removeAlldayOfWeek.removeAll()print(dayOfWeek)// Output: [:] 可以看到从字典里面删除某个键值对有两个方法： 使用removeValue方法并传入要删除的键值对里的键。 将字典取下标之后将nil赋给它。 数据结构这一部分内容主要让大家对数据结构先有一个基本的认识，因此在概念上不会深入讲解。该部分由以下三点展开： 数据结构的基本概念 抽象数据类型 链表，栈和队列的实现 概念首先我们来看一下数据结构的概念： 数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。 由数据结构这个词汇的本身（数据的结构）以及它的概念可以看出，它的重点在于“结构”和“关系”。所以说，数据是何种数据并不重要，重要的是这些数据是如何联系起来的。 而这些联系，可以从两个维度来展开： 逻辑结构：指数据对象中元素之间的相互关系。 物理结构：指数据的逻辑结构在计算机中的存储形式。 可以看出，逻辑结构是抽象的联系，而物理结构是实际在计算机内存里的具体联系。那么它们自己又细分为哪些结构呢？ 逻辑结构： 集合结构：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。 线性结构：线性结构中的数据元素之间是一对一的关系。 树形结构：数据结构中的元素存在一对多的相互关系。 图形结构：数据结构中的元素存在多对多的相互关系。 物理结构： 顺序存储结构：把数据元素粗放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的（数组）。 链式存储结构：把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。 为了便于记忆，用思维导图总结一下上面所说的： 而通过结合这两个维度中的某个结构，可以定义出来一个实际的数据结构的实现： 顺序存储结构的线性表就是数组：它的内存分布是连续的，元素之间可以通过内存地址来做关联； 链式存储结构的线性表就是链表：它的内存分布可以是不连续的，元素之间通过指针来做关联： 如果每个元素（在链表中称作节点）只持有指向后面节点的指针，那此链表就是单链表。 如果每个元素（在链表中称作节点）持有指向前后节点的两个指针，那此链表就是双链表。 为什么会有链表这么麻烦的东西？像数组这样，所有内存地址都是连续的不是很方便么？既生瑜何生亮呢？ 对于获取元素（节点）这一操作，使用数组这个数据结构确实非常方便：因为所有元素在内存中是连续的，所以只需要知道数组中第一个元素的地址以及要获取元素的index就能算出该index内存的地址，一步到位非常方便。 但是对于向数组中某个index中插入新的元素的操作恐怕就没有这么方便了：恰恰是因为数组中所有元素的内存是连续的，所以如果想在中间插入一个新的元素，那么这个位置后面的所有元素都要后移，显然是非常低效的。如果插在数组尾部还好，如果插在第一位的话成本就太高了。 而如果使用链表，只要把要插入到的index前后节点的指针赋给这个新的节点就可以了，不需要移动原有节点在内存中的位置。 关于链表的这种插入操作会在后面用代码的形式体现出来。 既然有这么多的数据结构，那么有没有一个标准的格式来将这些特定的数据结构（也可以说是数学模型）抽象出来呢？答案是肯定的，它就是我们下一节要讲的抽象数据类型。 抽象数据类型首先来看一下抽象数据类型的概念，摘自《大话数据结构》: 抽象数据类型（Abstract Data Type，ADT）：是指一个数学模型及定义在该模型上的一组操作。 需要注意的是：抽象数据类型的定义仅仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现没有关系。而且，抽象数据类型不仅仅指那些已经定义并实现的数据类型，还尅是计算机编程者自己定义的数据类型。 我们看一下数据类型的标准格式： 123456789101112131415ADT 抽象数据类型名Data 数据元素之间逻辑关系的定义 Operation 操作1 初始条件 操作结果描述 操作2 初始条件 操作结果描述 操作nendADT 其实看上去和面向对象编程里的类的定义相似： 可以把抽象数据类型的Data 和 类的成员变量联系起来。 可以把抽象数据类型的操作和类的函数联系起来。 简单来说，抽象数据类型描述了一个数据模型所使用的数据和数据之间的逻辑关系，以及它可以执行的一些操作。因此，如果知道了一个数学模型的抽象数据类型，那么在真正接触数学模型的实现（代码）之前，就可以对该数学模型能做的事情有一个大致的了解。 下一章笔者会介绍链表，栈和队列这三个数学模型，在讲解每个数学模型的实现之前都会给出它们各自的抽象数据类型，让读者可以先对当前数学模型有个大致的了解。 注意：书本文归纳的所有抽象数据类型是笔者自己根据网上资料和相关书籍而定下来的，所以严格来说它们并不是“最官方”的抽象数据类型。读者也可以参考网上的资料或是相关书籍，结合自己的思考来定义自己对着三个数据模型的抽象数据类型。 链表，栈和队列的实现通过上一节的介绍，我们知道了数据结构的概念以及分类，还知道了不同的数据结构在不同的场景下会发挥不同的优势，我们要根据实际的场景来选择合适的数据结构。 下面就来介绍几种在实际应用中使用的比较多的数学模型： 链表 栈 队列 链表（Linked list）说到链表就不得不提线性表这一数据结构，在介绍链表之前，首先看一下线性表的定义： 线性表：零个或多个数据元素的有限序列。 而根据物理结构的不同，线性表有两种具体的实现方式： 线性表的顺序存储结构：线性表的数据元素是被一段地址连续的存储单存储起来的。 线性表的链式存储结构: 线性表的数据元素是被用一组连续或不连续的存储单元存储起来的，这些元素通过指针来作为逻辑上的连接。 注：上面两个概念是笔者用自己的话总结出来的。 在这里，线性表的顺序存储结构的实现就是我们熟悉的数组；而线性表的链式存储结构的实现就是笔者即将要介绍的链表。 链表的定义相信对于读完上一节的朋友来说，应该对链表有一个比较清晰的认识了。关于链表的定义有很多不同的版本，笔者个人比较喜欢百度百科里的定义： 链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。 而且由于数据元素所持有的指针个数和链接特性可以将链表分为： 单向链表：单向链表的链接方向是单向的，其中每个结点都有指针成员变量指向列表中的下一个结点； 双向链表：双向链表的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点，它的链接方向是双向的。 循环链表：循环链表是另一种形式的链式存贮结构。它的特点是表中最后一个结点的指针域指向头结点，整个链表形成一个环。 笔者从中挑选出双向链表来进行讲解，它的难度适中，而且能够很好地让读者体会出链表的优势。 双向链表的抽象数据类型因为节点是链表的基本组成单元，所以想要实现链表，必须先要介绍链表的组成部分-节点。 节点：123456789ADT 节点(node)Data value:持有的数据Operation init:初始化 previous:指向上一节点的指针 next:指向下一节点的指针 endADT 再来看一下链表的抽象数据类型： 123456789101112131415161718ADT 链表（linked list）Data linked list:持有的线性表Operation init:初始化 count:持有节点总个数 isEmpty:是否为空 first:头节点 last:尾节点 node:传入index返回节点 insert:插入node到指定index insertToHead:插入节点到表头 appendToTail:插入节点到表尾 removeAll:移除所有节点 remove:移除传入的节点 removeAt:移除传入index的节点 endADT 双向链表的实现节点1234567891011121314151617public class LinkedListNode&lt;T&gt; &#123; //value of a node var value: T //pointer to previous node weak var previous: LinkedListNode? //pointer to next node var next: LinkedListNode? //init public init(value: T) &#123; self.value = value &#125;&#125; 再来看一下链表的实现： 因为整个链表的插入，删除等操作比较多，整个链表的定义超过了200行代码，所以为了看着方便一点，在这里来分段说明一下。 首先看一下链表的成员变量: 成员变量12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class LinkedList&lt;T&gt; &#123; public typealias Node = LinkedListNode&lt;T&gt; //if empty public var isEmpty: Bool &#123; return head == nil &#125; //total count of nodes public var count: Int &#123; guard var node = head else &#123; return 0 &#125; var count = 1 while let next = node.next &#123; node = next count += 1 &#125; return count &#125; //pointer to the first node, private private var head: Node? //pointer to the first node, public public var first: Node? &#123; return head &#125; //pointer to the last node public var last: Node? &#123; guard var node = head else &#123; return nil &#125; //until node.next is nil while let next = node.next &#123; node = next &#125; return node &#125; ... &#125; 相信看上面的命名以及注释大家可以对链表的成员变量有个初步的理解，这里面需要说三点： typealias是用来重新为已经存在的类型命名的：这里用Node代替了LinkedListNode&lt;T&gt;（节点类型），降低了不少阅读代码的成本。 在获取count和last的实现，都先判断了head这个指针是否为nil，如果是则判定为空链表，自然也就不存在节点个数和最后的节点对象了。 同样地，也是在获取count和last的实现里，使用了while控制语句来判断node.next节点是否存在：如果存在，则继续+1或者继续往下寻找，直到node.next为nil时才停止。在这里我们可以看到链表的寻址方式：是通过头结点开始，以节点的.next指针来寻找下一个节点的。而且作为链表的尾节点，它的.next指针不指向任何对象，因为它本来就是链表的最后一项。 最下方的…代表即将在下面介绍的一些函数，这些函数都定义在的LinkedList这个class里面。 获取index上node1234567891011121314151617181920//get node of indexpublic func node(atIndex index: Int) -&gt; Node? &#123; if index == 0 &#123; //head node return head! &#125; else &#123; var node = head!.next guard index &lt; count else &#123; return nil; &#125; for _ in 1..&lt;index &#123; // go on finding by .next node = node?.next if node == nil &#123; break &#125; &#125; return node! &#125;&#125; 注意在这里返回的node是可以为nil的，而且在这里可以看出来，链表在寻找特定node的时候，是根据节点的.next指针来一个一个寻找的。这个与顺序存储结构的数组是不同的，在后面我会重点讲解一下这二者的不同。 插入节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//insert node to last indexpublic func appendToTail(value: T) &#123; let newNode = Node(value: value) if let lastNode = last &#123; //update last node: newNode becomes new last node; //the previous last node becomes the second-last node newNode.previous = lastNode lastNode.next = newNode &#125; else &#123; //blank linked list head = newNode &#125;&#125;//insert node to index 0public func insertToHead(value: T) &#123; let newHead = Node(value: value) if head == nil &#123; //blank linked list head = newHead &#125;else &#123; newHead.next = head head?.previous = newHead head = newHead &#125;&#125;//insert node in specific indexpublic func insert(_ node: Node, atIndex index: Int) &#123; if index &lt; 0 &#123; print(&quot;invalid input index&quot;) return &#125; let newNode = node if count == 0 &#123; head = newNode &#125;else &#123; if index == 0 &#123; newNode.next = head head?.previous = newNode head = newNode &#125; else &#123; if index &gt; count &#123; print(&quot;out of range&quot;) return &#125; let prev = self.node(atIndex: index-1) let next = prev?.next newNode.previous = prev newNode.next = prev?.next prev?.next = newNode next?.previous = newNode &#125; &#125;&#125; 链表的插入节点的操作分为三种，按照从上到下的顺序依次是： 在头部插入 在尾部插入 指定index插入 需要注意的是 在前两种插入函数中，需要先判断该链表是否是空的，如果是，则要将链表的该节点赋给链表的head指针。 在第三种插入函数中，还是先判断该链表是否是空的，如果是，则无论index是多少(只要不小于0)，都插在链表的头部。如果不是空的，再判断index是否为0，如果是，则直接插在头部；如果index不为0，则判断index是否大于count，如果是，则无法插入；如果不是，则获取插入位置的前后节点进行重连。 在这里判断链表为空链表后的处理是笔者自己加上去的，笔者在网上的资料里没有看到过。大家不必纠结于这种处理方式，毕竟链表操作的重点在于前后节点的重连。 移除节点 1234567891011121314151617181920212223242526272829303132333435363738394041//removing all nodespublic func removeAll() &#123; head = nil&#125;//remove the last nodepublic func removeLast() -&gt; T? &#123; guard !isEmpty else &#123; return nil &#125; return remove(node: last!)&#125;//remove a node by it&apos;s refrencepublic func remove(node: Node) -&gt; T? &#123; guard head != nil else &#123; print(&quot;linked list is empty&quot;) return nil &#125; let prev = node.previous let next = node.next if let prev = prev &#123; prev.next = next &#125; else &#123; head = next &#125; next?.previous = prev node.previous = nil node.next = nil return node.value&#125;//remove a node by it&apos;s indexpublic func removeAt(_ index: Int) -&gt; T? &#123; guard head != nil else &#123; print(&quot;linked list is empty&quot;) return nil &#125; let node = self.node(atIndex: index) guard node != nil else &#123; return nil &#125; return remove(node: node!)&#125; 如果要移除链表上所有节点，只需要将head指针置空就可以了，因为它是所有节点的“源头”，是链表寻址的第一个节点。 在持有某个节点的指针的时候可以指定链表来移除这个节点（使用remove函数）。在这个函数内部，首先需要将该节点的前后节点对接，然后将该几点的前后指针置空。 当有要移除节点的指针但是知道该节点在链表中的index，可以使用removeAt函数。在这个函数内部，首先根据index来获取对应的node的指针，然后再调用remove函数删除这个node。 打印所有节点123456789101112131415public func printAllNodes()&#123; guard head != nil else &#123; print(&quot;linked list is empty&quot;) return &#125; var node = head print(&quot;\nstart printing all nodes:&quot;) for index in 0..&lt;count &#123; if node == nil &#123; break &#125; print(&quot;[\(index)]\(node!.value)&quot;) node = node!.next &#125;&#125; 该函数只是为了方便调试，为了跟踪链表的状态而定义的，它并不存在于链表的模型里。 为了验证上面这些方法的有效性，我们来实例化一个链表后实际操作一下，读者可以结合注释来看一下每一步对应的结果： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374let list = LinkedList&lt;String&gt;()list.isEmpty // truelist.first // nillist.count // 0list.appendToTail(value: &quot;Swift&quot;)list.isEmpty // falselist.first!.value // &quot;Swift&quot;list.last!.value // &quot;Swift&quot;list.count //1list.appendToTail(value:&quot;is&quot;)list.first!.value // &quot;Swift&quot;list.last!.value // &quot;is&quot;list.count // 2list.appendToTail(value:&quot;great&quot;)list.first!.value // &quot;Swift&quot;list.last!.value // &quot;great&quot;list.count // 3list.printAllNodes()//[0]Swift//[1]is//[2]Greatlist.node(atIndex: 0)?.value // Swiftlist.node(atIndex: 1)?.value // islist.node(atIndex: 2)?.value // greatlist.node(atIndex: 3)?.value // nillist.insert(LinkedListNode.init(value: &quot;language&quot;), atIndex: 1)list.printAllNodes()//[0]Swift//[1]language//[2]is//[3]greatlist.remove(node: list.first!)list.printAllNodes()//[0]language//[1]is//[2]greatlist.removeAt(1)list.printAllNodes()//[0]language//[1]greatlist.removeLast()list.printAllNodes()//[0]languagelist.insertToHead(value: &quot;study&quot;)list.count // 2list.printAllNodes()//[0]study//[1]languagelist.removeAll()list.printAllNodes()//linked list is emptylist.insert(LinkedListNode.init(value: &quot;new&quot;), atIndex: 3)list.printAllNodes()//[0]newlist.insert(LinkedListNode.init(value: &quot;new&quot;), atIndex: 3) //out of rangelist.printAllNodes()//[0]newlist.insert(LinkedListNode.init(value: &quot;new&quot;), atIndex: 1)list.printAllNodes()//[0]new//[1]new 栈（Stack）栈的讲解从 栈的定义 栈的抽象数据类型 栈的实现 三个部分来展开。 栈的定义首先来看一下栈的定义： 栈是限定仅在表的尾部进行插入和删除操作的线性表。 从定义中可以看出，我们知道我们只能在栈的一端来操作栈： 允许插入和删除的一端成为栈顶 另一端成为栈底 用一张图来看一下栈的操作： 图源：《维基百科：Stack (abstract data type)》 从上图可以看出，最先压入栈里面的只能最后访问，也就是说，栈遵循后进先出（Last In First Out, LIFO）的原则。 栈的抽象数据类型123456789101112ADT 栈（Stack）Data linked list:持有的线性表Operation init:初始化 count:栈的元素个数 isEmpty:是否为空 push:入栈 pop:出栈 top:返回顶部元素 endADT 上面的operation可能不全，但是涵盖了栈的一些最基本的操作。那么基于这个抽象数据类型，我们来看一下如何使用Swift来实现它。 栈的实现笔者将数组（顺序存储）作为栈的线性表的实现，同时支持泛型。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public struct Stack&lt;T&gt; &#123; //array fileprivate var stackArray = [T]() //count public var count: Int &#123; return stackArray.count &#125; //is empty ? public var isEmpty: Bool &#123; return stackArray.isEmpty &#125; //top element public var top: T? &#123; if isEmpty&#123; return nil &#125;else &#123; return stackArray.last &#125; &#125; //push operation public mutating func push(_ element: T) &#123; stackArray.append(element) &#125; //pop operation public mutating func pop() -&gt; T? &#123; if isEmpty&#123; print(&quot;stack is empty&quot;) return nil &#125;else &#123; return stackArray.removeLast() &#125; &#125; //print all public mutating func printAllElements() &#123; guard count &gt; 0 else &#123; print(&quot;stack is empty&quot;) return &#125; print(&quot;\nprint all stack elemets:&quot;) for (index, value) in stackArray.enumerated() &#123; print(&quot;[\(index)]\(value)&quot;) &#125; &#125;&#125; fileprivate：是Swift3.0新增的访问控制，表示在定义的声明文件里可访问。它代替了过去意义上的private。而有了fileprivate以后，新的private则代表了真正的私有：在这个类或结构体的外部无法访问。 这里printAllElements方法也不属于抽象数据类型里的方法，也是为了方便调试，可以打印出所有的数据元素。 我们来实例化上面定义的栈实际操作一下： 123456789101112131415161718192021222324var stack = Stack.init(stackArray: [])stack.printAllElements() //stack is emptystack.isEmpty //truestack.push(2)stack.printAllElements()//[0]2stack.isEmpty //falsestack.top //2stack.push(3)stack.printAllElements()//[0]2//[1]3stack.isEmpty //falsestack.top //3stack.pop()stack.printAllElements()//[0]2stack.isEmpty //falsestack.top //2stack.pop()stack.printAllElements() //stack is emptystack.top //nilstack.isEmpty //truestack.pop() //stack is empty 队列（Queue）队列的讲解从 队列的定义 队列的抽象数据类型 队列的实现 三个部分来展开。 队列的定义 图源：《维基百科：FIFO (computing and electronics)》 队列的抽象数据类型123456789101112ADT 队列（Queue）Data linked list:持有的线性表Operation init:初始化 count:栈的元素个数 isEmpty:是否为空 front:获取队列头元素 enqueue:插入到队尾 dequeue:删除队列头元素并返回 endADT 和上面的栈的实现一致，队列的实现也使用数组来实现队列内部的线性表。 队列的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public struct Queue&lt;T&gt; &#123; //array fileprivate var queueArray = [T]() //count public var count: Int &#123; return queueArray.count &#125; //is empty? public var isEmpty: Bool &#123; return queueArray.isEmpty &#125; //front element public var front: T? &#123; if isEmpty &#123; print(&quot;queue is empty&quot;) return nil &#125; else &#123; return queueArray.first &#125; &#125; //add element public mutating func enqueue(_ element: T) &#123; queueArray.append(element) &#125; //remove element public mutating func dequeue() -&gt; T? &#123; if isEmpty &#123; print(&quot;queue is empty&quot;) return nil &#125; else &#123; return queueArray.removeFirst() &#125; &#125; //print all public mutating func printAllElements() &#123; guard count &gt; 0 else &#123; print(&quot;queue is empty&quot;) return &#125; print(&quot;\nprint all queue elemets:&quot;) for (index, value) in queueArray.enumerated() &#123; print(&quot;[\(index)]\(value)&quot;) &#125; &#125; &#125; 我们初始化一个队列后实际操作一下： 1234567891011121314151617181920212223242526272829303132333435363738var queue = Queue.init(queueArray: [])queue.printAllElements()//queue is emptyqueue.isEmpty //truequeue.count //0queue.enqueue(2)queue.printAllElements()queue.isEmpty //false//[0]2queue.enqueue(3)queue.printAllElements()//[0]2//[1]3queue.enqueue(4)queue.printAllElements()//[0]2//[1]3//[2]4queue.front //2queue.dequeue()queue.printAllElements()//[0]3//[1]4queue.front //3queue.dequeue()queue.printAllElements()//[0]4queue.front //4queue.dequeue()queue.printAllElements() //queue is emptyqueue.front //return nil, and print : queue is emptyqueue.isEmpty //truequeue.count//0 算法算法基础 该部分是给那些对算法以及相关知识不了解的读者准备的，如果已经对算法的相关知识有所了解，可以略过该部分，直接看本文的第二部分：排序算法。 关于该部分的讨论不属于本文介绍的重点，因此没有过多非常专业的论述，只是让那些对算法不了解的读者可以对算法先有一个基本的认识，为阅读和理解本文的第二部分做好准备。 算法的概念算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。 摘自《大话数据结构》 简单说来，算法就是“一个问题的解法”。对于相同一个问题，可能会有多种不同的解法。这些解法虽然可以得到相同的结果，但是每个算法的执行所需要的时间和空间资源却可以是千差万别的。 以消耗的时间的角度为出发点，我们看一下对于同一个问题，两种不同的解法的效率会相差多大： 现在让我们解决这个问题：计算从1到100数字的总和。 把比较容易想到的下面两种方法作为比较： 1到100循环遍历逐步相加 等差数列求和 用Swift函数来分别实现一下： 12345678910111213141516func sumOpration1(_ n:Int) -&gt; Int&#123; var sum = 0 for i in 1 ... n &#123; sum += i &#125; return sum&#125;sumOpration1(100)//5050func sumOpration2(_ n:Int) -&gt; Int&#123; return (1 + n) * n/2&#125;sumOpration2(100)//5050 上面的代码中，sumOpration1使用的是循环遍历的方式；sumOpration2使用的是等差数列求和的公式。 虽然两个函数都能得到正确的结果，但是不难看出两个函数实现的效率是有区别的: 遍历求和所需要的时间是依赖于传入函数的n的大小的，而等差数列求和的方法所需要的时间对传入的n的大小是完全不依赖的。 在遍历求和中，如果传入的n值是100，则需要遍历100次并相加才能得到结果，那么如果传入的n值是一百万呢？ 而在等差数列求和的函数中，无论n值有多大，只需要一个公式就可以解决。 我们对此可以以小见大：世上千千万万种问题（算法题）可能也有类似的情况：相同的问题，相同的结果，但是执行效率缺差之千里。那么有没有什么方法可以度量某种算法的执行效率以方便人们去选择或是衡量算法之间的差异呢？ 答案是肯定的。 下面笔者就向大家介绍算法所消耗资源的两个维度：时间复杂度和空间复杂度。 时间复杂度与空间复杂度时间复杂度算法的时间复杂度是指算法需要消耗的时间资源。一般来说，计算机算法是问题规模!n的函数f(n)，算法的时间复杂度也因此记做： 常见的时间复杂度有：常数阶O(1)，对数阶O(log n），线性阶 O(n)，线性对数阶O(nlog n)，平方阶O(n^{2})，立方阶O(n^{3})，!k次方阶O(n^{k})，指数阶 O(2^{n})}。随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。 拿其中几个复杂度做对比： 从上图中我们可以看到，平方阶O(n^{2})随着n值的增大，其复杂度近乎直线飙升；而线性阶 O(n)随着n的增大，复杂度是线性增长的；我们还可以看到常数阶 O(1)随着n增大，其复杂度是不变的。 参考上一节的求和问题，我们可以看出来遍历求和的算法复杂度是线性阶O(n)：随着求和的最大数值的大小而线性增长；而等差数列求和算法的复杂度为常数阶 O(1)其算法复杂度与输入n值的大小无关。 读者可以试着想一个算法的复杂度与输入值n的平方成正比的算法。 在这里笔者举一个例子：求一个数组中某两个元素和为某个值的元素index的算法。数组为[0,2,1,3,6]，和为8： 12345678910111213141516171819202122232425func findTwoSum(_ array: [Int], target: Int) -&gt; (Int, Int)? &#123; guard array.count &gt; 1 else &#123; return nil &#125; for i in 0..&lt;array.count &#123; let left = array[i] for j in (i + 1)..&lt;array.count &#123; let right = array[j] if left + right == target &#123; return (i, j) &#125; &#125; &#125; return nil&#125;let array = [0,2,1,3,6]if let indexes = findTwoSum(array, target: 8) &#123; print(indexes) //1， 4&#125; else &#123; print(&quot;No pairs are found&quot;)&#125; 上面的算法准确地计算出了两个元素的index为1和4。因为使用了两层的遍历，所以这里算法的复杂度是平方阶O(n^{2}。关于算法复杂度的详细推倒方法，可以参考网上和算法相关书籍的资料。 而其实，不需要遍历两层，只需要遍历一层即可：在遍历的时候，我么知道当前元素的值a，那么只要其余元素里面有值等于（target - a）的值即可。所以这次算法的复杂度就是线性阶O(n)了。 同样地，上面两种算法虽然可以达到相同的效果，但是当n非常大的时候，二者的计算效率就会相差更大：n = 1000的时候，二者得到结果所需要的时间可能会差好几百倍。可以说平方阶O(n^{2})复杂度的算法在数据量很大的时候是无法让人接受的。 空间复杂度算法的空间复杂度是指算法需要消耗的空间资源。其计算和表示方法与时间复杂度类似，一般都用复杂度的渐近性来表示。同时间复杂度相比，空间复杂度的分析要简单得多。而且控件复杂度不属于本文讨论的重点，因此在这里不展开介绍了。 递归在算法的实现中，遍历与递归是经常出现的两种操作。 对于遍历，无非就是使用一个for循环来遍历集合里的元素，相信大家已经非常熟悉了。但是对于递归操作就可能比较陌生。而且由于本文第二部分讲解算法的是时候有两个算法（也是比较重要）的算法使用了递归操作，所以为了能帮助大家理解这两个算法，笔者觉得有必要将递归单独拿出来讲解。 先看一下递归的概念。 递归的概念递归的概念是：在数学与计算机科学中，是指在函数的定义中使用函数自身的方法摘自维基百科 摘自维基百科 通过使用递归，可以把一个大型复杂的问题逐层转化为一个与原问题相似的规模较小的问题来求解。因此如果使用递归，可以达到使用少量的代码就可描述出解题过程所需的多次重复计算的目的，减少了程序的代码量 。 下面用一个例子来具体感受一下递归操作： 大家应该都比较熟悉阶乘的算法：3！= 3 2 1 ； 4！= 4 3 2 * 1 不难看出，在这里反复执行了一个逐渐-1和相乘的操作，如果可以使用某段代码达到重复调用的效果就很方便了，在这里就可以使用递归： 1234func factorial(_ n:Int) -&gt; Int&#123; return n &lt; 2 ? 1: n * factorial(n-1)&#125;factorial(3) //6 在上面的代码里，factorial函数调用了它自己，并且在n&lt;2的时候返回了1；否则继续调用自己。 从代码本身其实不难理解函数调用的方式，但是这个6究竟是怎么算出来的呢？这就涉及到递归的实现原理了。 递归的实现原理递归的调用实际上是通过调用栈（callback stack）来实现的，笔者用一张图从factorial(3)开始调用到最后得出6这个顺序之间发生的事情画了出来： 由上图可以看出，整个递归的过程和栈的入栈出栈的操作非常类似：橘黄色背景的圆角矩形代表了栈顶元素，也就是正在执行的操作，而灰色背景的圆角矩形则代表了其余的元素，它们的顺序就是当初被调用的顺序，而且在内容上保持了当时被调用时执行的代码。 现在笔者按照时间顺序从左到右来说明一下整个调用的过程： 最开始传入3之后，3满足了n&gt;=2的条件，继续调用自己：3 * factorial(2) ，入栈。 传入2之后，2满足了n&gt;=2的条件，继续调用自己：2 * factorial(1) ，入栈。 传入1之后，1满足了n&lt;2的条件，停止调用自己，返回了1，出栈。 此时的栈顶元素为2 factorial(1) ，而刚刚factorial(1)返回了1，所以现在这里变成了2 1 = 2，出栈。 同样地，此时栈顶元素为3 factorial(2)里的 factorial(2)返回了2，所以现在这里变成了3 2 = 6，出栈。 最后，factorial(3)返回了6，出栈，递归结束。 按照笔者个人的理解：整个递归的过程可以大致理解为：在使递归继续的条件为false之前，持续递归调用，以栈的形式保存调用上下文（临时变量，函数等）。一旦这个条件变为true，则立即按照出栈的顺序（入栈顺序的逆序）来返回值，逐个传递，最终传递到最开始调用的那一层返回最终结果。 再简单点，递归中的“递”就是入栈，传递调用信息；“归”就是出栈，输出返回值。 而这个分界线就是递归的终止条件。很显然，这个终止条件在整个递归过程中起着举足轻重的作用。试想一下，如果这个条件永远不会改变，那么就会一直入栈，就会发生栈溢出的情况。 使用递归时需要注意的问题基于上面递归的例子，我们将递归终止条件去掉： 1234func factorialInfinite(_ n:Int) -&gt; Int&#123; return n * factorialInfinite(n-1)&#125;factorialInfinite(3) 这段代码如果放在playground里，经过一小段时间（几秒钟或更多）后，会报一个运行时错误。也可以在return语句上面写一个print函数打印一些字符串，接着就会看到不停的打印，直到运行时错误，栈溢出。 所以说在今后写关于递归的代码的时候，一定要注意递归的终止条件是否合理，因为即使条件存在也不一定就是合理的条件。我们看一下下面这个例子： 1234567func sumOperation( _ n:Int) -&gt; Int &#123; if n == 0 &#123; return 0 &#125; return n + sumOperation(n - 1)&#125;sumOperation(2) //3 上面的代码跟阶乘类似，也是和小于当前参数的值相加，如果传入2，那么知道 n=0时就开始出栈， 2 + 1 + 0 = 3。看似没什么问题，但是如果一开始传入 - 1 呢？结果就是不停的入栈，直到栈溢出。因为 n == 0 这个条件在传入 - 1 的时候是无法终止入栈的，因为 - 1 之后的 -1 操作都是非0的。 所以说这个条件就不是合理的，一个比较合理的条件是 n &lt; = 0。 1234567func sumOperation( _ n:Int) -&gt; Int &#123; if n &lt;= 0 &#123; return 0 &#125; return n + sumOperation(n - 1)&#125;sumOperation(-1) //0 相信到这里，读者应该对递归的使用，调用过程以及注意事项有个基本的认识了。 那么到这里，关于算法的基本介绍已经讲完了，下面正式开始讲解排序算法。 排序算法讲解算法之前，我们先来看一下几个常见的排序算法的对比： 排序算法 平均情况下 最好情况 最坏情况 稳定性 空间复杂度 冒泡 O(n^2) O(n） O(n^2) 稳定 1 选择排序 O(n^2) O(n^2) O(n^2) 不稳定 1 插入排序 O(n^2) O(n） O(n^2) 稳定 1 希尔排序 O(nlogn) 依赖步长 依赖步长 稳定 1 堆排序 O(nlogn) O(nlogn) O(nlogn) 稳定 1 归并排序 O(nlogn) O(nlogn) O(nlogn) 稳定 O(n） 快速排序 O(nlogn) O(nlogn) O(n^2) 不稳定 O(logn) 最好情况和最坏情况以及稳定性的概念不在本文的讨论范围之内，有兴趣的读者可以查阅相关资料。 现在只看平均情况下的性能： 冒泡排序，选择排序，插入排序的时间复杂度为平方阶O(n^{2}) 希尔排序，堆排序，归并排序，快速排序的时间复杂度为线性对数阶O(nlog n) 本篇要给大家介绍的是冒泡排序，选择排序，插入排序，归并排序和快速排序。 希尔排序是基于插入排序，理解了插入排序以后，理解希尔排序会很容易，故在本文不做介绍。堆排序涉及到一个全新的数据结构：堆，所以笔者将堆这个数据结构和堆排序放在下一篇来做介绍。 排序初探在讲排序算法之前，我们先看一种最简单的排序算法（也是性能最低的，也是最好理解的），在这里先称之为“交换排序”。 注意，这个名称是笔者自己起的，在互联网和相关技术书籍上面没有对该算法起名。 算法讲解用两个循环来嵌套遍历： 外层遍历数组从0到末尾的元素，索引为i. 里层遍历数组从i+1至数组末尾的元素，索引为j。 当i上的元素比j上的元素大的时候，交换i和j的元素，目的是保持index为i的元素是最小的。 我们用一个例子看一下是怎么做交换的： 给定一个初始数组：array = [4, 1, 2, 5, 0] i = 0 时： array[0] &gt; array[1] : 交换4和1：[1, 4, 2, 5, 0]，内层的j继续遍历，j++。 array[0] &gt; array[4] : 交换0和1：[0, 4, 2, 5, 1]，i = 0的外层循环结束，i++。 i = 1时： array[1] &gt; array[2] : 交换2和4：[0, 2, 4, 5, 1]，内层的j继续遍历，j++。 array[1] &gt; array[4] : 交换1和2：[0, 1, 4, 5, 2]，i = 1的外层循环结束，i++。 i = 2 时： array[2] &gt; array[4] : 交换2和4：[0, 1, 2, 5, 4]，i = 2的外层循环结束，i++。 i = 3 时： array[3] &gt; array[4] : 交换5和4：[0, 1, 2, 4, 5]，i = 3的外层循环结束，i++。 i = 4 时： 不符合内循环的边界条件，不进行内循环，排序结束。 那么用代码如何实现呢？ 代码实现1234567891011121314151617func switchSort(_ array: inout [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; for i in 0 ..&lt; array.count &#123; for j in i + 1 ..&lt; array.count &#123; if array[i] &gt; array[j] &#123; array.swapAt(i, j) print(&quot;\(array)&quot;) &#125; &#125; &#125; return array &#125; 这里面swapAt函数是使用了Swift内置的数组内部交换两个index的函数，在后面会经常用到。 为了用代码验证上面所讲解的交换过程，可以在swapAt函数下面将交换元素后的数组打印出来： 1234567891011121314151617181920var originalArray = [4,1,2,5,0]print(&quot;original array:\n\(originalArray)\n&quot;)func switchSort(_ array: inout [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; for i in 0 ..&lt; array.count &#123; for j in i + 1 ..&lt; array.count &#123; if array[i] &gt; array[j] &#123; array.swapAt(i, j) print(&quot;\(array)&quot;) &#125; &#125; &#125; return array &#125;switchSort(&amp;originalArray) 打印结果： 12345678910original array:[4, 1, 2, 5, 0]switch sort...[1, 4, 2, 5, 0][0, 4, 2, 5, 1][0, 2, 4, 5, 1][0, 1, 4, 5, 2][0, 1, 2, 5, 4][0, 1, 2, 4, 5] 验证后我们可以看到，结果和上面分析的结果是一样的。 各位读者也可以自己设置原数组，然后在运行代码之前按照自己的理解，把每一次交换的结果写出来，接着和运行算法之后进行对比。该方法对算法的理解很有帮助，推荐大家使用~ 请务必理解好上面的逻辑，可以通过动笔写结果的方式来帮助理解和巩固，有助于对下面讲解的排序算法的理解。 大家看上面的交换过程（排序过程）有没有什么问题？相信细致的读者已经看出来了：在原数组中，1和2都是比较靠前的位置，但是经过中间的排序以后，被放在了数组后方，然后再次又交换回来。这显然是比较低效的，给人的感觉像是做了无用功。 那么有没有什么方法可以优化一下交换的过程，让交换后的结果与元素最终在数组的位置基本保持一致呢？ 答案是肯定的，这就引出了笔者要第一个正式介绍的排序算法冒泡排序： 冒泡排序算法讲解与上面讲的交换排序类似的是，冒泡排序也是用两层的循环来实现的；但与其不同的是： 循环的边界条件：冒泡排序的外层是[0,array.count-1);内层是[0,array.count-1-i)。可以看到内层的范围是不断缩小的，而且范围的前端不变，后端在向前移。 交换排序比较的是内外层索引的元素（array[i] 和 array[j]）,但是冒泡排序比较的是两个相邻的内层索引的元素：array[j]和array[j+1]。 笔者用和上面交换排序使用的同一个数组来演示下元素是如何交换的： 初始数组：array = [4, 1, 2, 5, 0] i = 0 时： array[0] &gt; array[1] : 交换4和1：[1, 4, 2, 5, 0]，内层的j继续遍历，j++。 array[1] &gt; array[2] : 交换4和2：[1, 2, 4, 5, 0]，内层的j继续遍历，j++。 array[2] &lt; array[3] : 不交换，内层的j继续遍历，j++。 array[3] &gt; array[4] : 交换5和0：[1, 2, 4, 0, 5]，i = 0的外层循环结束，i++。 i = 1时： array[2] &gt; array[3] : 交换2和4：[1, 2, 0, 4, 5]，内层的j继续遍历，j++。 array[3] &lt; array[4] : 不交换，i = 1的外层循环结束，i++。 i = 2 时： array[1] &gt; array[2] : 交换2和0：[1, 0, 2, 4, 5]，内层的j继续遍历，j++，直到退出i=2的外层循环，i++。 i = 3 时： array[0] &gt; array[1] : 交换1和0：[0, 1, 2, 4, 5]，内层的j继续遍历，j++，直到退出i=3的外层循环，i++。 i = 4 时：不符合外层循环的边界条件，不进行外层循环，排序结束。 代码实现我们来看一下冒泡排序的代码： 1234567891011121314func bubbleSort(_ array: inout [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; for i in 0 ..&lt; array.count - 1 &#123; for j in 0 ..&lt; array.count - 1 - i &#123; if array[j] &gt; array[j+1] &#123; array.swapAt(j, j+1) &#125; &#125; &#125; return array&#125; 从上面的代码我们可以清楚地看到循环遍历的边界条件和交换时机。同样地，我们添加上log，将冒泡排序每次交换后的数组打印出来（为了进行对比，笔者将交换排序的log也打印了出来）： 123456789101112131415161718original array:[4, 1, 2, 5, 0]switch sort...[1, 4, 2, 5, 0][0, 4, 2, 5, 1][0, 2, 4, 5, 1][0, 1, 4, 5, 2][0, 1, 2, 5, 4][0, 1, 2, 4, 5]bubble sort...[1, 4, 2, 5, 0][1, 2, 4, 5, 0][1, 2, 4, 0, 5][1, 2, 0, 4, 5][1, 0, 2, 4, 5][0, 1, 2, 4, 5] 从上面两组打印可以看出，冒泡排序算法解决了交换排序算法的不足： 原来就处于靠前位置的1，2两个元素，在排序的过程中一直是靠前的。 原来处于末尾的0元素，在冒泡排序的过程中一点一点地向前移动，最终到了应该处于的位置。 现在我们知道冒泡排序是好于交换排序的，而且它的做法是相邻元素的两两比较：如果是逆序（左大右小）的话就做交换。 那么如果在排序过程中，数组已经变成有序的了，那么再进行两两比较就很不划算了。 为了证实上面这个排序算法的局限性，我们用新的测试用例来看一下： 1var originalArray = [2,1,3,4,5] 而且这次我们不仅仅在交换以后打log，也记录一下作比较的次数： 12345678910111213141516171819func bubbleSort(_ array: inout [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; var compareCount = 0 for i in 0 ..&lt; array.count - 1 &#123; for j in 0 ..&lt; array.count - 1 - i &#123; compareCount += 1 print(&quot;No.\(compareCount) compare \(array[j]) and \(array[j+1])&quot;) if array[j] &gt; array[j+1] &#123; array.swapAt(j, j+1) //keeping index of j is the smaller one print(&quot;after swap: \(array)&quot;) &#125; &#125; &#125; return array&#125; 打印结果： 123456789101112131415original array:[2, 1, 3, 4, 5]bubble sort...No.1 compare 2 and 1after swap: [1, 2, 3, 4, 5] //already sorted, but keep comparingNo.2 compare 2 and 3No.3 compare 3 and 4No.4 compare 4 and 5No.5 compare 1 and 2No.6 compare 2 and 3No.7 compare 3 and 4No.8 compare 1 and 2No.9 compare 2 and 3No.10 compare 1 and 2 从打印的结果可以看出，其实在第一次交换过之后，数组已经是有序的了，但是该算法还是继续在比较，做了很多无用功，能不能有个办法可以让这种两两比较在已知有序的情况下提前结束呢？答案是肯定的。 提前结束这个操作很容易，我们只需要跳出最外层的循环就好了。关键是这个时机：我们需要让算法自己知道什么时候数组已经是有序的了。 是否已经想到了呢？就是在一次内循环过后，如果没有发生元素交换，就说明数组已经是有序的，不需要再次缩小内循环的范围继续比较了。所以我们需要在外部设置一个布尔值的变量来标记“该数组是否有序”： 我们将这个算法称为：advanced bubble sort 12345678910111213141516171819202122232425func bubbleSortAdvanced(_ array: inout [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; for i in 0 ..&lt; array.count - 1 &#123; //bool switch var swapped = false for j in 0 ..&lt; array.count - i - 1 &#123; if array[j] &gt; array [j+1] &#123; array.swapAt(j, j+1) swapped = true; &#125; &#125; //if there is no swapping in inner loop, it means the the part looped is already sorted, //so it&apos;s time to break if (swapped == false)&#123; break &#125; &#125; return array &#125; 从上面的代码可以看出，在第一个冒泡排序的算法之内，只添加了一个swapped这个布尔值，默认为false： 如果在当前内循环里面没有发生过元素交换，则说明当前内循环范围的元素都是有序的；那么就说明后续的内循环范围的元素也是有序的（因为内循环每次迭代后都会缩小），就可以跳出循环了。 反之，如果在当前内循环里发生过元素交换，则说明当前内循环很可能是无序的（也可能是有序的，但是有序性需要在下一个内循环中验证，所以还是不能提前退出，还需要进行一次内循环）。 为了验证上面这个改进冒泡排序是否能解决最初给出的冒泡排序的问题，我们添加上对比次数的log： 1234567891011121314151617181920212223242526original array:[2, 1, 3, 4, 5]bubble sort...No.1 compare 2 and 1after swap: [1, 2, 3, 4, 5]No.2 compare 2 and 3No.3 compare 3 and 4No.4 compare 4 and 5No.5 compare 1 and 2No.6 compare 2 and 3No.7 compare 3 and 4No.8 compare 1 and 2No.9 compare 2 and 3No.10 compare 1 and 2bubble sort time duration : 1.96msadvanced bubble sort...No.1 compare 2 and 1after swap: [1, 2, 3, 4, 5]No.2 compare 2 and 3No.3 compare 3 and 4No.4 compare 4 and 5No.5 compare 1 and 2No.6 compare 2 and 3No.7 compare 3 and 4 我们可以看到，在使用改进的冒泡排序后，对比的次数少了3次。之所以没有立即返回，是因为即使在交换完变成有序数组以后，也无法在当前内循环判断出是有序的。需要在下次内循环才能验证出来。 因为数组的元素数量比较小，所以可能对这个改进所达到的效果体会得不是很明显。现在我们增加一下数组元素的个数，并用记录比较总和的方式来看一下二者的区别： 12345678original array:[2, 1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]bubble sort...total compare count： 91advanced bubble sort...total compare count： 25 从比较结果可以看出，这两种算法在该测试样本下的差距是比较大的，而且随着元素个数的增多这个差距会越来越大（因为做了更多没有意义的比较）。 虽然这种测试样本比较极端，但是在某种意义上还是优化了最初的冒泡排序算法。一般在网上的冒泡排序算法应该都能看到这个优化版的。 现在我们知道这个优化版的冒泡排序算法可以在知道当前数组已经有序的时候提前结束，但是毕竟不断的交换还是比较耗费性能的，有没有什么方法可以只移动一次就能做好当前元素的排序呢？答案又是肯定的，这就引出了笔者即将介绍的选择排序算法。 选择排序算法讲解选择排序也是两层循环： 外层循环的边界是[0,array.count-1)，index为i。 内层循环的边界是[i+1,array.count)，index为j。可以看到内层的范围也是不断缩小的，而且范围的前端一直后移，后端保持不变。 具体做法是： 在外层循环的开始，将i作为最小值index（很可能不是该数组的最小值）。 在内层循环里面找到当前内层循环范围内的最小值，并与已经记录的最小值作比较： 如果与当前记录的最小值index不同，则替换 如果与当前记录的最小值index相同，则不替换 我们还是用手写迭代的方式看一下选择排序的机制，使用的数组和上面交换排序和冒泡排序（非优化版）的数组一致：[4, 1, 2, 5, 0] i = 0 时： 记录当前的最小值的index为0，当前最小值为4。 内层循环开始，找到[1,5)之间的最小值为0，0的index为4，与当前最小值的index0不同，所以二者要做交换。交换后的数组：[0, 1, 2, 5, 4]。当前内层循环结束，i++。 i = 1 时： 记录当前的最小值的index为1，当前最小值为1。 内层循环开始，找到[2,5)之间的最小值为1，与当前记录的最小值index相同。也就是说后面没有比1还要小的了，不做交换。当前内层循环结束，i++。 i = 2 时： 记录当前的最小值的index为2，当前最小值为2。 内层循环开始，找到[3,5)之间的最小值为2，与当前记录的最小值index相同。也就是说后面没有比1还要小的了，不做交换。当前内层循环结束，i++。 i = 3 时： 记录当前的最小值的index为3，当前最小值为2。 内层循环开始，找到[4,5)之间的最小值为4，4的index为4，与当前记录的最小值index3不同，所以二者要做交换。交换后的数组：[0, 1, 2, 4, 5]。当前内层循环结束，i++。 i = 4 时：不符合外层循环的边界条件，不进行外层循环，排序结束。 我们可以看到，同样的初始序列，使用选择排序只进行了2次交换，因为它知道需要替换的最小值是什么，做了很少没意义的交换。 代码实现我们用代码来实现一下上面选择排序的算法： 12345678910111213141516171819202122func selectionSort(_ array: inout [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; for i in 0 ..&lt; array.count - 1&#123; var min = i for j in i + 1 ..&lt; array.count &#123; if array[j] &lt; array[min] &#123; min = j &#125; &#125; //if min has changed, it means there is value smaller than array[min] //if min has not changed, it means there is no value smallter than array[min] if i != min &#123; array.swapAt(i, min) &#125; &#125; return array&#125; 从上面的代码可以看到，在这里使用了min这个变量记录了当前外层循环所需要被比较的index值，如果当前外层循环的内层循环内部找到了比这个最小值还小的值，就替换他们。 下面我们使用log来看一下此时选择排序作替换的次数： 123456789101112original array:[4, 1, 2, 5, 0]advanced bubble sort...after swap: [1, 4, 2, 5, 0]after swap: [1, 2, 4, 5, 0]after swap: [1, 2, 4, 0, 5]after swap: [1, 2, 0, 4, 5]after swap: [1, 0, 2, 4, 5]after swap: [0, 1, 2, 4, 5]selection sort...after swap: [0, 1, 2, 5, 4]after swap: [0, 1, 2, 4, 5] 从上面的log可以看出二者的对比应该比较明显了。 为了进一步验证选择排序的性能，笔者在网上找到了两个工具： 计算程序运行时间的类：executionTimeInterval.swift 生成各种类型随机数的Array的分类：Array+Extension.swift 首先看executionTimeInterval.swift的实现： 123456789101112131415161718//time intervalpublic func executionTimeInterval(block: () -&gt; ()) -&gt; CFTimeInterval &#123; let start = CACurrentMediaTime() block(); let end = CACurrentMediaTime() return end - start&#125;//formatted timepublic extension CFTimeInterval &#123; public var formattedTime: String &#123; return self &gt;= 1000 ? String(Int(self)) + &quot;s&quot; : self &gt;= 1 ? String(format: &quot;%.3gs&quot;, self) : self &gt;= 1e-3 ? String(format: &quot;%.3gms&quot;, self * 1e3) : self &gt;= 1e-6 ? String(format: &quot;%.3gµs&quot;, self * 1e6) : self &lt; 1e-9 ? &quot;0s&quot; : String(format: &quot;%.3gns&quot;, self * 1e9) &#125;&#125; 第一个函数以block的形式传入需要测试运行时间的函数，返回了函数运行的时间。 第二个函数是CFTimeInterval的分类，将秒数添加了单位：毫秒级的以毫秒显示，微秒级的以微秒显示，大于1秒的以秒单位显示。 使用方法是：将两个swift文件拖进playground里面的Sources文件夹里，并点击二者后，进入playground内部： 12345var selectionSortedArray = [Int]()var time4 = executionTimeInterval&#123; selectionSortedArray = selectionSort(&amp;originalArray4) //要测试的函数&#125;print(&quot;selection sort time duration : \(time4.formattedTime)&quot;) //打印出时间 再来看一下Array+Extension.swift类： 先介绍其中的一个方法，生成随机数组： 12345678910111213import Foundationextension Array &#123; static public func randomArray(size: Int, maxValue: UInt) -&gt; [Int] &#123; var result = [Int](repeating: 0, count:size) for i in 0 ..&lt; size &#123; result[i] = Int(arc4random_uniform(UInt32(maxValue))) &#125; return result &#125;&#125; 这个方法只需要传入数组的大小以及最大值就可以生成一个不超过这个最大值的随机数组。 比如我们要生成一个数组长度为10，最大值为100的数组： 12var originalArray = Array&lt;Int&gt;.randomArray(size: inputSize, maxValue:100)//originalArray:[87, 56, 54, 20, 86, 33, 41, 9, 88, 55] 那么现在有了上面两个工具，我们就可以按照我们自己的意愿来生成测试用例数组，并且打印出所用算法的执行时间。我们现在生成一个数组长度为10，最大值为100的数组，然后分别用优化的冒泡排序和选择排序来看一下二者的性能： 12345678original array:[1, 4, 80, 83, 92, 63, 83, 23, 9, 85]advanced bubble sort...advanced bubble sort result: [1, 4, 9, 23, 63, 80, 83, 83, 85, 92] time duration : 8.53msselection sort...selection sort result: [1, 4, 9, 23, 63, 80, 83, 83, 85, 92] time duration : 3.4ms 我们现在让数组长度更长一点:一个长度为100，最大值为200： 12345advanced bubble sort...advanced bubble sort sorted elemets: 100 time duration : 6.27sselection sort...selection sort sorted elemets: 100 time duration : 414ms 可以看到，二者的差别大概在12倍左右。这个差别已经很大了，如果说用选择排序需要1天的话，冒泡排序需要12天。 现在我们学习了选择排序，知道了它是通过减少交换次数来提高排序算法的性能的。 但是关于排序，除了交换操作以外，对比操作也是需要时间的：选择排序通过内层循环的不断对比才得到了当前内层循环的最小值，然后进行后续的判断和操作。 那么有什么办法可以减少对比的次数呢？猜对了，答案又是肯定的。这就引出了笔者下面要说的算法：插入排序算法。 插入排序算法讲解插入排序的基本思想是：从数组中拿出一个元素（通常就是第一个元素）以后，再从数组中按顺序拿出其他元素。如果拿出来的这个元素比这个元素小，就放在这个元素左侧；反之，则放在右侧。整体上看来有点和玩儿扑克牌的时候将刚拿好的牌来做排序差不多。 选择排序也是两层循环：外层循环的边界是[1,array.count)，index为i。内层循环开始的时候初始index j = i，然后使用一个while循环，循环条件是j&gt;0 &amp;&amp; array[j] &lt; array[j - 1],循环内侧是交换j-1和j的元素，并使得j-1。可以简单理解为如果当前的元素比前一个元素小，则调换位置；反之进行下一个外层循环。 下面我们还是用手写迭代的方式看一下插入排序的机制，使用的数组和上面选择排序的数组一致：[4, 1, 2, 5, 0] i = 1 时： j = 1：array[1] &lt; array[0]， 交换4和1：[1, 4, 2, 5, 0]，j-1之后不符合内层循环条件，退出内层循环，i+1。 i = 2 时： j = 2，array[3] &lt; array[2]，交换4和2：[1, 2, 4, 5, 0]，j向左移动，array[2] &gt; array[1]，不符合内层循环条件，退出内层循环，i+1。 i = 3 时： j = 3，array[3] &gt; array[2]，不符合内层循环条件，退出内层循环，i+1。 i = 4 时： j = 4，array[4] &lt; array[3]，交换5和0：[1, 2, 4, 0, 5]，j -1。 j = 3，array[3] &lt; array[2]，交换4和0：[1, 2, 0, 4, 5]，j -1。 j = 2，array[2] &lt; array[1]，交换4和0：[1, 0, 2, 4, 5]，j -1。 j = 1，array[1] &lt; array[0]，交换1和0：[0, 1, 2, 4, 5]，j -1 = 0，不符合内层循环条件，退出内层循环，i+1 = 5，不符合外层循环条件，排序终止。 从上面的描述可以看出，和选择排序相比，插入排序的内层循环是可以提前推出的，其条件就是array[j] &gt;= array[j - 1],也就是说，当前index为j的元素只要比前面的元素大，那么该内层循环就立即退出，不需要再排序了，因为该算法从一开始就是小的放前面，大的放后面。 代码实现下面我们通过代码来看一下如何实现插入排序算法: 1234567891011121314func insertionSort(_ array: inout [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; for i in 1..&lt;array.count &#123; var j = i while j &gt; 0 &amp;&amp; array[j] &lt; array[j - 1] &#123; array.swapAt(j - 1, j) j -= 1 &#125; &#125; return array&#125; 从上面的代码可以看出插入排序内层循环的条件：j &gt; 0 &amp;&amp; array[j] &lt; array[j - 1]。只要当前元素比前面的元素小，就会一直交换下去；反之，当大于等于前面的元素，就会立即跳出循环。 之前笔者有提到相对于选择排序，说插入排序可以减少元素之间对比的次数，下面我们通过打印对比次数来对比一下两种算法： 使用元素个数为50，最大值为50的随机数组： 1234567selection sort...compare times:1225selection sort time duration : 178msinsertion sort...compare times:519insertion sort time duration : 676ms 我们可以看到，使用选择排序的比较次数比插入排序的比较次数多了2倍。但是遗憾的是整体的性能选择排序要高于插入排序。 也就是说虽然插入排序的比较次数少了，但是交换的次数却比选择排序要多，所以性能上有时可能不如选择排序。 注意，这不与笔者之前的意思相矛盾，笔者只是说在减少比较次数上插入排序是优于选择排序的，但没有说插入排序整体上优于选择排序。 那么有何种特性的数组可以让排序算法有其用武之地呢？ 从上面使用插入排序来排序[4, 1, 2, 5, 0]这个数组的时候，我们可以看到，因为0这个元素已经在末尾了，所以在j=4的时候我们费了好大劲才把它移到前面去。 那么将这个情况作为一个极端，我们可以这样想：如果这个数组里的元素里的index大致于最终顺序差不多的情况是不是就不用做这么多的搬移了？。这句话听起来像是理所当然的话，但是有一种数组属于“基本有序”的数组，这种数组也是无需的，但是它在整体上是有序的，比如： [2,1,3,6,4,5,9,7,8] 用笔者的话就叫做整体有序，部分无序。 我们可以简单用这个数组来分别进行选择排序和插入排序做个比较： 1234567selection sort...compare times:36selection sort time duration : 4.7msinsertion sort...compare times:5insertion sort time duration : 3.2ms 我们可以看到插入排序在基本有序的测试用例下表现更好。为了让差距更明显，笔者在Array+Extension.swift文件里增加了一个生成基本有序随机数组的方法： 12345678910111213141516static public func nearlySortedArray(size: Int, gap:Int) -&gt; [Int] &#123; var result = [Int](repeating: 0, count:size) for i in 0 ..&lt; size &#123; result[i] = i &#125; let count : Int = size / gap var arr = [Int]() for i in 0 ..&lt; count &#123; arr.append(i*gap) &#125; for j in 0 ..&lt; arr.count &#123; let swapIndex = arr[j] result.swapAt(swapIndex,swapIndex+1) &#125; return result&#125; 该函数需要传入数组的长度以及需要打乱顺序的index的跨度，它的实现是这样子的： 首先生成一个完全有序的序列。 将数组长度除以跨度来得出需要交换的index的个数count。 根据这个count可以得出需要交换的index，把这些index放在一个新的arr里面 便利这个arr来取出index，将之前生成好的w安全有序的数组的index于index+1做交换。 举个例子，如果我们生成一个数组长度为12，跨度为3的基本有序的数组，就可以这么调用： 12var originalArray = Array&lt;Int&gt;.nearlySortedArray(size: 12, gap: 3)//[1, 0, 2, 4, 3, 5, 7, 6, 8, 10, 9, 11] 跨度为3，说明有12/3 = 4 - 1 = 3 个元素需要调换位置，序号分别为0，3，6，9。所以序号为0，1；3，4；6，7；9，10的元素被调换了位置，可以看到调换后的数组还是基本有序的。 现在我们可以用一个比较大的数组来验证了： 1var originalArray = Array&lt;Int&gt;.nearlySortedArray(size: 100, gap: 10) 结果为： 1234567selection sort...compare times:4950selection sort time duration : 422msinsertion sort...compare times:10insertion sort time duration : 56.4ms 我们可以看到差距是非常明显的，插入排序的性能是选择排序的性能的近乎10倍 归并排序算法讲解归并排序使用了算法思想里的分治思想（divide conquer）。顾名思义，就是将一个大问题，分成类似的小问题来逐个攻破。在归并排序的算法实现上，首先逐步将要排序的数组等分成最小的组成部分（通常是1各元素），然后再反过来逐步合并。 用一张图来体会一下归并算法的实现过程： 上图面的虚线箭头代表拆分的过程；实线代表合并的过程。仔细看可以发现，拆分和归并的操作都是重复进行的，在这里面我们可以使用递归来操作。 首先看一下归并的操作： 归并的操作就是把两个数组（在这里这两个数组的元素个数通常是一致的）合并成一个完全有序数组。 归并操作的实现步骤是： 新建一个空数组，该数组用于存放合并后的有序数组。 两个传入的数组从index 0 开始两两比较，较小的元素放在新建的空数组中，index + 1; 较大的元素不作操作，index 不变，然后继续两两比较。知道index移到末尾为止。 个别情况当两个数组长度不一致的情况下需要将数组里剩余的元素放在新建的数组中。 代码实现我们来看一下归并排序算法的代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445func _merge(leftPile: [Int], rightPile: [Int]) -&gt; [Int] &#123; var leftIndex = 0 //left pile index, start from 0 var rightIndex = 0 //right pile index, start from 0 var sortedPile = [Int]() //sorted pile, empty in the first place while leftIndex &lt; leftPile.count &amp;&amp; rightIndex &lt; rightPile.count &#123; //append the smaller value into sortedPile if leftPile[leftIndex] &lt; rightPile[rightIndex] &#123; sortedPile.append(leftPile[leftIndex]) leftIndex += 1 &#125; else if leftPile[leftIndex] &gt; rightPile[rightIndex] &#123; sortedPile.append(rightPile[rightIndex]) rightIndex += 1 &#125; else &#123; //same value, append both of them and move the corresponding index sortedPile.append(leftPile[leftIndex]) leftIndex += 1 sortedPile.append(rightPile[rightIndex]) rightIndex += 1 &#125; &#125; //left pile is not empty while leftIndex &lt; leftPile.count &#123; sortedPile.append(leftPile[leftIndex]) leftIndex += 1 &#125; //right pile is not empty while rightIndex &lt; rightPile.count &#123; sortedPile.append(rightPile[rightIndex]) rightIndex += 1 &#125; return sortedPile&#125; 因为该函数是归并排序函数内部调用的函数，所以在函数名称的前面添加了下划线。仅仅是为了区分，并不是必须的。 从上面代码可以看出合并的实现逻辑： 新建空数组，初始化两个传入数组的index为0 两两比较两个数组index上的值，较小的放在新建数组里面并且index+1。 最后检查是否有剩余元素，如果有则添加到新建数组里面。 理解了合并的算法，下面我们看一下拆分的算法。拆分算法使用了递归： 123456789func mergeSort(_ array: [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; let middleIndex = array.count / 2 let leftArray = mergeSort(Array(array[0..&lt;middleIndex])) // recursively split left part of original array let rightArray = mergeSort(Array(array[middleIndex..&lt;array.count])) // recursively split right part of original array return _merge(leftPile: leftArray, rightPile: rightArray) // merge left part and right part&#125; 我们可以看到mergeSort调用了自身，它的递归终止条件是!(array.count &gt;1)，也就是说当数组元素个数 = 1的时候就会返回，会触发调用栈的出栈。 从这个递归函数的实现可以看到它的作用是不断以中心店拆分传入的数组。根据他的递归终止条件，当数组元素 &gt; 1的时候，拆分会继续进行。而下面的合并函数只有在递归终止，开始出栈的时候才开始真正执行。也就是说在拆分结束后才开始进行合并，这样符合了上面笔者介绍的归并算法的实现过程。 上段文字需要反复体会。 为了更形象体现出归并排序的实现过程，可以在合并函数(_merge)内部添加log来验证上面的说法： 123456789func _merge(leftPile: [Int], rightPile: [Int]) -&gt; [Int] &#123; print(&quot;\nmerge left pile:\(leftPile) | right pile:\(rightPile)&quot;) ... print(&quot;sorted pile：\(sortedPile)&quot;) return sortedPile&#125; 而且为了方便和上图作比较，初始数组可以取图中的[3, 5, 9, 2, 7, 4, 8, 0]。运行一下看看效果： 12345678910111213141516171819202122232425original array:[3, 5, 9, 2, 7, 4, 8, 0]merge sort...merge left pile:[3] | right pile:[5]sorted pile：[3, 5]merge left pile:[9] | right pile:[2]sorted pile：[2, 9]merge left pile:[3, 5] | right pile:[2, 9]sorted pile：[2, 3, 5, 9]merge left pile:[7] | right pile:[4]sorted pile：[4, 7]merge left pile:[8] | right pile:[0]sorted pile：[0, 8]merge left pile:[4, 7] | right pile:[0, 8]sorted pile：[0, 4, 7, 8]merge left pile:[2, 3, 5, 9] | right pile:[0, 4, 7, 8]sorted pile：[0, 2, 3, 4, 5, 7, 8, 9] 我们可以看到，拆分归并的操作是先处理原数组的左侧部分，然后处理原数组的右侧部分。这是为什么呢？ 我们来看下最初函数是怎么调用的： 最开始我们调用函数： 123456789func mergeSort(_ array: [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; let middleIndex = array.count / 2 let leftArray = mergeSort(Array(array[0..&lt;middleIndex])) //1 let rightArray = mergeSort(Array(array[middleIndex..&lt;array.count])) //2 return _merge(leftPile: leftArray, rightPile: rightArray) //3&#125; 在//1这一行开始了递归，这个时候数组是原数组，元素个数是8，而调用mergeSort时原数组被拆分了一半，是4。而4&gt;1，不满足递归终止的条件，继续递归，直到符合了终止条件（[3]）,递归开始返回。以为此时最初被拆分的是数组的左半部分，所以左半部分的拆分会逐步合并，最终得到了[2,3,5,9]。 同理，再回到了最初被拆分的数组的右半部分（上面代码段中的//2），也是和左测一样的拆分和归并，得到了右侧部分的归并结果：[0,4,7,8]。 而此时的递归调用栈只有一个mergeSort函数了，mergeSort会进行最终的合并（上面代码段中的//3），调用_merge函数，得到了最终的结果：[0, 2, 3, 4, 5, 7, 8, 9]。 关于归并排序的性能：由于使用了分治和递归并且利用了一些其他的内存空间，所以其性能是高于上述介绍的所有排序的，不过前提是初始元素量不小的情况下。 我们可以将选择排序和归并排序做个比较：初始数组为长度500，最大值为500的随机数组： 12345selection sort...selection sort time duration : 12.7smerge sort...merge sort time duration : 5.21s 可以看到归并排序的算法是优与选择排序的。 现在我们知道归并排序使用了分治思想而且使用了递归，能够高效地将数组排序。其实还有一个也是用分治思想和递归，但是却比归并排序还要优秀的算法 - 快速排序算法。 快速排序快速排序算法被称之为20世纪十大算法之一，也是各大公司面试比较喜欢考察的算法。 算法讲解快速排序的基本思想是：通过一趟排序将带排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。 上述文字摘自《大话数据结构》 它的实现步骤为： 从数列中挑出一个元素（挑选的算法可以是随机，也可以作其他的优化），称为”基准”（pivot）。 重新对数组进行排序：所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面，相同的放两边。 递归地进行分区操作，继续把小于基准值元素的子数列和大于基准值元素的子数列排序。 从上面的描述可以看出，分区操作是快速排序中的核心算法。下面笔者结合实例来描述一下分区操作的过程。 首先拿到初始的数组：[5,4,9,1,3,6,7,8,2] 选择5作为pivot。 从剩下部分的两端开始：左侧1的标记为low，最右侧2的标记为high。 先看j：2 &lt; 5 , 交换5和2，j不变 ：[2,4,9,1,3,6,7,8,5]； 再看i：2 &lt; 5 , i ++ ；4 &lt; 5, i++；9 &gt; 5，交换 9 和 5，i不变[2,4,5,1,3,6,7,8,9]。 代码实现使用Swift的filter函数因为在Swift中有一个数组的filter函数可以找出数组中符合某范围的一些数值，所以笔者先介绍一个会用该函数的简单的快速排序的实现： 12345678910func quickSort0&lt;T: Comparable&gt;(_ array: [T]) -&gt; [T] &#123; guard array.count &gt; 1 else &#123; return array &#125; let pivot = array[array.count/2] let less = array.filter &#123; $0 &lt; pivot &#125; let greater = array.filter &#123; $0 &gt; pivot &#125; return quickSort0(less) + quickSort0(greater)&#125; 不难看出这里面使用了递归：选中pivot以后，将数组分成了两个部分，最后将它们合并在一起。虽然这里面使用了Swift里面内置的函数来找出符合这两个个部分的元素，但是读者可以通过这个例子更好地理解快速排序的实现方式。 使用取index = 0 的partition函数除了使用swift内置的filter函数，当然我们也可以自己实现分区的功能，通常使用的是自定义的partition函数。 12345678910111213141516171819func _partition(_ array: inout [Int], low: Int, high: Int) -&gt; Int&#123; var low = low var high = high let pivotValue = array[low] while low &lt; high &#123; while low &lt; high &amp;&amp; array[high] &gt;= pivotValue &#123; high -= 1 &#125; array[low] = array[high] while low &lt; high &amp;&amp; array[low] &lt;= pivotValue &#123; low += 1 &#125; array[high] = array[low] &#125; array[low] = pivotValue return low&#125; 从代码实现可以看出，最初在这里选择的pivotValue是当前数组的第一个元素。 然后从数组的最右侧的index逐渐向左侧移动，如果值大于pivotValue，那么index-1；否则直接将high与low位置上的元素调换；同样左侧的index也是类似的操作。 该函数执行的最终效果就是将最初的array按照选定的pivotValue前后划分。 那么_partition如何使用呢？ 1234567891011func quickSort1(_ array: inout [Int], low: Int, high: Int)&#123; guard array.count &gt; 1 else &#123; return &#125; if low &lt; high &#123; let pivotIndex = _partition(&amp;array, low: low, high: high) quickSort1(&amp;array, low: low, high: pivotIndex - 1) quickSort1(&amp;array, low: pivotIndex + 1, high: high) &#125; &#125; 外层调用的quickSort1是一个递归函数，不断地进行分区操作，最终得到排好序的结果。 我们将上面实现的归并排序，使用swift内置函数的快速排序，以及自定义partition函数的快速排序的性能作对比： 123456merge sort...merge sort time duration : 4.85squick sort...quick sort0 time duration : 984ms //swift filter functionquick sort1 time duration : 2.64s //custom partition 上面的测试用例是选择随机数组的，我们看一下测试用例为元素个数一致的基本有序的数组试一下： 123456merge sort...merge sort time duration : 4.88squick sort...quick sort0 time duration : 921msquick sort1 time duration : 11.3s 虽然元素个数一致，但是性能却差了很多，是为什么呢？因为我们在分区的时候，pivot的index强制为第一个。那么如果这个第一个元素的值本来就非常小，那么就会造成分区不均的情况（前重后轻），而且由于是迭代操作，每次分区都会造成分区不均，导致性能直线下降。所以有一个相对合理的方案就是在选取pivot的index的时候随机选取。 使用随机选择pivotValue的partition函数实现方法肯简单，只需在分区函数里将pivotValue的index随机生成即可： 12345678910func _partitionRandom(_ array: inout [Int], low: Int, high: Int) -&gt; Int&#123; let x = UInt32(low) let y = UInt32(high) let pivotIndex = Int(arc4random() % (y - x)) + Int(x) let pivotValue = array[pivotIndex] ...&#125; 现在用一个数组长度和上面的测试用例一致的基本有序的数组来测试一下随机选取pivotValue的算法： 1234567merge sort...merge sort time duration : 4.73squick sort...quick sort0 time duration : 866msquick sort1 time duration : 15.1s //fixed pivote indexquick sort2 time duration : 4.28s //random pivote index 我们可以看到当随机抽取pivot的index的时候，其运行速度速度是上面方案的3倍。 现在我们知道了3种快速排序的实现，都是根据pivotValue将原数组一分为二。但是如果数组中有大量的重复的元素，而且pivotValue很有可能落在这些元素里，那么显然上面这些算法对于这些可能出现多次于pivotValue重复的情况没有单独做处理。而为了很好解决存在与pivot值相等的元素很多的数组的排序，使用三路排序算法会比较有效果。 三路快速排序三路快速排序将大于，等于，小于pivotValue的元素都区分开，我们看一下具体的实现。先看一下partition函数的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950func swap(_ arr: inout [Int], _ j: Int, _ k: Int) &#123; guard j != k else &#123; return; &#125; let temp = arr[j] arr[j] = arr[k] arr[k] = temp&#125;func quickSort3W(_ array: inout [Int], low: Int, high: Int) &#123; if high &lt;= low &#123; return &#125; var lt = low // arr[low+1...lt] &lt; v var gt = high + 1 // arr[gt...high] &gt; v var i = low + 1 // arr[lt+1...i) == v let pivoteIndex = low let pivoteValue = array[pivoteIndex] while i &lt; gt &#123; if array[i] &lt; pivoteValue &#123; swap(&amp;array, i, lt + 1) i += 1 lt += 1 &#125;else if pivoteValue &lt; array[i]&#123; swap(&amp;array, i, gt - 1) gt -= 1 &#125;else &#123; i += 1 &#125; &#125; swap(&amp;array, low, lt) quickSort3W(&amp;array, low: low, high: lt - 1) quickSort3W(&amp;array, low: gt, high: high) &#125;func quickSort3(_ array: inout [Int] )&#123; quickSort3W(&amp;array, low: 0, high: array.count - 1) &#125; 主要看quickSort3W方法，这里将数组分成了三个区间，分别是大于，等于，小于pivote的值，对有大量重复元素的数组做了比较好的处理。 我们生成一个元素数量为500，最大值为5的随机数组看一下这些快速排序算法的性能： 123quick sort1 time duration : 6.19s //fixed pivote indexquick sort2 time duration : 8.1s //random pivote indexquick sort3 time duration : 4.81s //quick sort 3 way 可以看到三路快速排序（quick sort 3 way）在处理大量重复元素的数组的表现最好。 对于三路快速排序，我们也可以使用Swift内置的filter函数来实现: 1234567891011func quicksort4(_ array: [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; let pivot = array[array.count/2] let less = array.filter &#123; $0 &lt; pivot &#125; let equal = array.filter &#123; $0 == pivot &#125; let greater = array.filter &#123; $0 &gt; pivot &#125; return quicksort4(less) + equal + quicksort4(greater)&#125; 以上，介绍完了快速排序在Swift中的5中实现方式。 最后的话总结本文讲解了Swift的基础语法、算法的一些基本概念以及结合了Swift代码的实现讲解了冒泡排序，选择排序，插入排序，归并排序，快速排序。相信认真阅读本文的读者能对这些算法有进一步的了解。 关于算法学习的思考关于算法的学习，笔者有一些思考想分享出来，也有可能有不对的地方，但笔者觉得有必要在这里说出来，希望可以引发读者的思考： 上图的Question是指问题；Mind是指想法，或者解决问题的思路；Code是指代码实现。 在阅读资料或书籍的算法学习过程，往往是按照图中1，2，3这些实线的路径进行的： 路径1：给出一个既定的问题后，马上给出解题策略 路径2：给出一个既定的问题后，马上给出算法实现 路径3：给出一个算法实现后，马上告诉你这些实现代码的意思 这些路径在算法的学习中虽然也是必不可少的，但是很容易给人一个错觉，这个错觉就是“我已经学会了这个算法了”。但是，仅仅是通过这些路径，对于真正理解算法，和今后对算法的应用还是远远不够的，原因是： 今后遇到的问题，几乎不可能与现在学习的问题一模一样，所以应该知其所以然，将问题本身抽象出来，达到触类旁通，举一反三。 有了一个新想法，如果没有足够的代码实现经验，很难以非常合理的方式用代码将其实现出来。所以应该增强将想法转化为代码的能力。 上面所说的两点的第一点，对应的是上图的路径4：给定一个策略或是设计，要思考这个策略或是设计是解决什么样的问题的，这样也就理解了这个策略或是设计的意义在哪里；而第二点对应的是上图中的路径5：怎样根据一个给定的策略来正确地，合理地用代码地实现出来；而上图中的路径6，笔者觉得也很重要：给定一份解决问题的代码，是否可以想到它所对应的问题是什么。 综上所述，笔者认为对于算法的学习，需要经常反复在问题，策略以及代码之间反复思考，这样才能真正地达到学以致用。 参考文献&amp;网站维基百科：算法 《大话数据结构》 《数据结构与算法分析：C语言描述》]]></content>
      <categories>
        <category>Data Structure &amp; Algorithm</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
        <tag>Algorithm</tag>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDWebImage源码解析]]></title>
    <url>%2F2018%2F03%2F26%2FiOS%2F%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2FSDWebImage%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言相信广大的iOS开发者，对于SDWebImage都不会陌生，这个框架通过给UIButton和UIImageView添加分类，实现了一个异步下载图片并支持缓存的功能。整个框架的接口非常简洁，每个类的分工都很明确，是很值得大家学习的一个框架。 简介在使用这个框架的时候，只需要提供一个下载的url和占位图就可以在回调里拿到下载后的图片： 123456[imageview sd_setImageWithURL:[NSURL URLWithString:@&quot;pic.jpg&quot;] placeholderImage:[UIImage imageNamed:@&quot;placeholder&quot;] completed:^(UIImage * _Nullable image, NSError * _Nullable error, SDImageCacheType cacheType, NSURL * _Nullable imageURL) &#123; imageview.image = image; NSLog(@&quot;图片加载完成&quot;); &#125;]; 而且我们还可以不设置占位图片，也可以不使用回调的block，非常灵活： 12//图片下载完成后直接显示下载后的图片[imageview sd_setImageWithURL:[NSURL URLWithString:@&quot;pic.jpg&quot;]]; 在最开始先简单介绍这个框架： 这个框架的核心类是SDWebImageManger，在外部有UIImageView+WebCache和UIButton+WebCache为下载图片的操作提供接口。内部有SDWebImageManager负责处理和协调SDWebImageDownloader和SDWebImageCache。其中SDWebImageDownloader负责具体的下载任务，SDWebImageCache负责关于缓存的工作：添加，删除，查询缓存。 首先我们大致看一下这个框架的调用流程图： 从这个流程图里可以大致看出，该框架分为两个层：UIKit层（负责接收下载参数）和工具层（负责下载操作和缓存）。 OK～基本流程大概清楚了，我们看一下每个层具体实现吧～ UIKit层该框架最外层的类是UIImageView +WebCache，我们将图片的URL，占位图片直接给这个类。下面是这个类的公共接口： 123456789101112131415161718192021 // ============== UIImageView + WebCache.h ============== //- (void)sd_setImageWithURL:(nullable NSURL *)url;- (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder;- (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options;- (void)sd_setImageWithURL:(nullable NSURL *)url completed:(nullable SDExternalCompletionBlock)completedBlock;- (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder completed:(nullable SDExternalCompletionBlock)completedBlock;- (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options completed:(nullable SDExternalCompletionBlock)completedBlock;- (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDExternalCompletionBlock)completedBlock; 可以看出，这个类提供的接口非常灵活，可以根据我们自己的需求来调用其中某一个方法，而这些方法到最后都会走到： 123456// ============== UIView+ WebCache.m ============== //- (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDExternalCompletionBlock)completedBlock; 为什么不是UIImageView+WebCache而要上一层到UIView的分类里呢？因为SDWebImage框架也支持UIButton的下载图片等方法，所以需要在它们的父类：UIView里面统一一个下载方法。 简单看一下这个方法的实现（省略的代码用…代替）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// ============== UIView+ WebCache.m ============== // //valid key：UIImageView || UIButton NSString *validOperationKey = operationKey ?: NSStringFromClass([self class]); //UIView+WebCacheOperation 的 operationDictionary //下面这行代码是保证没有当前正在进行的异步下载操作, 使它不会与即将进行的操作发生冲突 [self sd_cancelImageLoadOperationWithKey:validOperationKey]; //添加临时的占位图（在不延迟添加占位图的option下） if (!(options &amp; SDWebImageDelayPlaceholder)) &#123; dispatch_main_async_safe(^&#123; [self sd_setImage:placeholder imageData:nil basedOnClassOrViaCustomSetImageBlock:setImageBlock]; &#125;); &#125; //如果url存在 if (url) &#123; ... __weak __typeof(self)wself = self; //SDWebImageManager下载图片 id &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager loadImageWithURL:url options:options progress:progressBlock completed:^(UIImage *image, NSData *data, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; ... //dispatch_main_sync_safe : 保证block能在主线程进行 dispatch_main_async_safe(^&#123; if (!sself) &#123; return; &#125; if (image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage) &amp;&amp; completedBlock) &#123; //image，而且不自动替换 placeholder image completedBlock(image, error, cacheType, url); return; &#125; else if (image) &#123; //存在image，需要马上替换 placeholder image [sself sd_setImage:image imageData:data basedOnClassOrViaCustomSetImageBlock:setImageBlock]; [sself sd_setNeedsLayout]; &#125; else &#123; //没有image，在图片下载完之后显示 placeholder image if ((options &amp; SDWebImageDelayPlaceholder)) &#123; [sself sd_setImage:placeholder imageData:nil basedOnClassOrViaCustomSetImageBlock:setImageBlock]; [sself sd_setNeedsLayout]; &#125; &#125; if (completedBlock &amp;&amp; finished) &#123; completedBlock(image, error, cacheType, url); &#125; &#125;); &#125;]; //在操作缓存字典（operationDictionary）里添加operation，表示当前的操作正在进行 [self sd_setImageLoadOperation:operation forKey:validOperationKey]; &#125; else &#123; //如果url不存在，就在completedBlock里传入error（url为空） dispatch_main_async_safe(^&#123; [self sd_removeActivityIndicator]; if (completedBlock) &#123; NSError *error = [NSError errorWithDomain:SDWebImageErrorDomain code:-1 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Trying to load a nil url&quot;&#125;]; completedBlock(nil, error, SDImageCacheTypeNone, url); &#125; &#125;); &#125; 值得一提的是，在这一层，使用一个字典operationDictionary专门用作存储操作的缓存，随时添加，删除操作任务。而这个字典是UIView+WebCacheOperation分类的关联对象，它的存取方法使用运行时来操作： 12345678910111213 // ============== UIView+WebCacheOperation.m ============== // //获取关联对象：operations（用来存放操作的字典）- (SDOperationsDictionary *)operationDictionary &#123; SDOperationsDictionary *operations = objc_getAssociatedObject(self, &amp;loadOperationKey); //存放操作的字典 if (operations) &#123; return operations; &#125; //如果没有，就新建一个 operations = [NSMutableDictionary dictionary]; objc_setAssociatedObject(self, &amp;loadOperationKey, operations, OBJC_ASSOCIATION_RETAIN_NONATOMIC); return operations;&#125; 为什么不直接在UIImageView+WebCache里直接关联这个对象呢？我觉得这里作者应该是遵从面向对象的单一职责原则（SRP：Single responsibility principle），就连类都要履行这个职责，何况分类呢？这里作者专门创造一个分类UIView+WebCacheOperation来管理操作缓存（字典）。 到这里，UIKit层上面的东西都讲完了，现在开始正式讲解工具层。 工具层上文提到过，SDWebImageManager同时管理SDImageCache和SDWebImageDownloader两个类，它是这一层的老大哥。在下载任务开始的时候，SDWebImageManager首先访问SDImageCache来查询是否存在缓存，如果有缓存，直接返回缓存的图片。如果没有缓存，就命令SDWebImageDownloader来下载图片，下载成功后，存入缓存，显示图片。以上是SDWebImageManager大致的工作流程。 在详细讲解SDWebImageManager是如何下载图片之前，我们先看一下这个类的几个重要的属性： 12345 // ============== SDWebImageManager.h ============== //@property (strong, nonatomic, readwrite, nonnull) SDImageCache *imageCache;//管理缓存@property (strong, nonatomic, readwrite, nonnull) SDWebImageDownloader //下载器*imageDownloader;@property (strong, nonatomic, nonnull) NSMutableSet&lt;NSURL *&gt; *failedURLs;//记录失效url的名单@property (strong, nonatomic, nonnull) NSMutableArray&lt;SDWebImageCombinedOperation *&gt; *runningOperations;//记录当前正在执行的操作 SDWebImageManager下载图片的方法只有一个： 1[SDWebImageManager.sharedManager loadImageWithURL:options:progress:completed:] 看一下这个方法的具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118 // ============== SDWebImageManager.m ============== //- (id &lt;SDWebImageOperation&gt;)loadImageWithURL:(nullable NSURL *)url options:(SDWebImageOptions)options progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDInternalCompletionBlock)completedBlock &#123; ... //在SDImageCache里查询是否存在缓存的图片 operation.cacheOperation = [self.imageCache queryCacheOperationForKey:key done:^(UIImage *cachedImage, NSData *cachedData, SDImageCacheType cacheType) &#123; ... //（没有缓存图片） || （即使有缓存图片，也需要更新缓存图片） || （代理没有响应imageManager:shouldDownloadImageForURL:消息，默认返回yes，需要下载图片）|| （imageManager:shouldDownloadImageForURL:返回yes，需要下载图片） if ((!cachedImage || options &amp; SDWebImageRefreshCached) &amp;&amp; (![self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self shouldDownloadImageForURL:url])) &#123; //1. 存在缓存图片 &amp;&amp; 即使有缓存图片也要下载更新图片 if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123; [self callCompletionBlockForOperation:weakOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url]; &#125; // 2. 如果不存在缓存图片 ... //开启下载器下载 //subOperationToken 用来标记当前的下载任务，便于被取消 SDWebImageDownloadToken *subOperationToken = [self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage *downloadedImage, NSData *downloadedData, NSError *error, BOOL finished) &#123; __strong __typeof(weakOperation) strongOperation = weakOperation; if (!strongOperation || strongOperation.isCancelled) &#123; // 1. 如果任务被取消，则什么都不做，避免和其他的completedBlock重复 &#125; else if (error) &#123; //2. 如果有错误 //2.1 在completedBlock里传入error [self callCompletionBlockForOperation:strongOperation completion:completedBlock error:error url:url]; //2.2 在错误url名单中添加当前的url if ( error.code != NSURLErrorNotConnectedToInternet &amp;&amp; error.code != NSURLErrorCancelled &amp;&amp; error.code != NSURLErrorTimedOut &amp;&amp; error.code != NSURLErrorInternationalRoamingOff &amp;&amp; error.code != NSURLErrorDataNotAllowed &amp;&amp; error.code != NSURLErrorCannotFindHost &amp;&amp; error.code != NSURLErrorCannotConnectToHost) &#123; @synchronized (self.failedURLs) &#123; [self.failedURLs addObject:url]; &#125; &#125; &#125; else &#123; //3. 下载成功 //3.1 如果需要下载失败后重新下载，则将当前url从失败url名单里移除 if ((options &amp; SDWebImageRetryFailed)) &#123; @synchronized (self.failedURLs) &#123; [self.failedURLs removeObject:url]; &#125; &#125; //3.2 进行缓存 BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly); if (options &amp; SDWebImageRefreshCached &amp;&amp; cachedImage &amp;&amp; !downloadedImage) &#123; //（即使缓存存在，也要刷新图片） &amp;&amp; 缓存图片 &amp;&amp; 不存在下载后的图片：不做操作 &#125; else if (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)]) &#123; //（下载图片成功 &amp;&amp; （没有动图||处理动图） &amp;&amp; （下载之后，缓存之前处理图片） dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123; UIImage *transformedImage = [self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url]; if (transformedImage &amp;&amp; finished) &#123; BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage]; // pass nil if the image was transformed, so we can recalculate the data from the image //缓存图片 [self.imageCache storeImage:transformedImage imageData:(imageWasTransformed ? nil : downloadedData) forKey:key toDisk:cacheOnDisk completion:nil]; &#125; //将图片传入completedBlock [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:transformedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url]; &#125;); &#125; else &#123; //(图片下载成功并结束) if (downloadedImage &amp;&amp; finished) &#123; [self.imageCache storeImage:downloadedImage imageData:downloadedData forKey:key toDisk:cacheOnDisk completion:nil]; &#125; [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:downloadedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url]; &#125; &#125; //如果完成，从当前运行的操作列表里移除当前操作 if (finished) &#123; [self safelyRemoveOperationFromRunning:strongOperation]; &#125; &#125;]; //取消的block operation.cancelBlock = ^&#123; //取消当前的token [self.imageDownloader cancel:subOperationToken]; __strong __typeof(weakOperation) strongOperation = weakOperation; //从当前运行的操作列表里移除当前操作 [self safelyRemoveOperationFromRunning:strongOperation]; &#125;; &#125; else if (cachedImage) &#123; //存在缓存图片 __strong __typeof(weakOperation) strongOperation = weakOperation; //调用完成的block [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url]; //删去当前的的下载操作（线程安全） [self safelyRemoveOperationFromRunning:operation]; &#125; else &#123; //没有缓存的图片，而且下载被代理终止了 __strong __typeof(weakOperation) strongOperation = weakOperation; // 调用完成的block [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:nil data:nil error:nil cacheType:SDImageCacheTypeNone finished:YES url:url]; //删去当前的下载操作 [self safelyRemoveOperationFromRunning:operation]; &#125; &#125;]; return operation; &#125; 看完了SDWebImageManager的回调处理，我们分别看一下SDImageCache和SDWebImageDownloader内部具体是如何工作的。首先看一下SDImageCache： SDImageCache属性12345 // ============== SDImageCache.m ============== //@property (strong, nonatomic, nonnull) NSCache *memCache;//内存缓存@property (strong, nonatomic, nonnull) NSString *diskCachePath;//磁盘缓存路径@property (strong, nonatomic, nullable) NSMutableArray&lt;NSString *&gt; *customPaths;//@property (SDDispatchQueueSetterSementics, nonatomic, nullable) dispatch_queue_t //ioQueue唯一子线程; 核心方法：查询缓存12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 // ============== SDImageCache.m ============== //- (nullable NSOperation *)queryCacheOperationForKey:(nullable NSString *)key done:(nullable SDCacheQueryCompletedBlock)doneBlock &#123; if (!key) &#123; if (doneBlock) &#123; doneBlock(nil, nil, SDImageCacheTypeNone); &#125; return nil; &#125; //================查看内存的缓存=================// UIImage *image = [self imageFromMemoryCacheForKey:key]; // 如果存在，直接调用block，将image，data，CaheType传进去 if (image) &#123; NSData *diskData = nil; //如果是gif，就拿到data，后面要传到doneBlock里。不是gif就传nil if ([image isGIF]) &#123; diskData = [self diskImageDataBySearchingAllPathsForKey:key]; &#125; if (doneBlock) &#123; doneBlock(image, diskData, SDImageCacheTypeMemory); &#125; //因为图片有缓存可供使用，所以不用实例化NSOperation，直接范围nil return nil; &#125; //================查看磁盘的缓存=================// NSOperation *operation = [NSOperation new]; //唯一的子线程：self.ioQueue dispatch_async(self.ioQueue, ^&#123; if (operation.isCancelled) &#123; // 在用之前就判断operation是否被取消了，作者考虑的非常严谨 return; &#125; @autoreleasepool &#123; NSData *diskData = [self diskImageDataBySearchingAllPathsForKey:key]; UIImage *diskImage = [self diskImageForKey:key]; if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) &#123; // cost 被用来计算缓存中所有对象的代价。当内存受限或者所有缓存对象的总代价超过了最大允许的值时，缓存会移除其中的一些对象。 NSUInteger cost = SDCacheCostForImage(diskImage); //存入内存缓存中 [self.memCache setObject:diskImage forKey:key cost:cost]; &#125; if (doneBlock) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; doneBlock(diskImage, diskData, SDImageCacheTypeDisk); &#125;); &#125; &#125; &#125;); return operation;&#125; SDWebImageDownloader属性1234567 // ============== SDWebImageDownloader.m ============== //@property (strong, nonatomic, nonnull) NSOperationQueue *downloadQueue;//下载队列@property (weak, nonatomic, nullable) NSOperation *lastAddedOperation;//最后添加的下载操作@property (assign, nonatomic, nullable) Class operationClass;//操作类@property (strong, nonatomic, nonnull) NSMutableDictionary&lt;NSURL *, SDWebImageDownloaderOperation *&gt; *URLOperations;//操作数组@property (strong, nonatomic, nullable) SDHTTPHeadersMutableDictionary *HTTPHeaders;//HTTP请求头@property (SDDispatchQueueSetterSementics, nonatomic, nullable) dispatch_queue_t barrierQueue;//用来阻塞前面的下载线程（串行化） 核心方法：下载图片123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 // ============== SDWebImageDownloader.m ============== //- (nullable SDWebImageDownloadToken *)downloadImageWithURL:(nullable NSURL *)url options:(SDWebImageDownloaderOptions)options progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock &#123; __weak SDWebImageDownloader *wself = self; return [self addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^SDWebImageDownloaderOperation *&#123; __strong __typeof (wself) sself = wself; NSTimeInterval timeoutInterval = sself.downloadTimeout; if (timeoutInterval == 0.0) &#123; timeoutInterval = 15.0; &#125; // In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise //创建下载请求 NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url cachePolicy:(options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData) timeoutInterval:timeoutInterval]; request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies); request.HTTPShouldUsePipelining = YES; if (sself.headersFilter) &#123; request.allHTTPHeaderFields = sself.headersFilter(url, [sself.HTTPHeaders copy]); &#125; else &#123; request.allHTTPHeaderFields = sself.HTTPHeaders; &#125; //创建下载操作：SDWebImageDownloaderOperation用于请求网络资源的操作，它是一个 NSOperation 的子类 SDWebImageDownloaderOperation *operation = [[sself.operationClass alloc] initWithRequest:request inSession:sself.session options:options]; operation.shouldDecompressImages = sself.shouldDecompressImages; //url证书 if (sself.urlCredential) &#123; operation.credential = sself.urlCredential; &#125; else if (sself.username &amp;&amp; sself.password) &#123; operation.credential = [NSURLCredential credentialWithUser:sself.username password:sself.password persistence:NSURLCredentialPersistenceForSession]; &#125; //优先级 if (options &amp; SDWebImageDownloaderHighPriority) &#123; operation.queuePriority = NSOperationQueuePriorityHigh; &#125; else if (options &amp; SDWebImageDownloaderLowPriority) &#123; operation.queuePriority = NSOperationQueuePriorityLow; &#125; //在下载队列里添加下载操作，执行下载操作 [sself.downloadQueue addOperation:operation]; //如果后进先出 if (sself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123; // Emulate LIFO execution order by systematically adding new operations as last operation&apos;s dependency //addDependency:参数opertaion倍添加到NSOperationQueue后，只有等该opertion结束后才能执行其他的operation，实现了后进先出 [sself.lastAddedOperation addDependency:operation]; sself.lastAddedOperation = operation; &#125; return operation; &#125;];&#125; 这里面还有一个addProgressCallback: progressBlock: completedBlock: forURL: createCallback:方法，用来保存progressBlock和completedBlock。我们看一下这个方法的实现： 123456789101112131415161718192021222324252627282930313233343536373839 // ============== SDWebImageDownloader.m ============== //- (nullable SDWebImageDownloadToken *)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock forURL:(nullable NSURL *)url createCallback:(SDWebImageDownloaderOperation *(^)())createCallback &#123; // url 用来作为回调字典的key，如果为空，立即返回失败 if (url == nil) &#123; if (completedBlock != nil) &#123; completedBlock(nil, nil, nil, NO); &#125; return nil; &#125; __block SDWebImageDownloadToken *token = nil; //串行化前面所有的操作 dispatch_barrier_sync(self.barrierQueue, ^&#123; //当前下载操作中取出SDWebImageDownloaderOperation实例 SDWebImageDownloaderOperation *operation = self.URLOperations[url]; if (!operation) &#123; //如果没有，就初始化它 operation = createCallback(); self.URLOperations[url] = operation; __weak SDWebImageDownloaderOperation *woperation = operation; operation.completionBlock = ^&#123; SDWebImageDownloaderOperation *soperation = woperation; if (!soperation) return; if (self.URLOperations[url] == soperation) &#123; [self.URLOperations removeObjectForKey:url]; &#125;; &#125;; &#125; id downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock]; //这里 downloadOperationCancelToken 默认是一个字典，存放 progressBlock 和 completedBlock token = [SDWebImageDownloadToken new]; token.url = url; token.downloadOperationCancelToken = downloadOperationCancelToken; &#125;); return token;&#125; 这里真正保存两个block的方法是addHandlersForProgress: completed:： 123456789101112- (nullable id)addHandlersForProgress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock &#123; //实例化一个SDCallbacksDictionary，存放一个progressBlock 和 completedBlock SDCallbacksDictionary *callbacks = [NSMutableDictionary new]; if (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock copy]; if (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock copy]; dispatch_barrier_async(self.barrierQueue, ^&#123; //添加到缓存中 self.callbackBlocks [self.callbackBlocks addObject:callbacks]; &#125;); return callbacks;&#125; 到这里SDWebImage的核心方法都讲解完毕了，其他没有讲到的部分以后会慢慢添加上去。 最后看一下一些比较零散的知识点： 1. 运行时存取关联对象：存： 12objc_setAssociatedObject(self, &amp;loadOperationKey, operations, OBJC_ASSOCIATION_RETAIN_NONATOMIC);//将operations对象关联给self，地址为&amp;loadOperationKey，语义是OBJC_ASSOCIATION_RETAIN_NONATOMIC。 取： 12SDOperationsDictionary *operations = objc_getAssociatedObject(self, &amp;loadOperationKey);//将operations对象通过地址&amp;loadOperationKey从self里取出来 2. 数组的写操作需要加锁（多线程访问，避免覆写）12345678910111213//给self.runningOperations加锁//self.runningOperations数组的添加操作 @synchronized (self.runningOperations) &#123; [self.runningOperations addObject:operation]; &#125;//self.runningOperations数组的删除操作- (void)safelyRemoveOperationFromRunning:(nullable SDWebImageCombinedOperation*)operation &#123; @synchronized (self.runningOperations) &#123; if (operation) &#123; [self.runningOperations removeObject:operation]; &#125; &#125;&#125; 3. 确保在主线程的宏：123456789101112dispatch_main_async_safe(^&#123; //将下面这段代码放在主线程中 [self sd_setImage:placeholder imageData:nil basedOnClassOrViaCustomSetImageBlock:setImageBlock]; &#125;);//宏定义：#define dispatch_main_async_safe(block)\ if (strcmp(dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL), dispatch_queue_get_label(dispatch_get_main_queue())) == 0) &#123;\ block();\ &#125; else &#123;\ dispatch_async(dispatch_get_main_queue(), block);\ &#125;#endif 4. 设置不能为nil的参数123456789- (nonnull instancetype)initWithCache:(nonnull SDImageCache *)cache downloader:(nonnull SDWebImageDownloader *)downloader &#123; if ((self = [super init])) &#123; _imageCache = cache; _imageDownloader = downloader; _failedURLs = [NSMutableSet new]; _runningOperations = [NSMutableArray new]; &#125; return self;&#125; 如果在参数里添加了nonnull关键字，那么编译器就可以检查传入的参数是否为nil，如果是，则编译器会有警告 5. 容错，强制转换类型123if ([url isKindOfClass:NSString.class]) &#123; url = [NSURL URLWithString:(NSString *)url];&#125; 在传入的参数为NSString时（但是方法参数要求是NSURL），自动转换为NSURL]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F16%2Fhexo%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS代码规范]]></title>
    <url>%2F2018%2F03%2F15%2FiOS%2F%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%2FiOS%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[利用业余时间，整理出来了这份规范，我会将这份规范作为以后我们团队的代码规范，并且我也会根据读者的反馈以及项目的实践不定时更新，希望大家多多指正批评。 这篇规范一共分为三个部分： 核心原则：介绍这篇代码规范所遵循的核心原则。 通用规范：不局限iOS的通用性的代码规范（使用C语言和Swift语言） iOS规范：仅适用于iOS的代码规范（使用Objective-C） 一、核心原则原则一：代码应该简洁易懂，逻辑清晰以为软件是需要人来维护的。这个人在未来很可能不是你。所以首先是为人编写程序，其次才是计算机。 不要分追求技巧，降低程序的可读性 简洁的代码可以让bug无处藏身。要写出明显没有bug的代码，而不是没有明显bug的代码。 原则二：面向变化编程，而不是面向需求编程需求是暂时的，只有变化才是永恒的。本次迭代不能仅仅为了当前的需求，要写出拓展性强，易修改的程序才是责任的做法，对自己负责，对公司负责。 原则三：先保证程序的正确性，防止过度工程过度工程（over-engineering）：在正确可用的代码写出之前就过度地考虑拓展，重用的的问题，使得工程过度复杂。引用《王垠：编程的智慧》里的话： 先把眼前的问题解决掉，解决好，再考虑将来的扩展问题。 先写出可用的代码，反复推敲，再考虑是否需要重用的问题。 先写出可用，简单，明显没有bug的代码，再考虑测试的问题。 二、通用规范关于大括号 控制语句(if,for,while,switch)中，大括号开始与行尾 函数中，大括号要开始于行首 推荐这样写： 12345678910//控制语句white(someCondition)&#123;&#125;//函数void function(param1,param2)&#123;&#125; 运算符 1.运算符与变量之间的间隔1.1 一元运算符与变量之间没有空格：12345!bValue~iValue++iCount*strSource&amp;fSum 1.2 二元运算符与变量之间必须有空格：1234fWidth = 5 + 5;fLength = fWidth * 2;fHeight = fWidth + fLength;for(int i = 0; i &lt; 10; i++) 2. 多个不同的运算符同时存在时应该使用括号来明确优先级在多个不同的运算符同时存在的时候应该合理使用括号，不要盲目依赖操作符优先级。因为有的时候不能保证阅读你代码的人就一定能了解你写的算式里面所有操作符的优先级。 来看一下这个算式：2 &lt;&lt; 2 + 1 * 3 - 4 这里的&lt;&lt;是移位操作直观上却很容易认为它的优先级很高，所以就把这个算式误认为：(2 &lt;&lt; 2) + 13 - 4但事实上，它的优先级是比加减法还要低的，所以该算式应该等同于：2 &lt;&lt; (2 + 13 - 4).所以在以后写这种复杂一点的算式的时候，尽量多加一点括号，避免让其他人误解（甚至是自己）。 变量 1.一个变量有且只有一个功能，尽量不要把一个变量用作多种用途2.变量在使用前应该初始化，防止未初始化的变量被引用3.局部变量应该尽量接近使用它的地方推荐这样写： 1234567891011func someFunction() &#123; let index = ...; //Do something With index ... ... let count = ...; //Do something With count &#125; 不推荐这样写： 12345678910func someFunction() &#123; let index = ...; let count = ...; //Do something With index ... ... //Do something With count&#125; if语句 1.必须列出所有的分支（列举所有的情况），而且每个分支都必须给出明确的结果。推荐这样写： 123456var hintStr;if (count &lt; 3) &#123; hintStr = &quot;Good&quot;;&#125; else &#123; hintStr = &quot;&quot;;&#125; 不推荐这样写： 1234var hintStr;if (count &lt; 3) &#123; hintStr = &quot;Good&quot;;&#125; 2.不要使用过多的分支，要善于使用return来提前返回错误的情况推荐这样写： 123456- (void)someMethod &#123; if (!goodCondition) &#123; return; &#125; //Do something&#125; 不推荐这样写： 12345- (void)someMethod &#123; if (goodCondition) &#123; //Do something &#125;&#125; 比较典型的例子： 12345678910111213141516171819202122232425262728293031323334-(id)initWithDictionary:(NSDictionary*)dict error:(NSError)err&#123; //方法1. 参数为nil if (!dict) &#123; if (err) *err = [JSONModelError errorInputIsNil]; return nil; &#125; //方法2. 参数不是nil，但也不是字典 if (![dict isKindOfClass:[NSDictionary class]]) &#123; if (err) *err = [JSONModelError errorInvalidDataWithMessage:@&quot;Attempt to initialize JSONModel object using initWithDictionary:error: but the dictionary parameter was not an &apos;NSDictionary&apos;.&quot;]; return nil; &#125; //方法3. 初始化 self = [self init]; if (!self) &#123; //初始化失败 if (err) *err = [JSONModelError errorModelIsInvalid]; return nil; &#125; //方法4. 检查用户定义的模型里的属性集合是否大于传入的字典里的key集合（如果大于，则返回NO） if (![self __doesDictionary:dict matchModelWithKeyMapper:self.__keyMapper error:err]) &#123; return nil; &#125; //方法5. 核心方法：字典的key与模型的属性的映射 if (![self __importDictionary:dict withKeyMapper:self.__keyMapper validation:YES error:err]) &#123; return nil; &#125; //方法6. 可以重写[self validate:err]方法并返回NO，让用户自定义错误并阻拦model的返回 if (![self validate:err]) &#123; return nil; &#125; //方法7. 终于通过了！成功返回model return self;&#125; 可以看到，在这里，首先判断出各种错误的情况然后提前返回，把最正确的情况放到最后返回。 3.条件表达式如果很长，则需要将他们提取出来赋值给一个BOOL值推荐这样写： 123456let nameContainsSwift = sessionName.hasPrefix(&quot;Swift&quot;)let isCurrentYear = sessionDateCompontents.year == 2014let isSwiftSession = nameContainsSwift &amp;&amp; isCurrentYearif (isSwiftSession) &#123; // Do something&#125; 不推荐这样写： 123if ( sessionName.hasPrefix(&quot;Swift&quot;) &amp;&amp; (sessionDateCompontents.year == 2014) ) &#123; // Do something&#125; 4.条件语句的判断应该是变量在左，常量在右推荐这样写： 12if ( count == 6) &#123;&#125; 或者 12if ( object == nil) &#123;&#125; 或者 12if ( !object ) &#123;&#125; 不推荐这样写： 12if ( 6 == count) &#123;&#125; 或者 12f ( nil == object ) &#123;&#125; 5.每个分支必须的实现代码必须用大括号包围推荐这样写： 123if (!error) &#123; return success;&#125; 不推荐这样写：12if (!error) return success; 或者 1if (!error) return success; 6.条件过多，过长的时候应该换行推荐这样写： 123456if (condition1() &amp;&amp; condition2() &amp;&amp; condition3() &amp;&amp; condition4()) &#123; // Do something&#125; 不推荐这样写： 123if (condition1() &amp;&amp; condition2() &amp;&amp; condition3() &amp;&amp; condition4()) &#123; // Do something&#125; for语句 1.不可在for循环内修改循环变量，防止for循环失去控制。1234for (int index = 0; index &lt; 10; index++)&#123; ... logicToChange(index)&#125; 2.避免使用continue和break。continue和break做描述的是“什么时候不做什么”，所以为了读懂二者所在的代码，我们需要在头脑里将他们取反。 其实最好不要让这两个东西出现，移位我们的代码只要体现出“什么时候做什么”就好了，而且通过适当的方法，是可以将这两个东西消灭掉的； 2.1 如果出现了continue，只需要把continue的条件取反即可1234567var filteredProducts = Array&lt;String&gt;()for level in products &#123; if level.hasPrefix(&quot;bad&quot;) &#123; continue &#125; filteredProducts.append(level)&#125; 我们可以看到，通过判断字符串里是否还有“bad”这个prefix老过滤掉一些值。其实我们是可以通过取反，来避免使用continue的： 12345for level in products &#123; if !level.hasPrefix(&quot;bad&quot;) &#123; filteredProducts.append(level) &#125;&#125; 2.2 消除while里的break；讲break的条件取反，合并并到主循环里在while里的block其实就相当于“不存在”，既然是不存在的东西就完全可以子啊最开始的条件语句中将其排除。 while里的break: 123456while (condition1) &#123; ... if (condition2) &#123; break; &#125;&#125; 取反并合并到主条件： 123while (condition1 &amp;&amp; !condition2) &#123; ...&#125; 2.3 在有返回值的方法里消除break：将break转换为return立即返回有些朋友喜欢这样做：在有返回值的方法里break之后，再返回某个值。其实完全可以在break的那一行直接返回。 123456789func hasBadProductIn(products: Array&lt;String&gt;) -&gt; Bool &#123; var result = false for level in products &#123; if level.hasPrefix(&quot;bad&quot;) &#123; result = true &#125; &#125; return result&#125; 遇到错误条件直接返回： 12345678func hasBadProductIn(products: Array&lt;String&gt;) -&gt; Bool &#123; for level in products &#123; if level.hasPrefix(&quot;bad&quot;) &#123; return true &#125; &#125; return false&#125; 这样写的话不用特意声明一个变量来特意保存需要返回的值，看起来非常简洁，可读性高。 Switch语句 1. 每个分支都必须用大括号括起来推荐这样写： 123456789101112131415161718switch (integer) &#123; case 1: &#123; // ... &#125; break; case 2: &#123; // ... break; &#125; case 3: &#123; // ... break; &#125; default:&#123; // ... break; &#125;&#125; 2. 使用枚举类型时，不能有default分支， 除了使用枚举类型以外，都必须有default分支123456789101112131415RWTLeftMenuTopItemType menuType = RWTLeftMenuTopItemMain; switch (menuType) &#123; case RWTLeftMenuTopItemMain: &#123; // ... break; &#125; case RWTLeftMenuTopItemShows: &#123; // ... break; &#125; case RWTLeftMenuTopItemSchedule: &#123; // ... break; &#125;&#125; 在Switch语句使用枚举类型的时候，如果使用了default分支，在将来就无法通过编译器来检查新增的枚举类型了。 函数 1. 一个函数的长度必须限制在50行以内常来说，在阅读一个函数的时候，如果视需要跨过很长的垂直距离会非常影响代码的阅读体验。如果需要来回滚动眼球或代码才能看全一个方法，就会很影响思维的连贯性，对阅读代码的速度造成比较大的影响。最好的情况是在不滚动眼球或代码的情况下一眼就能将该方法的全部代码映入眼帘。 2. 一个函数只做一件事（单一原则）每个函数的职责都应该划分的很明确（就像类一样）。 推荐这样写： 12dataConfiguration()viewConfiguration() 不推荐这样写： 12345void dataConfiguration()&#123; ... viewConfiguration()&#125; 3. 对于有返回值的函数（方法），每一个分支都必须有返回值推荐这样写： 12345678910int function()&#123; if(condition1)&#123; return count1 &#125;else if(condition2)&#123; return count2 &#125;else&#123; return defaultCount &#125; &#125; 不推荐这样写： 12345678int function()&#123; if(condition1)&#123; return count1 &#125;else if(condition2)&#123; return count2 &#125;&#125; 4. 对输入参数的正确性和有效性进行检查，参数错误立即返回推荐这样写： 1234567891011void function(param1,param2)&#123; if(param1 is unavailable)&#123; return; &#125; if(param2 is unavailable)&#123; return; &#125; //Do some right thing&#125; 5. 如果在不同的函数内部有相同的功能，应该把相同的功能抽取出来单独作为另一个函数原来的调用： 123456789void logic() &#123; a(); b()； if (logic1 condition) &#123; c(); &#125; else &#123; d(); &#125;&#125; 将a，b函数抽取出来作为单独的函数 12345678910111213void basicConfig() &#123; a(); b();&#125; void logic1() &#123; basicConfig(); c();&#125;void logic2() &#123; basicConfig(); d();&#125; 6. 将函数内部比较复杂的逻辑提取出来作为单独的函数一个函数内的不清晰（逻辑判断比较多，行数较多）的那片代码，往往可以被提取出去，构成一个新的函数，然后在原来的地方调用它这样你就可以使用有意义的函数名来代替注释，增加程序的可读性。 举一个发送邮件的例子： 123456789openEmailSite();login();writeTitle(title);writeContent(content);writeReceiver(receiver);addAttachment(attachment);send(); 中间的部分稍微长一些，我们可以将它们提取出来： 1234567void writeEmail(title, content,receiver,attachment)&#123; writeTitle(title); writeContent(content); writeReceiver(receiver); addAttachment(attachment); &#125; 然后再看一下原来的代码： 1234openEmailSite();login();writeEmail(title, content,receiver,attachment)send(); 7.避免使用全局变量，类成员（class member）来传递信息，尽量使用局部变量和参数。在一个类里面，经常会有传递某些变量的情况。而如果需要传递的变量是某个全局变量或者属性的时候，有些朋友不喜欢将它们作为参数，而是在方法内部就直接访问了： 1234567891011class A &#123; var x; func updateX() &#123; ... x = ...; &#125; func printX() &#123; updateX(); print(x); &#125;&#125; 我们可以看到，在printX方法里面，updateX和print方法之间并没有值的传递，乍一看我们可能不知道x从哪里来的，导致程序的可读性降低了。 而如果你使用局部变量而不是类成员来传递信息，那么这两个函数就不需要依赖于某一个类，而且更加容易理解，不易出错： 12345678func updateX() -&gt; String&#123; x = ...; return x; &#125; func printX() &#123; String x = updateX(); print(x); &#125; 注释 优秀的代码大部分是可以自描述的，我们完全可以用程代码本身来表达它到底在干什么，而不需要注释的辅助。 但并不是说一定不能写注释，有以下三种情况比较适合写注释： 公共接口（注释要告诉阅读代码的人，当前类能实现什么功能）。涉及到比较深层专业知识的代码（注释要体现出实现原理和思想）。容易产生歧义的代码（但是严格来说，容易让人产生歧义的代码是不允许存在的）。除了上述这三种情况，如果别人只能依靠注释才能读懂你的代码的时候，就要反思代码出现了什么问题。 最后，对于注释的内容，相对于“做了什么”，更应该说明“为什么这么做”。 Code Review 换行、注释、方法长度、代码重复等这些是通过机器检查出来的问题，是无需通过人来做的。 而且除了审查需求的实现的程度，bug是否无处藏身以外，更应该关注代码的设计。比如类与类之间的耦合程度，设计的可扩展性，复用性，是否可以将某些方法抽出来作为接口等等。 三. iOS规范变量 1. 变量名必须使用驼峰格式类，协议使用大驼峰： 12HomePageViewController.h&lt;HeaderViewDelegate&gt; 对象等局部变量使用小驼峰： 12NSString *personName = @&quot;&quot;;NSUInteger totalCount = 0; 2. 变量的名称必须同时包含功能与类型123UIButton *addBtn //添加按钮UILabel *nameLbl //名字标签NSString *addressStr//地址字符串 3. 系统常用类作实例变量声明时加入后缀 类型 后缀 UIViewController VC UIView View UILabel Lbl UIButton Btn UIImage Img UIImageView ImagView NSArray Array NSMutableArray Marray NSDictionary Dict NSMutableDictionary MDdict NSString Str NSMutableString MStr NSSet Set NSMutableSet Mset 常量 1. 常量以相关类名作为前缀推荐这样写： 1static const NSTimeInterval ZOCSignInViewControllerFadeOutAnimationDuration = 0.4; 不推荐这样写： 1static const NSTimeInterval fadeOutTime = 0.4; 2. 建议使用类型常量，不建议使用#define预处理命令首先比较一下这两种声明常量的区别： 预处理命令：简单的文本替换，不包括类型信息，并且可被任意修改。 类型常量：包括类型信息，并且可以设置其使用范围，而且不可被修改。 使用预处理虽然能达到替换文本的目的，但是本身还是有局限性的： 不具备类型信息。 可以被任意修改。 3. 对外公开某个常量：如果我们需要发送通知，那么就需要在不同的地方拿到通知的“频道”字符串（通知的名称），那么显然这个字符串是不能被轻易更改，而且可以在不同的地方获取。这个时候就需要定义一个外界可见的字符串常量。 推荐这样写： 12//头文件extern NSString *const ZOCCacheControllerDidClearCacheNotification; 123//实现文件static NSString * const ZOCCacheControllerDidClearCacheNotification = @&quot;ZOCCacheControllerDidClearCacheNotification&quot;;static const CGFloat ZOCImageThumbnailHeight = 50.0f; 不推荐这样写： 12#define CompanyName @&quot;Apple Inc.&quot; #define magicNumber 42 宏 1. 宏、常量名都要使用大写字母，用下划线‘_’分割单词。123#define URL_GAIN_QUOTE_LIST @&quot;/v1/quote/list&quot;#define URL_UPDATE_QUOTE_LIST @&quot;/v1/quote/update&quot;#define URL_LOGIN @&quot;/v1/user/login” 2. 宏定义中如果包含表达式或变量，表达式和变量必须用小括号括起来。1#define MY_MIN(A, B) ((A)&gt;(B)?(B):(A)) CGRect函数 其实iOS内部已经提供了相应的获取CGRect各个部分的函数了，它们的可读性比较高，而且简短，推荐使用： 推荐这样写： 123456CGRect frame = self.view.frame; CGFloat x = CGRectGetMinX(frame); CGFloat y = CGRectGetMinY(frame); CGFloat width = CGRectGetWidth(frame); CGFloat height = CGRectGetHeight(frame); CGRect frame = CGRectMake(0.0, 0.0, width, height); 而不是 123456CGRect frame = self.view.frame; CGFloat x = frame.origin.x; CGFloat y = frame.origin.y; CGFloat width = frame.size.width; CGFloat height = frame.size.height; CGRect frame = (CGRect)&#123; .origin = CGPointZero, .size = frame.size &#125;; 范型 建议在定义NSArray和NSDictionary时使用泛型，可以保证程序的安全性： 12NSArray&lt;NSString *&gt; *testArr = [NSArray arrayWithObjects:@&quot;Hello&quot;, @&quot;world&quot;, nil];NSDictionary&lt;NSString *, NSNumber *&gt; *dic = @&#123;@&quot;key&quot;:@(1), @&quot;age&quot;:@(10)&#125;; Block为常用的Block类型创建typedef 如果我们需要重复创建某种block（相同参数，返回值）的变量，我们就可以通过typedef来给某一种块定义属于它自己的新类型 例如： 1234int (^variableName)(BOOL flag, int value) =^(BOOL flag, int value)&#123; // Implementation return someInt;&#125; 这个Block有一个bool参数和一个int参数，并返回int类型。我们可以给它定义类型： 12345int(^EOCSomeBlock)(BOOL flag, int value);//再次定义的时候，就可以通过简单的赋值来实现：EOCSomeBlock block = ^(BOOL flag, int value)&#123;// Implementation&#125;; 定义作为参数的Block： 1(void)startWithCompletionHandler: (void(^)(NSData data, NSError error))completion; 这里的Block有一个NSData参数，一个NSError参数并没有返回值 1typedef void(^EOCCompletionHandler)(NSData data, NSError error); 1(void)startWithCompletionHandler:(EOCCompletionHandler)completion;” 通过typedef定义Block签名的好处是:如果要某种块增加参数，那么只修改定义签名的那行代码即可。 字面量语法 尽量使用字面量值来创建 NSString , NSDictionary , NSArray , NSNumber 这些不可变对象： 推荐这样写： 123NSArray *names = @[@&quot;Brian&quot;, @&quot;Matt&quot;, @&quot;Chris&quot;, @&quot;Alex&quot;, @&quot;Steve&quot;, @&quot;Paul&quot;];NSDictionary *productManagers = @&#123;@&quot;iPhone&quot; : @&quot;Kate&quot;, @&quot;iPad&quot; : @&quot;Kamal&quot;, @&quot;Mobile Web&quot; : @&quot;Bill&quot;&#125;; NSNumber *shouldUseLiterals = @YES;NSNumber *buildingZIPCode = @10018; 123NSArray *names = [NSArray arrayWithObjects:@&quot;Brian&quot;, @&quot;Matt&quot;, @&quot;Chris&quot;, @&quot;Alex&quot;, @&quot;Steve&quot;, @&quot;Paul&quot;, nil];NSDictionary *productManagers = [NSDictionary dictionaryWithObjectsAndKeys: @&quot;Kate&quot;, @&quot;iPhone&quot;, @&quot;Kamal&quot;, @&quot;iPad&quot;, @&quot;Bill&quot; ];NSNumber *shouldUseLiterals = [NSNumber numberWithBool:YES];NSNumber *buildingZIPCode = [NSNumber numberWithInteger:10018]; 属性 1. 属性的命名使用小驼峰推荐这样写： 1@property (nonatomic, readwrite, strong) UIButton *confirmButton; 2. 属性的关键字推荐按照 原子性，读写，内存管理的顺序排列推荐这样写： 123@property (nonatomic, readwrite, copy) NSString *name;@property (nonatomic, readonly, copy) NSString *gender;@property (nonatomic, readwrite, strong) UIView *headerView; Block属性应该使用copy关键字 推荐这样写： 12typedef void (^ErrorCodeBlock) (id errorCode,NSString *message);@property (nonatomic, readwrite, copy) ErrorCodeBlock errorBlock;//将block拷贝到堆中 4. 形容词性的BOOL属性的getter应该加上is前缀推荐这样写： 1@property (assign, getter=isEditable) BOOL editable; 5. 使用getter方法做懒加载实例化一个对象是需要耗费资源的，如果这个对象里的某个属性的实例化要调用很多配置和计算，就需要懒加载它，在使用它的前一刻对它进行实例化： 123456789- (NSDateFormatter *)dateFormatter &#123; if (!_dateFormatter) &#123; _dateFormatter = [[NSDateFormatter alloc] init]; NSLocale *enUSPOSIXLocale = [[NSLocale alloc] initWithLocaleIdentifier:@&quot;en_US_POSIX&quot;]; [_dateFormatter setLocale:enUSPOSIXLocale]; [_dateFormatter setDateFormat:@&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss.SSS&quot;]; &#125; return _dateFormatter;&#125; 但是也有对这种做法的争议：getter方法可能会产生某些副作用，例如如果它修改了全局变量，可能会产生难以排查的错误。 6. 除了init和dealloc方法，建议都使用点语法访问属性使用点语法的好处：setter： setter会遵守内存管理语义(strong, copy, weak)。 通过在内部设置断点，有助于调试bug。 可以过滤一些外部传入的值。 捕捉KVO通知。getter： 允许子类化。 通过在内部设置断点，有助于调试bug。 实现懒加载（lazy initialization）。 注意： 懒加载的属性，必须通过点语法来读取数据。因为懒加载是通过重写getter方法来初始化实例变量的，如果不通过属性来读取该实例变量，那么这个实例变量就永远不会被初始化。 在init和dealloc方法里面使用点语法的后果是：因为没有绕过setter和getter，在setter和getter里面可能会有很多其他的操作。而且如果它的子类重载了它的setter和getter方法，那么就可能导致该子类调用其他的方法。 7. 不要滥用点语法，要区分好方法调用和属性访问推荐这样写： 12view.backgroundColor = [UIColor orangeColor]; [UIApplication sharedApplication].delegate; 不推荐这样写： 12[view setBackgroundColor:[UIColor orangeColor]]; UIApplication.sharedApplication.delegate; 8. 尽量使用不可变对象建议尽量把对外公布出来的属性设置为只读，在实现文件内部设为读写。具体做法是： 在头文件中，设置对象属性为 在实现文件中设置为123456 这样一来，在外部就只能读取该数据，而不能修改它，使得这个类的实例所持有的数据更加安全。而且，对于集合类的对象，更应该仔细考虑是否可以将其设为可变的。 如果在公开部分只能设置其为只读属性，那么就在非公开部分存储一个可变型。所以当在外部获取这个属性时，获取的只是内部可变型的一个不可变版本, 例如： 在公共API中： @interface EOCPerson : NSObject @property (nonatomic, copy, readonly) NSString firstName;@property (nonatomic, copy, readonly) NSString lastName;@property (nonatomic, strong, readonly) NSSet *friends //向外公开的不可变集合 (id)initWithFirstName:(NSString)firstName andLastName:(NSString)lastName;(void)addFriend:(EOCPerson)person;(void)removeFriend:(EOCPerson)person;@end1234&gt;在这里，我们将friends属性设置为不可变的set。然后，提供了来增加和删除这个set里的元素的公共接口。在实现文件里： @interface EOCPerson () @property (nonatomic, copy, readwrite) NSString firstName;@property (nonatomic, copy, readwrite) NSString lastName; @end @implementation EOCPerson {NSMutableSet *_internalFriends; //实现文件里的可变集合} (NSSet*)friends { return [_internalFriends copy]; //get方法返回的永远是可变set的不可变型} 12##### 2. 方法实现时，如果参数过长，则令每个参数占用一行，以冒号对齐。 (void)doSomethingWith:(NSString *)theFoo rect:(CGRect)theRect interval:(CGFloat)theInterval { //Implementation} 12##### 3. 私有方法应该在实现文件中申明。 @interface ViewController () (void)basicConfiguration;@end@implementation ViewController (void)basicConfiguration{ //Do some basic configuration}@end 123##### 4. 方法名用小写字母开头的单词组合而成 (NSString *)descriptionWithLocale:(id)locale; 123456##### 5. 方法名前缀* 刷新视图的方法名要以refresh为首。* 更新数据的方法名要以update为首。推荐这样写： (void)refreshHeaderViewWithCount:(NSUInteger)count; (void)updateDataSourceWithViewModel:(ViewModel*)viewModel;123456789101112### 面向协议编程-------如果某些功能（方法）具备可复用性，我们就需要将它们抽取出来放入一个抽象接口文件中（在iOS中，抽象接口即协议），让不同类型的对象遵循这个协议，从而拥有相同的功能。因为协议是不依赖于某个对象的，所以通过协议，我们可以解开两个对象之间的耦合。如何理解呢？我们来看一下下面这个例子：现在有一个需求：在一个`UITableViewController`里面拉取feed并展示出来。#### 方案一：定义一个拉取feed的类ZOCFeedParser，这个类有一些代理方法实现feed相关功能： @protocol ZOCFeedParserDelegate @optional (void)feedParserDidStart:(ZOCFeedParser *)parser; (void)feedParser:(ZOCFeedParser )parser didParseFeedInfo:(ZOCFeedInfoDTO )info; (void)feedParser:(ZOCFeedParser )parser didParseFeedItem:(ZOCFeedItemDTO )item; (void)feedParserDidFinish:(ZOCFeedParser *)parser; (void)feedParser:(ZOCFeedParser )parser didFailWithError:(NSError )error;@end@interface ZOCFeedParser : NSObject@property (nonatomic, weak) id delegate;@property (nonatomic, strong) NSURL *url; (id)initWithURL:(NSURL *)url; (BOOL)start; (void)stop;@end1然后在ZOCTableViewController里面传入ZOCFeedParser，并遵循其代理方法，实现feed的拉取功能。 @interface ZOCTableViewController : UITableViewController (instancetype)initWithFeedParser:(ZOCFeedParser *)feedParser;@end1然后在ZOCTableViewController里面传入ZOCFeedParser，并遵循其代理方法，实现feed的拉取功能。 @interface ZOCTableViewController : UITableViewController (instancetype)initWithFeedParser:(ZOCFeedParser *)feedParser;@end12具体应用： NSURL feedURL = [NSURL URLWithString:@”http://bbc.co.uk/feed.rss“];ZOCFeedParser feedParser = [[ZOCFeedParser alloc] initWithURL:feedURL];ZOCTableViewController *tableViewController = [[ZOCTableViewController alloc] initWithFeedParser:feedParser];feedParser.delegate = tableViewController;1234567OK，现在我们实现了需求：在`ZOCTableViewController`里面存放了一个`ZOCFeedParser`对象来处理feed的拉取功能。于是我们重新审视一下这个需求：其实我们实际上只需要`ZOCTableViewController`拉取feed就可以了，而具体是由哪个对象来拉取，`ZOCTableViewController`并不需要关心。也就是说，我们需要提供给`ZOCTableViewController`的是一个更范型的对象，这个对象具备了拉取feed的功能就好了，而不应该仅仅局限于某个具体的对象（`ZOCFeedParser`）。所以，刚才的设计需要重新做一次修改：#### 方案二：首先需要在一个接口文件`ZOCFeedParserProtocol.h`里面定义抽象的，具有拉取feed功能的协议： @protocol ZOCFeedParserDelegate @optional (void)feedParserDidStart:(id)parser; (void)feedParser:(id)parser didParseFeedInfo:(ZOCFeedInfoDTO *)info; (void)feedParser:(id)parser didParseFeedItem:(ZOCFeedItemDTO *)item; (void)feedParserDidFinish:(id)parser; (void)feedParser:(id)parser didFailWithError:(NSError )error;@end@protocol ZOCFeedParserProtocol @property (nonatomic, weak) id delegate;@property (nonatomic, strong) NSURL url; (BOOL)start; (void)stop;@end1而原来的`ZOCFeedParser`仅仅是需要遵循上面这个协议就具备了拉取feed的功能 @interface ZOCFeedParser : NSObject (id)initWithURL:(NSURL *)url;//仅仅需要通过传入url即可，其他事情都交给ZOCFeedParserProtocol@end1而且，`ZOCTableViewController`也不直接依赖于`ZOCFeedParser`对象，我们只需要传给它一个遵循`&lt;ZOCFeedParserProtocol&gt;`的对象即可。 @interface ZOCTableViewController : UITableViewController (instancetype)initWithFeedParser:(id)feedParser;@end 123456789101112131415这样一来，`ZOCTableViewController`和`wController`和`之间就没有直接的关系了。以后，如果我们想：* 给这个feed拉取器增加新的功能：仅需要修改`ZOCFeedParserProtocol.h`文件。* 更换一个feed拉取器实例：创建一个新类型来遵循`ZOCFeedParserProtocol.h`即可。### iOS 中委托的设计-------#### 1. 要区分好代理和数据源的区别在iOS开发中的委托模式包含了delegate（代理）和datasource（数据源）。虽然二者同属于委托模式，但是这两者是有区别的。这个区别就是二者的信息流方向是不同的：* delegate ：事件发生的时候，委托者需要通知代理。（信息流从委托者到代理）* datasource：委托者需要从数据源拉取数据。（信息流从数据源到委托者）然而包括苹果也没有做好榜样，将它们彻底的区分开。就拿UITableView来说，在它的delegate方法中有一个方法： (void)tableView:(UITableView )tableView didSelectRowAtIndexPath:(NSIndexPath )indexPath; 12这个方法正确地体现了代理的作用：委托者（tableview）告诉代理（控制器）“我的某个cell被点击了”。但是，UITableViewDelegate的方法列表里还有这个方法： (CGFloat)tableView:(UITableView )tableView heightForRowAtIndexPath:(NSIndexPath )indexPath 1234该方法的作用是 由控制器来告诉tabievlew的行高，也就是说，它的信息流是从控制器（数据源）到委托者（tableview）的。准确来讲，它应该是一个数据源方法，而不是代理方法。在UITableViewDataSource中，就有标准的数据源方法： (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView; 1234567这个方法的作用就是让tableview向控制器拉取一个section数量的数据。所以，在我们设计一个视图控件的代理和数据源时，一定要区分好二者的区别，合理地划分哪些方法属于代理方法，哪些方法属于数据源方法。#### 2. 代理方法的第一个参数必须为委托者代理方法必须以委托者作为第一个参数（参考UITableViewDelegate）的方法。其目的是为了区分不同委托着的实例。因为同一个控制器是可以作为多个tableview的代理的。若要区分到底是哪个tableview的cell被点击了，就需要在 (void)tableView:(UITableView )tableView didSelectRowAtIndexPath:(NSIndexPath )indexPath``方法中做个区分。123##### 向代理发送消息时需要判断其是否实现该方法最后，在委托着向代理发送消息的时候，需要判断委托着是否实现了这个代理方法: if ([self.delegate respondsToSelector:@selector(signUpViewControllerDidPressSignUpButton:)]) { [self.delegate signUpViewControllerDidPressSignUpButton:self];}1#### 3. 遵循代理过多的时候，换行对齐显示 @interface ShopViewController () 12#### 4. 代理的方法需要明确必须执行和可不执行代理方法在默认情况下都是必须执行的，然而在设计一组代理方法的时候，有些方法可以不是必须执行（是因为存在默认配置），这些方法就需要使用@optional关键字来修饰： @protocol ZOCServiceDelegate @optional- (void)generalService:(ZOCGeneralService )service didRetrieveEntries:(NSArray )entries;@end123456### 类-------#### 1. 类的名称应该以三个大写字母为前缀；创建子类的时候，应该把代表子类特点的部分放在前缀和父类名的中间推荐这样写： //父类ZOCSalesListViewController//子类ZOCDaySalesListViewControllerZOCMonthSalesListViewController1234567891011#### 2. initializer &amp;&amp; dealloc推荐：* 将 dealloc 方法放在实现文件的最前面* 将init方法放在dealloc方法后面。如果有多个初始化方法，应该将指定初始化方法放在最前面，其他初始化方法放在其后。##### 2.1 dealloc方法里面应该直接访问实例变量，不应该用点语法访问##### 2.2 init方法的写法：* init方法返回类型必须是instancetype，不能是id。* 必须先实现[super init]。 (instancetype)init { self = [super init]; // call the designated initializer if (self) { // Custom initialization } return self;}1234##### 2.3 指定初始化方法指定初始化方法(designated initializer)是提供所有的（最多的）参数的初始化方法，间接初始化方法(secondary initializer)有一个或部分参数的初始化方法。注意事项1：间接初始化方法必须调用指定初始化方法。 @implementation ZOCEvent//指定初始化方法 (instancetype)initWithTitle:(NSString )title date:(NSDate )datelocation:(CLLocation *)location{ self = [super init]; if (self) { _title = title; _date = date; _location = location; } return self;}//间接初始化方法 (instancetype)initWithTitle:(NSString )title date:(NSDate )date{ return [self initWithTitle:title date:date location:nil];}//间接初始化方法 (instancetype)initWithTitle:(NSString *)title{ return [self initWithTitle:title date:[NSDate date] location:nil];}@end 12注意事项2：如果直接父类有指定初始化方法，则必须调用其指定初始化方法 (id)initWithNibName:(NSString )nibNameOrNil bundle:(NSBundle )nibBundleOrNil { self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil]; if (self) { } return self;} 12345678注意事项3：如果想在当前类自定义一个新的全能初始化方法，则需要如下几个步骤1. 定义新的指定初始化方法，并确保调用了直接父类的初始化方法。2. 重载直接父类的初始化方法，在内部调用新定义的指定初始化方法。3. 为新的指定初始化方法写文档。看一个标准的例子： @implementation ZOCNewsViewController//新的指定初始化方法 (id)initWithNews:(ZOCNews *)news { self = [super initWithNibName:nil bundle:nil]; if (self) {_news = news; } return self;}// 重载父类的初始化方法 (id)initWithNibName:(NSString )nibNameOrNil bundle:(NSBundle )nibBundleOrNil{ return [self initWithNews:nil];}@end123456789101112在这里，重载父类的初始化方法并在内部调用新定义的指定初始化方法的原因是你不能确定调用者调用的就一定是你定义的这个新的指定初始化方法，而不是原来从父类继承来的指定初始化方法。假设你没有重载父类的指定初始化方法，而调用者却恰恰调用了父类的初始化方法。那么调用者可能永远都调用不到你自己定义的新指定初始化方法了。而如果你成功定义了一个新的指定初始化方法并能保证调用者一定能调用它，你最好要在文档中明确写出哪一个才是你定义的新初始化方法。或者你也可以使用编译器指令`__attribute__((objc_designated_initializer))`来标记它。#### 3. 所有返回类对象和实例对象的方法都应该使用instancetype将instancetype关键字作为返回值的时候，可以让编译器进行类型检查，同时适用于子类的检查，这样就保证了返回类型的正确性（一定为当前的类对象或实例对象）推荐这样写： @interface ZOCPerson (instancetype)personWithName:(NSString *)name;@end1不推荐这样写： @interface ZOCPerson (id)personWithName:(NSString *)name;@end1234#### 4. 在类的头文件中尽量少引用其他头文件有时，类A需要将类B的实例变量作为它公共API的属性。这个时候，我们不应该引入类B的头文件，而应该使用向前声明（forward declaring）使用class关键字，并且在A的实现文件引用B的头文件。 // EOCPerson.h #import @class EOCEmployer;@interface EOCPerson : NSObject@property (nonatomic, copy) NSString firstName;@property (nonatomic, copy) NSString lastName;@property (nonatomic, strong) EOCEmployer *employer;//将EOCEmployer作为属性@end// EOCPerson.m #import “EOCEmployer.h”12345678910111213这样做有什么优点呢：&gt; * 不在A的头文件中引入B的头文件，就不会一并引入B的全部内容，这样就减少了编译时间。&gt; * 可以避免循环引用：因为如果两个类在自己的头文件中都引入了对方的头文件，那么就会导致其中一个类无法被正确编译。但是个别的时候，必须在头文件中引入其他类的头文件: &gt; 主要有两种情况：&gt; 1. 该类继承于某个类，则应该引入父类的头文件。&gt; 2. 该类遵从某个协议，则应该引入该协议的头文件。而且最好将协议单独放在一个头文件中。#### 5. 类的布局 #pragma mark - Life Cycle Methods (instancetype)init (void)dealloc (void)viewWillAppear:(BOOL)animated (void)viewDidAppear:(BOOL)animated (void)viewWillDisappear:(BOOL)animated (void)viewDidDisappear:(BOOL)animated#pragma mark - Override Methods#pragma mark - Intial Methods#pragma mark - Network Methods#pragma mark - Target Methods#pragma mark - Public Methods#pragma mark - Private Methods#pragma mark - UITableViewDataSource#pragma mark - UITableViewDelegate#pragma mark - Lazy Loads#pragma mark - NSCopying#pragma mark - NSObject Methods1234567### 分类-------#### 1. 分类添加的方法需要添加前缀和下划线推荐这样写： @interface NSDate (ZOCTimeExtensions) (NSString *)zoc_timeAgoShort;@end12不推荐这样写： @interface NSDate (ZOCTimeExtensions) (NSString *)zoc_timeAgoShort;@end12345678#### 2. 把类的实现代码分散到便于管理的多个分类中一个类可能会有很多公共方法，而且这些方法往往可以用某种特有的逻辑来分组。我们可以利用Objecctive-C的分类机制，将类的这些方法按一定的逻辑划入几个分区中。举个🌰：先看一个没有使用无分类的类： #import @interface EOCPerson : NSObject@property (nonatomic, copy, readonly) NSString firstName;@property (nonatomic, copy, readonly) NSString lastName;@property (nonatomic, strong, readonly) NSArray *friends; (id)initWithFirstName:(NSString)firstName andLastName:(NSString)lastName;/ Friendship methods / (void)addFriend:(EOCPerson*)person; (void)removeFriend:(EOCPerson*)person; (BOOL)isFriendsWith:(EOCPerson)person;/ Work methods */ (void)performDaysWork; (void)takeVacationFromWork;/ Play methods / (void)goToTheCinema; (void)goToSportsGame;@end12分类之后： #import @interface EOCPerson : NSObject@property (nonatomic, copy, readonly) NSString firstName;@property (nonatomic, copy, readonly) NSString lastName;@property (nonatomic, strong, readonly) NSArray *friends; (id)initWithFirstName:(NSString)firstNameandLastName:(NSString)lastName;@end@interface EOCPerson (Friendship) (void)addFriend:(EOCPerson*)person; (void)removeFriend:(EOCPerson*)person; (BOOL)isFriendsWith:(EOCPerson*)person;@end@interface EOCPerson (Work) (void)performDaysWork; (void)takeVacationFromWork;@end@interface EOCPerson (Play) (void)goToTheCinema; (void)goToSportsGame;@end12其中，FriendShip分类的实现代码可以这么写： // EOCPerson+Friendship.h #import “EOCPerson.h”@interface EOCPerson (Friendship) (void)addFriend:(EOCPerson*)person; (void)removeFriend:(EOCPerson*)person; (BOOL)isFriendsWith:(EOCPerson*)person;@end// EOCPerson+Friendship.m#import “EOCPerson+Friendship.h”@implementation EOCPerson (Friendship) (void)addFriend:(EOCPerson)person {/ … */} (void)removeFriend:(EOCPerson)person {/ … */} (BOOL)isFriendsWith:(EOCPerson)person {/ … */}@end1234567891011121314151617&gt; 注意：在新建分类文件时，一定要引入被分类的类文件。通过分类机制，可以把类代码分成很多个易于管理的功能区，同时也便于调试。因为分类的方法名称会包含分类的名称，可以马上看到该方法属于哪个分类中。利用这一点，我们可以创建名为Private的分类，将所有私有方法都放在该类里。这样一来，我们就可以根据private一词的出现位置来判断调用的合理性，这也是一种编写“自我描述式代码（self-documenting）”的办法。### 单例-------#### 1. 单例不能作为容器对象来使用单例对象不应该暴露出任何属性，也就是说它不能作为让外部存放对象的容器。它应该是一个处理某些特定任务的工具，比如在iOS中的GPS和加速度传感器。我们只能从他们那里得到一些特定的数据。#### 2. 使用dispatch_once来生成单例推荐这样写： (instancetype)sharedInstance {static id sharedInstance = nil;static dispatch_once_t onceToken = 0; dispatch_once(&amp;onceToken, ^{ sharedInstance = [[self alloc] init];});return sharedInstance;} 12不推荐这样写： (instancetype)sharedInstance {static id sharedInstance;@synchronized(self) {if (sharedInstance == nil) { sharedInstance = [[MyClass alloc] init];} }return sharedInstance;} 12345### 相等性的判断-------判断两个person类是否相等的合理做法： (BOOL)isEqual:(id)object { if (self == object) { return YES; //判断内存地址}if (![object isKindOfClass:[ZOCPerson class]]) { return NO; //是否为当前类或派生类 }return [self isEqualToPerson:(ZOCPerson *)object]; }//自定义的判断相等性的方法 (BOOL)isEqualToPerson:(Person *)person { if (!person) { return NO; } BOOL namesMatch = (!self.name &amp;&amp; !person.name) || [self.name isEqualToString:person.name]; BOOL birthdaysMatch = (!self.birthday &amp;&amp; !person.birthday) || [self.birthday isEqualToDate:person.birthday]; return haveEqualNames &amp;&amp; haveEqualBirthdays;}12345678910111213141516171819### 方法文档-------一个函数(方法)必须有一个字符串文档来解释，除非它：* 非公开，私有函数。* 很短。* 显而易见。 而其余的，包括公开接口，重要的方法，分类，以及协议，都应该伴随文档（注释）：* 以/开始* 第二行识总结性的语句* 第三行永远是空行* 在与第二行开头对齐的位置写剩下的注释。建议这样写： /This comment serves to demonstrate the format of a doc string.Note that the summary line is always at most one line long, and after the opening block comment,and each line of text is preceded by a single space.*/12看一个指定初始化方法的注释： / Designated initializer. * @param store The store for CRUD operations. @param searchService The search service used to query the store. @return A ZOCCRUDOperationsStore object.*/ (instancetype)initWithOperationsStore:(id)store searchService:(id)searchService;1234567### 多用队列，少用同步锁来避免资源抢夺-------多个线程执行同一份代码时，很可能会造成数据不同步。建议使用GCD来为代码加锁的方式解决这个问题。#### 方案一：使用串行同步队列来将读写操作都安排到同一个队列里： _syncQueue = dispatch_queue_create(“com.effectiveobjectivec.syncQueue”, NULL);//读取字符串 (NSString*)someString { __block NSString *localSomeString; dispatch_sync(_syncQueue, ^{ localSomeString = _someString; }); return localSomeString; }//设置字符串 (void)setSomeString:(NSString*)someString { dispatch_sync(_syncQueue, ^{_someString = someString; });}123456这样一来，读写操作都在串行队列进行，就不容易出错。但是，还有一种方法可以让性能更高：#### 方案二：将写操作放入栅栏快中，让他们单独执行；将读取操作并发执行。 _syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);//读取字符串 (NSString)someString { __block NSString localSomeString; dispatch_sync(_syncQueue, ^{localSomeString = _someString; }); return localSomeString;}12 //设置字符串 (void)setSomeString:(NSString*)someString { dispatch_barrier_async(_syncQueue, ^{ _someString = someString; });} 12345678910111213显然，数据的正确性主要取决于写入操作，那么只要保证写入时，线程是安全的，那么即便读取操作是并发的，也可以保证数据是同步的。这里的`dispatch_barrier_async`方法使得操作放在了同步队列里“有序进行”，保证了写入操作的任务是在串行队列里。### 实现description方法打印自定义对象信息-------在打印我们自己定义的类的实例对象时，在控制台输出的结果往往是这样的：`object = &lt;EOCPerson: 0x7fd9a1600600&gt;`这里只包含了类名和内存地址，它的信息显然是不具体的,远达不到调试的要求。但是！如果在我们自己定义的类覆写description方法，我们就可以在打印这个类的实例时输出我们想要的信息。例如： (NSString*)description { return [NSString stringWithFormat:@”&lt;%@: %p, %@ %@&gt;”, [self class], self, firstName, lastName];} 1234在这里，显示了内存地址，还有该类的所有属性。而且，如果我们将这些属性值放在字典里打印，则更具有可读性： (NSString*)description { return [NSString stringWithFormat:@”&lt;%@: %p, %@&gt;”,[self class],self, @{ @”title”:_title, @&quot;latitude&quot;:@(_latitude), @&quot;longitude&quot;:@(_longitude)} ];} 12输出结果： location = 12345678910111213141516171819202122232425262728293031我们可以看到，通过重写`description`方法可以让我们更加了解对象的情况，便于后期的调试，节省开发时间。### NSArray&amp; NSMutableArray-------#### 1. addObject之前要非空判断。#### 2. 取下标的时候要判断是否越界。#### 3. 取第一个元素或最后一个元素的时候使用firtstObject和lastObject### NSCache-------#### 1. 构建缓存时选用NSCache 而非NSDictionary如果我们缓存使用得当，那么应用程序的响应速度就会提高。只有那种“重新计算起来很费事的数据，才值得放入缓存”，比如那些需要从网络获取或从磁盘读取的数据。在构建缓存的时候很多人习惯用NSDictionary或者NSMutableDictionary，但是作者建议大家使用NSCache，它作为管理缓存的类，有很多特点要优于字典，因为它本来就是为了管理缓存而设计的。#### 2. NSCache优于NSDictionary的几点：* 当系统资源将要耗尽时，NSCache具备自动删减缓冲的功能。并且还会先删减“最久未使用”的对象。* NSCache不拷贝键，而是保留键。因为并不是所有的键都遵从拷贝协议（字典的键是必须要支持拷贝协议的，有局限性）。* NSCache是线程安全的：不编写加锁代码的前提下，多个线程可以同时访问NSCache。### NSNotification-------#### 1. 通知的名称建议将通知的名字作为常量，保存在一个专门的类中： // Const.hextern NSString const ZOCFooDidBecomeBarNotification// Const.mNSString const ZOCFooDidBecomeBarNotification = @”ZOCFooDidBecomeBarNotification”;1234567891011#### 2. 通知的移除通知必须要在对象销毁之前移除掉。### 其他-------#### 1. Xcode工程文件的物理路径要和逻辑路径保持一致。#### 2. 忽略没有使用变量的编译警告对于某些暂时不用，以后可能用到的临时变量，为了避免警告，我们可以使用如下方法将这个警告消除： (NSInteger)giveMeFive {NSString *foo;#pragma unused (foo)return 5;} 1234#### 3. 手动标明警告和错误手动明确一个错误： (NSInteger)divide:(NSInteger)dividend by:(NSInteger)divisor {#error Whoa, buddy, you need to check for zero here!return (dividend / divisor);} 1手动明确一个警告： (float)divide:(float)dividend by:(float)divisor {#warning Dude, don’t compare floating point numbers like this!if (divisor != 0.0) {return (dividend / divisor);} else { return NAN;}}``` 参考文献： 王垠：编程的智慧 美团点评技术团队：聊聊clean code 禅与 Objective-C 编程艺术 J_Knight 的文集：iOS - 《Effective Objective-C 2.0》 蝴蝶之梦天使：iOS代码编程规范-根据项目经验汇总 高家二少爷：Objective-C高质量代码参考规范 J_Knight 的文集：iOS 代码规范]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub Pages + Hexo搭建博客]]></title>
    <url>%2F2018%2F03%2F15%2Fhexo%2FGitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[GitHub Pages + Hexo搭建博客一、 前言这是一篇是单纯地利用GitHub Pages搭建自己独立博客的过程，并没有额外使用独立域名之类的。 如果是小小白，可以先花时间去了解下： Git GitHub GitHub Pages Hexo Markdown 二、 必要配置2.1 GitHub Pages 仓库2.1.1 创建对应仓库在自己的GitHub账号下创建一个新的仓库，命名为username.github.io（username是你的账号名)。 在这里，要知道，GitHub Pages有两种类型：User/Organization Pages 和 Project Pages，而我所使用的是User Pages。 简单来说，User Pages 与 Project Pages的区别是： User Pages 是用来展示用户的，而 Project Pages 是用来展示项目的。 用于存放 User Pages 的仓库必须使用username.github.io的命名规则，而 Project Pages 则没有特殊的要求。 User Pages 将使用仓库的 master 分支，而 Project Pages 将使用 gh-pages 分支。 User Pages 通过 http(s)://username.github.io 进行访问，而 Projects Pages通过 http(s)://username.github.io/projectname 进行访问。 2.1.2 相关资料 GitHub Pages Basics / User, Organization, and Project Pages 2.2 Git2.2.1 安装 Git在windows下安装git比较常用的有两种方式： Git 官方版本的安装 GitHub for Windows 2.2.2 配置 Git当安装完Git应该做的第一件事情就是设置用户名称和邮件地址。这样做很重要，因为每一个Git的提交都会使用这些信息，并且它会写入你的每一次提交中，不可更改： 12$ git config --global user.name &quot;username&quot;$ git config --global user.email &quot;username@example.com&quot; 对于user.email，因为在GitHub的commits信息上是可见的，所以如果你不想让人知道你的email，可以Keeping your email address private: 在GitHub右上方点击你的头像，选择”Settings”； 在右边的”Personal settings”侧边栏选择”Emails”； 选择”Keep my email address private”。 这样，你就可以使用如下格式的email进行配置： 1$ git config --global user.email &quot;username@users.noreply.github.com&quot; 2.2.3 相关资料 安装 Git 配置 Git Setting your email in Git Keeping your email address private 2.3 Git 与 GitHub2.3.1 git与github的区别这里，我们要区分清楚git与github。 git是一个版本控制的工具，而github有点类似于远程仓库，用于存放用git管理的各种项目。 2.3.2 与github建立联系为了能够在本地使用git管理github上的项目，需要进行一些配置，这里介绍SSH的方法。 2.3.2.1 检查电脑是否已经有SSH KEYS。12$ ls -al ~/.ssh# Lists the files in your .ssh directory, if they exist 默认情况下，public keys的文件名是以下的格式之一：id_dsa.pub、id_ecdsa.pub、id_ed25519.pub、id_rsa.pub。因此，如果列出的文件有public和private钥匙对（例如id_ras.pub和id_rsa），证明已存在SSH keys。 2.3.2.2 如果没有SSH KEY，则生成新的SSH KEY。12$ ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;# Creates a new ssh key, using the provided email as a label 之后一路回车即可。 2.3.2.3 向SSH-AGENT添加KEY。首先确保ssh-agent可运行： 12# start the ssh-agent in the background$ ssh-agent -s 然后添加SSH key： 1$ ssh-add ~/.ssh/id_rsa 2.3.2.4 在GITHUB添加SSH KEY。首先，拷贝key： 12clip &lt; ~/.ssh/id_rsa.pub# Copies the contents of the id_rsa.pub file to your cllipboard 然后，在GitHub右上方点击头像，选择”Settings”，在右边的”Personal settings”侧边栏选择”SSH Keys”。接着粘贴key，点击”Add key”按钮。最后，测试链接： 12$ ssh -T git@github.com# Attempts to ssh to GitHub 如果你看到： 123The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 就键入：yes。之后将会看到如下信息： 12Hi username! You&apos;ve successfully authenticated, but GitHub does notprovide shell access. 2.3.3 相关资料 Generating SSH keys 2.4 Hexo2.4.1 安装Hexo安装Hexo相当简单。在安装之前，必须检查电脑中是否已经安装下列应用程序： Node.js Git 如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。 1$ npm install -g hexo-cli 2.4.2 使用Hexo建站安装完后，在你喜欢的文件夹内（例如D：\Hexo），点击鼠标右键选择Git bash，输入以下指令： 1$ hexo init 该命令会在目标文件夹内建立网站所需要的所有文件。接下来是安装依赖包： 1$ npm install 这样，我们就已经搭建起本地的Hexo博客了。可以先执行以下命令（在对应文件夹下），然后再浏览器输入localhost:4000查看。 12$ hexo generate$ hexo server 这个博客只是本地的，别人是浏览不了的，之后需要部署到GitHub上。 2.4.3 相关资料 Hexo 官方文档 三、一般的搭建方法在上面，我们已经配置好了所需的所有东西，也成功地搭建了一个本地Hexo博客。现在，需要使用GitHub Pages搭建一个别人能够访问的Hexo博客了。 3.1 使用默认theme我们继续使用上面的文件夹D:\Hexo（也可以新建一个文件夹重新生成），然后编辑该文件夹下的_config.yml。 默认生成的_config.yml： 1234# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy: type: 修改后的_config.yml： 1234deploy: type: git repo: 对应仓库的SSH地址（可以在GitHub对应的仓库中复制） branch: 分支（User Pages为master，Project Pages为gh-pages） 为了能够使Hexo部署到GitHub上，需要安装一个插件： 1$ npm install hexo-deployer-git --save 然后，执行下列指令即可完成部署： 12$ hexo generate$ hexo deploy 之后，可以通过在浏览器键入：username.github.io进行浏览，开心吧~ 3.2 其他theme如果想要使用其他主题，可以使用git clone将别人的主题拷贝到D:\Hexo\themes下，然后将_config.yml中的theme: landscape改为对应的主题名字。 下面是next主题的个性化配置教程: next个性化配置教程 四、 优化部署与管理4.1 概述Hexo部署到GitHub上的文件，是.md（你的博文）转化之后的.html（静态网页）。因此，当你重装电脑或者想在不同电脑上修改博客时，就不可能了（除非你自己写html o(^▽^)o ）。 其实，Hexo生成的网站文件中有.gitignore文件，因此它的本意也是想我们将Hexo生成的网站文件存放到GitHub上进行管理的（而不是用U盘或者云备份啦(╬▔皿▔)凸）。这样，不仅解决了上述的问题，还可以通过git的版本控制追踪你的博文的修改过程，是极赞的。 但是，如果每一个GitHub Pages都需要创建一个额外的仓库来存放Hexo网站文件，我感觉很麻烦（10个项目需要20个仓库(ˉ▽ˉ)…）。 所以，我利用了分支！！！ 简单地说，每个想建立GitHub Pages的仓库，起码有两个分支，一个用来存放Hexo网站的文件，一个用来发布网站。 下面以我的博客作为例子详细地讲述。 4.2 我的博客搭建流程 创建仓库，liuxc123.github.io； 创建两个分支：master 与 hexo； 设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）； 使用git clone git@github.com:liuxc123/liuxc123.github.io.git拷贝仓库； 修改_config.yml中的deploy参数，分支应为master； 依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件； 执行hexo generate -d生成网站并部署到GitHub上。 这样一来，在GitHub上的CrazyMilk.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。完美( •̀ ω •́ )y！ 4.3 我的博客管理流程4.3.1 日常修改在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理： 依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）； 然后才执行hexo generate -d发布网站到master分支上。 虽然两个过程顺序调转一般不会有问题，不过逻辑上这样的顺序是绝对没问题的（例如突然死机要重装了，悲催….的情况，调转顺序就有问题了）。 4.3.2 本地资料丢失当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤： 使用git clone git@github.com:liuxc123/liuxc123.github.io.git拷贝仓库（默认分支为hexo）； 在本地新拷贝的liuxc123.github.io文件夹下通过Git bash依次执行下列指令：npm install hexo、npm install、npm install hexo-deployer-git（记得，不需要hexo init这条指令）。 ###五、结尾ok,现在你就可以轻松的搭建自己的博客了。(ˉ▽ˉ)]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
