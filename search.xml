<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SDWebImage源码解析]]></title>
    <url>%2F2018%2F03%2F26%2FiOS%2F%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2FSDWebImage%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言相信广大的iOS开发者，对于SDWebImage都不会陌生，这个框架通过给UIButton和UIImageView添加分类，实现了一个异步下载图片并支持缓存的功能。整个框架的接口非常简洁，每个类的分工都很明确，是很值得大家学习的一个框架。 简介在使用这个框架的时候，只需要提供一个下载的url和占位图就可以在回调里拿到下载后的图片： 123456[imageview sd_setImageWithURL:[NSURL URLWithString:@&quot;pic.jpg&quot;] placeholderImage:[UIImage imageNamed:@&quot;placeholder&quot;] completed:^(UIImage * _Nullable image, NSError * _Nullable error, SDImageCacheType cacheType, NSURL * _Nullable imageURL) &#123; imageview.image = image; NSLog(@&quot;图片加载完成&quot;); &#125;]; 而且我们还可以不设置占位图片，也可以不使用回调的block，非常灵活： 12//图片下载完成后直接显示下载后的图片[imageview sd_setImageWithURL:[NSURL URLWithString:@&quot;pic.jpg&quot;]]; 在最开始先简单介绍这个框架： 这个框架的核心类是SDWebImageManger，在外部有UIImageView+WebCache和UIButton+WebCache为下载图片的操作提供接口。内部有SDWebImageManager负责处理和协调SDWebImageDownloader和SDWebImageCache。其中SDWebImageDownloader负责具体的下载任务，SDWebImageCache负责关于缓存的工作：添加，删除，查询缓存。 首先我们大致看一下这个框架的调用流程图： 从这个流程图里可以大致看出，该框架分为两个层：UIKit层（负责接收下载参数）和工具层（负责下载操作和缓存）。 OK～基本流程大概清楚了，我们看一下每个层具体实现吧～ UIKit层该框架最外层的类是UIImageView +WebCache，我们将图片的URL，占位图片直接给这个类。下面是这个类的公共接口： 123456789101112131415161718192021 // ============== UIImageView + WebCache.h ============== //- (void)sd_setImageWithURL:(nullable NSURL *)url;- (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder;- (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options;- (void)sd_setImageWithURL:(nullable NSURL *)url completed:(nullable SDExternalCompletionBlock)completedBlock;- (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder completed:(nullable SDExternalCompletionBlock)completedBlock;- (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options completed:(nullable SDExternalCompletionBlock)completedBlock;- (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDExternalCompletionBlock)completedBlock; 可以看出，这个类提供的接口非常灵活，可以根据我们自己的需求来调用其中某一个方法，而这些方法到最后都会走到： 123456// ============== UIView+ WebCache.m ============== //- (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDExternalCompletionBlock)completedBlock; 为什么不是UIImageView+WebCache而要上一层到UIView的分类里呢？因为SDWebImage框架也支持UIButton的下载图片等方法，所以需要在它们的父类：UIView里面统一一个下载方法。 简单看一下这个方法的实现（省略的代码用…代替）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// ============== UIView+ WebCache.m ============== // //valid key：UIImageView || UIButton NSString *validOperationKey = operationKey ?: NSStringFromClass([self class]); //UIView+WebCacheOperation 的 operationDictionary //下面这行代码是保证没有当前正在进行的异步下载操作, 使它不会与即将进行的操作发生冲突 [self sd_cancelImageLoadOperationWithKey:validOperationKey]; //添加临时的占位图（在不延迟添加占位图的option下） if (!(options &amp; SDWebImageDelayPlaceholder)) &#123; dispatch_main_async_safe(^&#123; [self sd_setImage:placeholder imageData:nil basedOnClassOrViaCustomSetImageBlock:setImageBlock]; &#125;); &#125; //如果url存在 if (url) &#123; ... __weak __typeof(self)wself = self; //SDWebImageManager下载图片 id &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager loadImageWithURL:url options:options progress:progressBlock completed:^(UIImage *image, NSData *data, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; ... //dispatch_main_sync_safe : 保证block能在主线程进行 dispatch_main_async_safe(^&#123; if (!sself) &#123; return; &#125; if (image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage) &amp;&amp; completedBlock) &#123; //image，而且不自动替换 placeholder image completedBlock(image, error, cacheType, url); return; &#125; else if (image) &#123; //存在image，需要马上替换 placeholder image [sself sd_setImage:image imageData:data basedOnClassOrViaCustomSetImageBlock:setImageBlock]; [sself sd_setNeedsLayout]; &#125; else &#123; //没有image，在图片下载完之后显示 placeholder image if ((options &amp; SDWebImageDelayPlaceholder)) &#123; [sself sd_setImage:placeholder imageData:nil basedOnClassOrViaCustomSetImageBlock:setImageBlock]; [sself sd_setNeedsLayout]; &#125; &#125; if (completedBlock &amp;&amp; finished) &#123; completedBlock(image, error, cacheType, url); &#125; &#125;); &#125;]; //在操作缓存字典（operationDictionary）里添加operation，表示当前的操作正在进行 [self sd_setImageLoadOperation:operation forKey:validOperationKey]; &#125; else &#123; //如果url不存在，就在completedBlock里传入error（url为空） dispatch_main_async_safe(^&#123; [self sd_removeActivityIndicator]; if (completedBlock) &#123; NSError *error = [NSError errorWithDomain:SDWebImageErrorDomain code:-1 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Trying to load a nil url&quot;&#125;]; completedBlock(nil, error, SDImageCacheTypeNone, url); &#125; &#125;); &#125; 值得一提的是，在这一层，使用一个字典operationDictionary专门用作存储操作的缓存，随时添加，删除操作任务。而这个字典是UIView+WebCacheOperation分类的关联对象，它的存取方法使用运行时来操作： 123456789101112131415161718192021222324 // ============== UIView+WebCacheOperation.m ============== // //获取关联对象：operations（用来存放操作的字典）- (SDOperationsDictionary *)operationDictionary &#123; SDOperationsDictionary *operations = objc_getAssociatedObject(self, &amp;loadOperationKey); //存放操作的字典 if (operations) &#123; return operations; &#125; //如果没有，就新建一个 operations = [NSMutableDictionary dictionary]; objc_setAssociatedObject(self, &amp;loadOperationKey, operations, OBJC_ASSOCIATION_RETAIN_NONATOMIC); return operations;&#125;``` 为什么不直接在`UIImageView+WebCache`里直接关联这个对象呢？我觉得这里作者应该是遵从面向对象的**单一职责原则（SRP：Single responsibility principle）**，就连类都要履行这个职责，何况分类呢？这里作者专门创造一个分类`UIView+WebCacheOperation`来管理操作缓存（字典）。到这里，UIKit层上面的东西都讲完了，现在开始正式讲解工具层。## 到这里，UIKit层上面的东西都讲完了，现在开始正式讲解工具层。上文提到过，`SDWebImageManager`同时管理`SDImageCache`和`SDWebImageDownloader`两个类，它是这一层的老大哥。在下载任务开始的时候，`SDWebImageManager`首先访问`SDImageCache`来查询是否存在缓存，如果有缓存，直接返回缓存的图片。如果没有缓存，就命令`SDWebImageDownloader`来下载图片，下载成功后，存入缓存，显示图片。以上是`SDWebImageManager`大致的工作流程。在详细讲解`SDWebImageManager`是如何下载图片之前，我们先看一下这个类的几个重要的属性： // ============== SDWebImageManager.h ============== //@property (strong, nonatomic, readwrite, nonnull) SDImageCache imageCache;//管理缓存@property (strong, nonatomic, readwrite, nonnull) SDWebImageDownloader //下载器imageDownloader;@property (strong, nonatomic, nonnull) NSMutableSet failedURLs;//记录失效url的名单@property (strong, nonatomic, nonnull) NSMutableArray&lt;SDWebImageCombinedOperation &gt; *runningOperations;//记录当前正在执行的操作12`SDWebImageManager`下载图片的方法只有一个： [SDWebImageManager.sharedManager loadImageWithURL:options:progress:completed:]12看一下这个方法的具体实现： // ============== SDWebImageManager.m ============== // (id )loadImageWithURL:(nullable NSURL *)url options:(SDWebImageOptions)options progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDInternalCompletionBlock)completedBlock { … //在SDImageCache里查询是否存在缓存的图片 operation.cacheOperation = [self.imageCache queryCacheOperationForKey:key done:^(UIImage cachedImage, NSData cachedData, SDImageCacheType cacheType) { ... //（没有缓存图片） || （即使有缓存图片，也需要更新缓存图片） || （代理没有响应imageManager:shouldDownloadImageForURL:消息，默认返回yes，需要下载图片）|| （imageManager:shouldDownloadImageForURL:返回yes，需要下载图片） if ((!cachedImage || options &amp; SDWebImageRefreshCached) &amp;&amp; (![self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self shouldDownloadImageForURL:url])) { //1. 存在缓存图片 &amp;&amp; 即使有缓存图片也要下载更新图片 if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) { [self callCompletionBlockForOperation:weakOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url]; } // 2. 如果不存在缓存图片 ... //开启下载器下载 //subOperationToken 用来标记当前的下载任务，便于被取消 SDWebImageDownloadToken *subOperationToken = [self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage *downloadedImage, NSData *downloadedData, NSError *error, BOOL finished) { __strong __typeof(weakOperation) strongOperation = weakOperation; if (!strongOperation || strongOperation.isCancelled) { // 1. 如果任务被取消，则什么都不做，避免和其他的completedBlock重复 } else if (error) { //2. 如果有错误 //2.1 在completedBlock里传入error [self callCompletionBlockForOperation:strongOperation completion:completedBlock error:error url:url]; //2.2 在错误url名单中添加当前的url if ( error.code != NSURLErrorNotConnectedToInternet &amp;&amp; error.code != NSURLErrorCancelled &amp;&amp; error.code != NSURLErrorTimedOut &amp;&amp; error.code != NSURLErrorInternationalRoamingOff &amp;&amp; error.code != NSURLErrorDataNotAllowed &amp;&amp; error.code != NSURLErrorCannotFindHost &amp;&amp; error.code != NSURLErrorCannotConnectToHost) { @synchronized (self.failedURLs) { [self.failedURLs addObject:url]; } } } else { //3. 下载成功 //3.1 如果需要下载失败后重新下载，则将当前url从失败url名单里移除 if ((options &amp; SDWebImageRetryFailed)) { @synchronized (self.failedURLs) { [self.failedURLs removeObject:url]; } } //3.2 进行缓存 BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly); if (options &amp; SDWebImageRefreshCached &amp;&amp; cachedImage &amp;&amp; !downloadedImage) { //（即使缓存存在，也要刷新图片） &amp;&amp; 缓存图片 &amp;&amp; 不存在下载后的图片：不做操作 } else if (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)]) { //（下载图片成功 &amp;&amp; （没有动图||处理动图） &amp;&amp; （下载之后，缓存之前处理图片） dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{ UIImage *transformedImage = [self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url]; if (transformedImage &amp;&amp; finished) { BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage]; // pass nil if the image was transformed, so we can recalculate the data from the image //缓存图片 [self.imageCache storeImage:transformedImage imageData:(imageWasTransformed ? nil : downloadedData) forKey:key toDisk:cacheOnDisk completion:nil]; } //将图片传入completedBlock [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:transformedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url]; }); } else { //(图片下载成功并结束) if (downloadedImage &amp;&amp; finished) { [self.imageCache storeImage:downloadedImage imageData:downloadedData forKey:key toDisk:cacheOnDisk completion:nil]; } [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:downloadedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url]; } } //如果完成，从当前运行的操作列表里移除当前操作 if (finished) { [self safelyRemoveOperationFromRunning:strongOperation]; } }]; //取消的block operation.cancelBlock = ^{ //取消当前的token [self.imageDownloader cancel:subOperationToken]; __strong __typeof(weakOperation) strongOperation = weakOperation; //从当前运行的操作列表里移除当前操作 [self safelyRemoveOperationFromRunning:strongOperation]; }; } else if (cachedImage) { //存在缓存图片 __strong __typeof(weakOperation) strongOperation = weakOperation; //调用完成的block [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url]; //删去当前的的下载操作（线程安全） [self safelyRemoveOperationFromRunning:operation]; } else { //没有缓存的图片，而且下载被代理终止了 __strong __typeof(weakOperation) strongOperation = weakOperation; // 调用完成的block [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:nil data:nil error:nil cacheType:SDImageCacheTypeNone finished:YES url:url]; //删去当前的下载操作 [self safelyRemoveOperationFromRunning:operation]; } }]; return operation;} 123456看完了`SDWebImageManager`的回调处理，我们分别看一下`SDImageCache`和`SDWebImageDownloader`内部具体是如何工作的。首先看一下`SDImageCache`：### SDImageCache#### 属性 // ============== SDImageCache.m ============== //@property (strong, nonatomic, nonnull) NSCache memCache;//内存缓存@property (strong, nonatomic, nonnull) NSString diskCachePath;//磁盘缓存路径@property (strong, nonatomic, nullable) NSMutableArray *customPaths;//@property (SDDispatchQueueSetterSementics, nonatomic, nullable) dispatch_queue_t //ioQueue唯一子线程; 12#### 核心方法：查询缓存 // ============== SDImageCache.m ============== // (nullable NSOperation )queryCacheOperationForKey:(nullable NSString )key done:(nullable SDCacheQueryCompletedBlock)doneBlock { if (!key) { if (doneBlock) { doneBlock(nil, nil, SDImageCacheTypeNone); } return nil; } //================查看内存的缓存=================// UIImage *image = [self imageFromMemoryCacheForKey:key]; // 如果存在，直接调用block，将image，data，CaheType传进去 if (image) { NSData *diskData = nil; //如果是gif，就拿到data，后面要传到doneBlock里。不是gif就传nil if ([image isGIF]) { diskData = [self diskImageDataBySearchingAllPathsForKey:key]; } if (doneBlock) { doneBlock(image, diskData, SDImageCacheTypeMemory); } //因为图片有缓存可供使用，所以不用实例化NSOperation，直接范围nil return nil; } //================查看磁盘的缓存=================// NSOperation *operation = [NSOperation new]; //唯一的子线程：self.ioQueue dispatch_async(self.ioQueue, ^{ if (operation.isCancelled) { // 在用之前就判断operation是否被取消了，作者考虑的非常严谨 return; } @autoreleasepool { NSData *diskData = [self diskImageDataBySearchingAllPathsForKey:key]; UIImage *diskImage = [self diskImageForKey:key]; if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) { // cost 被用来计算缓存中所有对象的代价。当内存受限或者所有缓存对象的总代价超过了最大允许的值时，缓存会移除其中的一些对象。 NSUInteger cost = SDCacheCostForImage(diskImage); //存入内存缓存中 [self.memCache setObject:diskImage forKey:key cost:cost]; } if (doneBlock) { dispatch_async(dispatch_get_main_queue(), ^{ doneBlock(diskImage, diskData, SDImageCacheTypeDisk); }); } } }); return operation;} 123### SDWebImageDownloader#### 属性 // ============== SDWebImageDownloader.m ============== //@property (strong, nonatomic, nonnull) NSOperationQueue downloadQueue;//下载队列@property (weak, nonatomic, nullable) NSOperation lastAddedOperation;//最后添加的下载操作@property (assign, nonatomic, nullable) Class operationClass;//操作类@property (strong, nonatomic, nonnull) NSMutableDictionary URLOperations;//操作数组@property (strong, nonatomic, nullable) SDHTTPHeadersMutableDictionary HTTPHeaders;//HTTP请求头@property (SDDispatchQueueSetterSementics, nonatomic, nullable) dispatch_queue_t barrierQueue;//用来阻塞前面的下载线程（串行化） 1#### 核心方法：下载图片 // ============== SDWebImageDownloader.m ============== // (nullable SDWebImageDownloadToken )downloadImageWithURL:(nullable NSURL )url options:(SDWebImageDownloaderOptions)options progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock { __weak SDWebImageDownloader wself = self; return [self addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^SDWebImageDownloaderOperation { __strong __typeof (wself) sself = wself; NSTimeInterval timeoutInterval = sself.downloadTimeout; if (timeoutInterval == 0.0) { timeoutInterval = 15.0; } // In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise //创建下载请求 NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url cachePolicy:(options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData) timeoutInterval:timeoutInterval]; request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies); request.HTTPShouldUsePipelining = YES; if (sself.headersFilter) { request.allHTTPHeaderFields = sself.headersFilter(url, [sself.HTTPHeaders copy]); } else { request.allHTTPHeaderFields = sself.HTTPHeaders; } //创建下载操作：SDWebImageDownloaderOperation用于请求网络资源的操作，它是一个 NSOperation 的子类 SDWebImageDownloaderOperation *operation = [[sself.operationClass alloc] initWithRequest:request inSession:sself.session options:options]; operation.shouldDecompressImages = sself.shouldDecompressImages; //url证书 if (sself.urlCredential) { operation.credential = sself.urlCredential; } else if (sself.username &amp;&amp; sself.password) { operation.credential = [NSURLCredential credentialWithUser:sself.username password:sself.password persistence:NSURLCredentialPersistenceForSession]; } //优先级 if (options &amp; SDWebImageDownloaderHighPriority) { operation.queuePriority = NSOperationQueuePriorityHigh; } else if (options &amp; SDWebImageDownloaderLowPriority) { operation.queuePriority = NSOperationQueuePriorityLow; } //在下载队列里添加下载操作，执行下载操作 [sself.downloadQueue addOperation:operation]; //如果后进先出 if (sself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) { // Emulate LIFO execution order by systematically adding new operations as last operation&apos;s dependency //addDependency:参数opertaion倍添加到NSOperationQueue后，只有等该opertion结束后才能执行其他的operation，实现了后进先出 [sself.lastAddedOperation addDependency:operation]; sself.lastAddedOperation = operation; } return operation; }];} 1这里面还有一个`addProgressCallback: progressBlock: completedBlock: forURL: createCallback:`方法，用来保存`progressBlock`和`completedBlock`。我们看一下这个方法的实现： // ============== SDWebImageDownloader.m ============== // (nullable SDWebImageDownloadToken *)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock forURL:(nullable NSURL *)url createCallback:(SDWebImageDownloaderOperation *(^)())createCallback { // url 用来作为回调字典的key，如果为空，立即返回失败 if (url == nil) { if (completedBlock != nil) { completedBlock(nil, nil, nil, NO); } return nil; } __block SDWebImageDownloadToken *token = nil; //串行化前面所有的操作 dispatch_barrier_sync(self.barrierQueue, ^{ //当前下载操作中取出SDWebImageDownloaderOperation实例 SDWebImageDownloaderOperation *operation = self.URLOperations[url]; if (!operation) { //如果没有，就初始化它 operation = createCallback(); self.URLOperations[url] = operation; __weak SDWebImageDownloaderOperation *woperation = operation; operation.completionBlock = ^{ SDWebImageDownloaderOperation *soperation = woperation; if (!soperation) return; if (self.URLOperations[url] == soperation) { [self.URLOperations removeObjectForKey:url]; }; }; } id downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock]; //这里 downloadOperationCancelToken 默认是一个字典，存放 progressBlock 和 completedBlock token = [SDWebImageDownloadToken new]; token.url = url; token.downloadOperationCancelToken = downloadOperationCancelToken; }); return token;} 12这里真正保存两个block的方法是`addHandlersForProgress: completed:`： (nullable id)addHandlersForProgress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock { //实例化一个SDCallbacksDictionary，存放一个progressBlock 和 completedBlock SDCallbacksDictionary *callbacks = [NSMutableDictionary new]; if (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock copy]; if (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock copy]; dispatch_barrier_async(self.barrierQueue, ^{ //添加到缓存中 self.callbackBlocks [self.callbackBlocks addObject:callbacks]; }); return callbacks;} 12345678910到这里`SDWebImage`的核心方法都讲解完毕了，其他没有讲到的部分以后会慢慢添加上去。## 最后看一下一些比较零散的知识点：-------### 1. 运行时存取关联对象：存： objc_setAssociatedObject(self, &amp;loadOperationKey, operations, OBJC_ASSOCIATION_RETAIN_NONATOMIC);//将operations对象关联给self，地址为&amp;loadOperationKey，语义是OBJC_ASSOCIATION_RETAIN_NONATOMIC。12取： SDOperationsDictionary *operations = objc_getAssociatedObject(self, &amp;loadOperationKey);//将operations对象通过地址&amp;loadOperationKey从self里取出来1### 2. 数组的写操作需要加锁（多线程访问，避免覆写） //给self.runningOperations加锁//self.runningOperations数组的添加操作 @synchronized (self.runningOperations) { [self.runningOperations addObject:operation]; }//self.runningOperations数组的删除操作 (void)safelyRemoveOperationFromRunning:(nullable SDWebImageCombinedOperation*)operation { @synchronized (self.runningOperations) {if (operation) { [self.runningOperations removeObject:operation]; } }}12### 3. 确保在主线程的宏： dispatch_main_async_safe(^{ //将下面这段代码放在主线程中 [self sd_setImage:placeholder imageData:nil basedOnClassOrViaCustomSetImageBlock:setImageBlock]; });//宏定义： #define dispatch_main_async_safe(block)\ if (strcmp(dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL), dispatch_queue_get_label(dispatch_get_main_queue())) == 0) {\ block();\ } else {\ dispatch_async(dispatch_get_main_queue(), block);\ } #endif1### 4. 设置不能为nil的参数 (nonnull instancetype)initWithCache:(nonnull SDImageCache )cache downloader:(nonnull SDWebImageDownloader )downloader { if ((self = [super init])) {_imageCache = cache; _imageDownloader = downloader; _failedURLs = [NSMutableSet new]; _runningOperations = [NSMutableArray new]; } return self;}1234&gt; 如果在参数里添加了nonnull关键字，那么编译器就可以检查传入的参数是否为nil，如果是，则编译器会有警告### 5. 容错，强制转换类型 if ([url isKindOfClass:NSString.class]) { url = [NSURL URLWithString:(NSString *)url];}```在传入的参数为NSString时（但是方法参数要求是NSURL），自动转换为NSURL]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[YTKNetwork源码解析]]></title>
    <url>%2F2018%2F03%2F18%2FiOS%2F%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2FYTKNetwork%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[作为一名iOS开发工作者，大家应该都听过YTKNetwork框架吧。它是猿题库技术团队开源的一个网络请求框架，内部封装了AFNetworking。它把每个请求实例化，管理它的生命周期，也可以管理多个请求。 在正式讲解源码之前，我会先讲一下该框架所用的架构和设计模式。我总觉得对架构和设计有一定的了解的话，会有助于对源码的理解。 1. 架构 先上图： 在这里简单说明一下： YTKNetwork框架将每一个请求实例化，YTKBaseRequest是所有请求类的基类，YTKRequest是它的子类。所以如果我们想要发送一个请求，则需要创建并实例化一个继承于YTKRequest的自定义的请求类（CustomRequest）并发送请求。 YTKNetworkAgent是一个单例，负责管理所有的请求类（例如CustomRequest）。当CustomRequest发送请求以后，会把自己放在YTKNetworkAgent持有的一个字典里，让其管理自己。 我们说YTKNetwork封装了AFNetworking，实际上是YTKNetworkAgent封装了AFNetworking，由它负责AFNetworking请求的发送和AFNetworking的回调处理。所以如果我们想更换一个第三方网络请求库，就可以在这里更换一下。而YTKRequest更多的是只是负责缓存的处理。 YTKNetworkConfig与YTKPriviate的具体职能现在不做介绍，会在后文给出。 OK，现在我们知道了YTKNetwork中类与类之间的关系以及关键类的大致职能，接下来我会告诉你YTKNetwork为什么会采用这种关系来架构，以及采用这种架构会有什么好处。 2. 设计模式 YTKNetwork框架采用的设计模式是命令模式（Command Pattern）。 首先看一下命令模式的定义： 命令模式将请求封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。摘自：《Head First 设计模式》 看一下命令模式的类图： 图中英文的含义： 英文 中文 Command 抽象命令类 ConcreteCommand 命令类的实现类（子类） Invoker 调用者 Receiver 命令接收者（执行者) Client 客户端 详细介绍一下： 命令模式的本质是对命令的封装，将发出命令的责任和执行命令的责任分割开。 命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。 可能还是觉得有点抽象，在这里举一个《Head First 设计模式》里的例子，一个客人在餐厅点餐的过程： 你将点的菜写在订单里，交给了服务员。 服务员将订单交给厨师。 厨师做好菜之后将做好的菜交给服务员。 最后服务员把菜递给你。 在这里，命令就好比是订单，而你是命令的发起者。你的命令（订单）通过服务员（调用者）交给了命令的执行者（厨师）。所以至于这道菜具体是谁做，怎么做，你是不知道的，你做的只是发出命令和接受结果。而且对于餐厅来说，厨师是可以随便换的，而你可能对此一无所知。反过来，厨师只需要好好把菜做好，至于是谁点的菜也不需要他考虑。 结合上面命令模式的类图以及餐厅点餐的例子，我们来理清一下YTKNetwork内部的职能 场景 Command ConcreteCommand Invoker Receiver Client 餐厅 空白订单 填入菜名的订单 服务员 厨师 客人 YTKNetwork YTKBaseRequest CustomRequest YTKNetworkAgent AFNetworking ViewController/ViewModel 可以看到，YTKNetwork对命令模式的实现是很符合其设计标准的，它将请求的发起者和接收者分离开来(中间隔着调用者)，可以让我们随时更换接受者。 另外，因为封装了请求，我们既可以管理单个请求，也可以同时管理多个请求，甚至实现琏式请求的发送。关于多个请求的发送，我们也可以想象在餐厅里，你可以在吃的过程中还想起来要吃别的东西，例如点心，饮料之类的，你就可以填多个订单（当然也可以写在一起）交给服务员。 相信到这里，大家应该对YTKNetwork的设计与架构有了足够的认识了，下面进入到真正的源码解析，我们结合一下它的代码来看一下YTKNetwork是如何实现和管理网络请求的。 3. 源码解析 在真正讲解源码之前，我先详细说一下各个类的职责: 3.1 责任介绍 类名 职责 YTKBaseRequest 所有请求类的基类。持有NSURLSessionTask实例，responseData，responseObject，error等重要数据，提供一些需要子类实现的与网络请求相关的方法，处理回调的代理和block，命令YTKNetworkAgent发起网络请求。 YTKRequest YTKBaseRequest的子类。负责缓存的处理：请求前查询缓存；请求后写入缓存。 YTKNetworkConfig 被YTKRequest和YTKNetworkAgent访问。负责所有请求的全局配置，例如baseUrl和CDNUrl等等。 YTKNetworkPrivate 提供JSON验证，appVersion等辅助性的方法；给YTKBaseRequest增加一些分类。 YTKNetworkAgent 真正发起请求的类。负责发起请求，结束请求，并持有一个字典来存储正在执行的请求。 YTKBatchRequest 可以发起批量请求，持有一个数组来保存所有的请求类。在请求执行后遍历这个数组来发起请求，如果其中有一个请求返回失败，则认定本组请求失败。 YTKBatchRequestAgent 负责管理多个YTKBatchRequest实例，持有一个数组来保存YTKBatchRequest。支持添加和删除YTKBatchRequest实例。 YTKChainRequest 可以发起链式请求，持有一个数组来保存所有的请求类。当某个请求结束后才能发起下一个请求，如果其中有一个请求返回失败，则认定本请求链失败。 YTKChainRequestAgent 负责管理多个YTKChainRequestAgent实例，持有一个数组来保存YTKChainRequest。支持添加和删除YTKChainRequest实例。 OK，现在知道了YTKNetwork内部的责任分配，下面我们先从单个请求的全部流程（配置，发起，结束）来看一下YTKNetwork都做了什么。 3.2 单个请求3.21 单个请求的配置官方的教程建议我们将请求的全局配置是在AppDelegate.m文件里，设定baseUrl以及cdnUrl等参数。 1234567- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; YTKNetworkConfig *config = [YTKNetworkConfig sharedConfig]; config.baseUrl = @&quot;http://yuantiku.com&quot;; config.cdnUrl = @&quot;http://fen.bi&quot;;&#125; 如果我们需要新建一个注册的请求，则需要创建一个继承于YTKRequest的注册接口的类RegisterApi，并将针对该请求参数配置好： 12345678910111213141516171819202122232425262728293031323334353637// RegisterApi.h#import &quot;YTKRequest.h&quot;@interface RegisterApi : YTKRequest- (id)initWithUsername:(NSString *)username password:(NSString *)password;@end// RegisterApi.m#import &quot;RegisterApi.h&quot;@implementation RegisterApi &#123; NSString *_username; NSString *_password;&#125;//初始化的时候将两个参数值传入- (id)initWithUsername:(NSString *)username password:(NSString *)password &#123; self = [super init]; if (self) &#123; _username = username; _password = password; &#125; return self;&#125;//需要和baseUrl拼接的地址- (NSString *)requestUrl &#123; // “ http://www.yuantiku.com ” 在 YTKNetworkConfig 中设置，这里只填除去域名剩余的网址信息 return @&quot;/iphone/register&quot;;&#125;//请求方法，某人是GET- (YTKRequestMethod)requestMethod &#123; return YTKRequestMethodPOST;&#125;//请求体- (id)requestArgument &#123; return @&#123; @&quot;username&quot;: _username, @&quot;password&quot;: _password &#125;;&#125;@end 现在我们知道如何配置全局的参数和针对某个请求的参数了，接下来看一下单个请求是如何发起的。 3.22 单个请求的发起还是刚才的注册API，在实例化以后，直接调用startWithCompletionBlockWithSuccess:failure方法（或start方法）就可以发起它： 123456789101112131415//LoginViewController.m- (void)loginButtonPressed:(id)sender &#123; NSString *username = self.UserNameTextField.text; NSString *password = self.PasswordTextField.text; if (username.length &gt; 0 &amp;&amp; password.length &gt; 0) &#123; RegisterApi *api = [[RegisterApi alloc] initWithUsername:username password:password]; [api startWithCompletionBlockWithSuccess:^(YTKBaseRequest *request) &#123; // 你可以直接在这里使用 self NSLog(@&quot;succeed&quot;); &#125; failure:^(YTKBaseRequest *request) &#123; // 你可以直接在这里使用 self NSLog(@&quot;failed&quot;); &#125;]; &#125;&#125; 上面是以block的形式回调，YTKNetwork也支持代理的回调： 12345678910111213141516//LoginViewController.m- (void)loginButtonPressed:(id)sender &#123; NSString *username = self.UserNameTextField.text; NSString *password = self.PasswordTextField.text; if (username.length &gt; 0 &amp;&amp; password.length &gt; 0) &#123; RegisterApi *api = [[RegisterApi alloc] initWithUsername:username password:password]; api.delegate = self; [api start]; &#125;&#125;- (void)requestFinished:(YTKBaseRequest *)request &#123; NSLog(@&quot;succeed&quot;);&#125;- (void)requestFailed:(YTKBaseRequest *)request &#123; NSLog(@&quot;failed&quot;);&#125; 有两点需要注意的是： 必须给自定义请求类（RegisterApi）调用startWithCompletionBlockWithSuccess:failure方法（或start方法），才能真正发起请求。 在同时设置了回调代理和回调block的情况下，首先回调的是回调代理方法，然后再走回调block。 知道了YTKRequest请求是如何在外部发起的，我们现在从startWithCompletionBlockWithSuccess:failure方法开始，来看一下YTKNetwork都做了什么： 首先来到YTKBaseRequest类（因为最早是由它定义的该方法）： 123456789101112131415//YTKBaseRequest.m//传入成功和失败的block,并保存起来- (void)startWithCompletionBlockWithSuccess:(YTKRequestCompletionBlock)success failure:(YTKRequestCompletionBlock)failure &#123; //保存成功和失败的回调block，便于将来调用 [self setCompletionBlockWithSuccess:success failure:failure]; //发起请求 [self start];&#125;//保存成功和失败的block- (void)setCompletionBlockWithSuccess:(YTKRequestCompletionBlock)success failure:(YTKRequestCompletionBlock)failure &#123; self.successCompletionBlock = success; self.failureCompletionBlock = failure;&#125; 当保存完成功和失败的block以后，调用start方法，于是来到了YTKRequest类（注意，虽然YTKBaseRequest也实现了start方法，但是由于YTKRequest类是它的子类并也实现了start方法，所以这里最先走的是YTKRequest类的start方法）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344//YTKRequest.m- (void)start &#123; //1. 如果忽略缓存 -&gt; 请求 if (self.ignoreCache) &#123; [self startWithoutCache]; return; &#125; //2. 如果存在下载未完成的文件 -&gt; 请求 if (self.resumableDownloadPath) &#123; [self startWithoutCache]; return; &#125; //3. 获取缓存失败 -&gt; 请求 if (![self loadCacheWithError:nil]) &#123; [self startWithoutCache]; return; &#125; //4. 到这里，说明一定能拿到可用的缓存，可以直接回调了（因为一定能拿到可用的缓存，所以一定是调用成功的block和代理） _dataFromCache = YES; dispatch_async(dispatch_get_main_queue(), ^&#123; //5. 回调之前的操作 //5.1 缓存处理 [self requestCompletePreprocessor]; //5.2 用户可以在这里进行真正回调前的操作 [self requestCompleteFilter]; YTKRequest *strongSelf = self; //6. 执行回调 //6.1 请求完成的代理 [strongSelf.delegate requestFinished:strongSelf]; //6.2 请求成功的block if (strongSelf.successCompletionBlock) &#123; strongSelf.successCompletionBlock(strongSelf); &#125; //7. 把成功和失败的block都设置为nil，避免循环引用 [strongSelf clearCompletionBlock]; &#125;);&#125; 我们之前说过YTKRequest负责缓存的相关处理，所以在上面这个start方法里，它做的是请求之前缓存的查询和检查工作: 如果忽略缓存，或者缓存获取失败，调用startWithoutCache方法（参考1-3的情况），发起请求。 如果能成功获取到缓存，则直接回调（参考4-7的情况）。 我们来看一下每一步的具体实现： ignoreCache属性是用户手动设置的，如果用户强制忽略缓存，则无论是否缓存是否存在，直接发送请求。 resumableDownloadPath是断点下载路径，如果该路径不为空，说明有未完成的下载任务，则直接发送请求继续下载。 loadCacheWithError：方法验证了加载缓存是否成功的方法（返回值为YES，说明可以加载缓存；反之亦然），看一下具体实现： 123456789101112131415161718192021222324252627282930//YTKRequest.m- (BOOL)loadCacheWithError:(NSError * _Nullable __autoreleasing *)error &#123; // 缓存时间小于0，则返回（缓存时间默认为-1，需要用户手动设置，单位是秒） if ([self cacheTimeInSeconds] &lt; 0) &#123; if (error) &#123; *error = [NSError errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorInvalidCacheTime userInfo:@&#123; NSLocalizedDescriptionKey:@&quot;Invalid cache time&quot;&#125;]; &#125; return NO; &#125; // 是否有缓存的元数据，如果没有，返回错误 if (![self loadCacheMetadata]) &#123; if (error) &#123; *error = [NSError errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorInvalidMetadata userInfo:@&#123; NSLocalizedDescriptionKey:@&quot;Invalid metadata. Cache may not exist&quot;&#125;]; &#125; return NO; &#125; // 有缓存，再验证是否有效 if (![self validateCacheWithError:error]) &#123; return NO; &#125; // 有缓存，而且有效，再验证是否能取出来 if (![self loadCacheData]) &#123; if (error) &#123; *error = [NSError errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorInvalidCacheData userInfo:@&#123; NSLocalizedDescriptionKey:@&quot;Invalid cache data&quot;&#125;]; &#125; return NO; &#125; return YES;&#125; 先讲一下什么是元数据：元数据是指数据的数据，在这里描述了缓存数据本身的一些特征：包括版本号，缓存时间，敏感信息等等， 稍后会做详细介绍。 我们来看一下上面关于缓存的元数据的获取方法：loadCacheMetadata方法 1234567891011121314151617//YTKRequest.m- (BOOL)loadCacheMetadata &#123; NSString *path = [self cacheMetadataFilePath]; NSFileManager * fileManager = [NSFileManager defaultManager]; if ([fileManager fileExistsAtPath:path isDirectory:nil]) &#123; @try &#123; //将序列化之后被保存在磁盘里的文件反序列化到当前对象的属性cacheMetadata _cacheMetadata = [NSKeyedUnarchiver unarchiveObjectWithFile:path]; return YES; &#125; @catch (NSException *exception) &#123; YTKLog(@&quot;Load cache metadata failed, reason = %@&quot;, exception.reason); return NO; &#125; &#125; return NO;&#125; cacheMetadata（YTKCacheMetadata） 是当前reqeust类用来保存缓存元数据的属性。 YTKCacheMetadata类被定义在YTKRequest.m文件里面： 12345678910//YTKRequest.m@interface YTKCacheMetadata : NSObject&lt;NSSecureCoding&gt;@property (nonatomic, assign) long long version;@property (nonatomic, strong) NSString *sensitiveDataString;@property (nonatomic, assign) NSStringEncoding stringEncoding;@property (nonatomic, strong) NSDate *creationDate;@property (nonatomic, strong) NSString *appVersionString;@end 它描述的是缓存的版本号，敏感信息，创建时间，app版本等信息，并支持序列化处理，可以保存在磁盘里。因此，loadCacheMetadata方法的目的是将之前被序列化保存的缓存元数据信息反序列化，赋给自身的cacheMetadata属性上。 现在获取了缓存的元数据并赋给了自身的cacheMetadata属性上，那么接下来就要逐一验证元数据里的各项信息是否符合要求，在下面的validateCacheWithError：里面验证： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//YTKRequest.m- (BOOL)validateCacheWithError:(NSError * _Nullable __autoreleasing *)error &#123; // 是否大于过期时间 NSDate *creationDate = self.cacheMetadata.creationDate; NSTimeInterval duration = -[creationDate timeIntervalSinceNow]; if (duration &lt; 0 || duration &gt; [self cacheTimeInSeconds]) &#123; if (error) &#123; *error = [NSError errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorExpired userInfo:@&#123; NSLocalizedDescriptionKey:@&quot;Cache expired&quot;&#125;]; &#125; return NO; &#125; // 缓存的版本号是否符合 long long cacheVersionFileContent = self.cacheMetadata.version; if (cacheVersionFileContent != [self cacheVersion]) &#123; if (error) &#123; *error = [NSError errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorVersionMismatch userInfo:@&#123; NSLocalizedDescriptionKey:@&quot;Cache version mismatch&quot;&#125;]; &#125; return NO; &#125; // 敏感信息是否符合 NSString *sensitiveDataString = self.cacheMetadata.sensitiveDataString; NSString *currentSensitiveDataString = ((NSObject *)[self cacheSensitiveData]).description; if (sensitiveDataString || currentSensitiveDataString) &#123; // If one of the strings is nil, short-circuit evaluation will trigger if (sensitiveDataString.length != currentSensitiveDataString.length || ![sensitiveDataString isEqualToString:currentSensitiveDataString]) &#123; if (error) &#123; *error = [NSError errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorSensitiveDataMismatch userInfo:@&#123; NSLocalizedDescriptionKey:@&quot;Cache sensitive data mismatch&quot;&#125;]; &#125; return NO; &#125; &#125; // app的版本是否符合 NSString *appVersionString = self.cacheMetadata.appVersionString; NSString *currentAppVersionString = [YTKNetworkUtils appVersionString]; if (appVersionString || currentAppVersionString) &#123; if (appVersionString.length != currentAppVersionString.length || ![appVersionString isEqualToString:currentAppVersionString]) &#123; if (error) &#123; *error = [NSError errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorAppVersionMismatch userInfo:@&#123; NSLocalizedDescriptionKey:@&quot;App version mismatch&quot;&#125;]; &#125; return NO; &#125; &#125; return YES;&#125; 如果每项元数据信息都能通过，再在loadCacheData方法里面验证缓存是否能被取出来： 123456789101112131415161718192021222324//YTKRequest.m- (BOOL)loadCacheData &#123; NSString *path = [self cacheFilePath]; NSFileManager *fileManager = [NSFileManager defaultManager]; NSError *error = nil; if ([fileManager fileExistsAtPath:path isDirectory:nil]) &#123; NSData *data = [NSData dataWithContentsOfFile:path]; _cacheData = data; _cacheString = [[NSString alloc] initWithData:_cacheData encoding:self.cacheMetadata.stringEncoding]; switch (self.responseSerializerType) &#123; case YTKResponseSerializerTypeHTTP: // Do nothing. return YES; case YTKResponseSerializerTypeJSON: _cacheJSON = [NSJSONSerialization JSONObjectWithData:_cacheData options:(NSJSONReadingOptions)0 error:&amp;error]; return error == nil; case YTKResponseSerializerTypeXMLParser: _cacheXML = [[NSXMLParser alloc] initWithData:_cacheData]; return YES; &#125; &#125; return NO;&#125; 如果通过了最终的考验，则说明当前请求对应的缓存是符合各项要求并可以被成功取出，也就是可以直接进行回调了。 当确认缓存可以成功取出后，手动设置dataFromCache属性为 YES，说明当前的请求结果是来自于缓存，而没有通过网络请求。 然后在真正回调之前做了如下处理： 12345678910//YTKRequest.m：- (void)start&#123; .... //5. 回调之前的操作 //5.1 缓存处理 [self requestCompletePreprocessor]; //5.2 用户可以在这里进行真正回调前的操作 [self requestCompleteFilter]; ....&#125; 5.1：requestCompletePreprocessor方法: 1234567891011121314151617//YTKRequest.m：- (void)requestCompletePreprocessor &#123; [super requestCompletePreprocessor]; //是否异步将responseData写入缓存（写入缓存的任务放在专门的队列ytkrequest_cache_writing_queue进行） if (self.writeCacheAsynchronously) &#123; dispatch_async(ytkrequest_cache_writing_queue(), ^&#123; //保存响应数据到缓存 [self saveResponseDataToCacheFile:[super responseData]]; &#125;); &#125; else &#123; //保存响应数据到缓存 [self saveResponseDataToCacheFile:[super responseData]]; &#125;&#125; 1234567891011121314151617181920212223//YTKRequest.m：//保存响应数据到缓存- (void)saveResponseDataToCacheFile:(NSData *)data &#123; if ([self cacheTimeInSeconds] &gt; 0 &amp;&amp; ![self isDataFromCache]) &#123; if (data != nil) &#123; @try &#123; // New data will always overwrite old data. [data writeToFile:[self cacheFilePath] atomically:YES]; YTKCacheMetadata *metadata = [[YTKCacheMetadata alloc] init]; metadata.version = [self cacheVersion]; metadata.sensitiveDataString = ((NSObject *)[self cacheSensitiveData]).description; metadata.stringEncoding = [YTKNetworkUtils stringEncodingWithRequest:self]; metadata.creationDate = [NSDate date]; metadata.appVersionString = [YTKNetworkUtils appVersionString]; [NSKeyedArchiver archiveRootObject:metadata toFile:[self cacheMetadataFilePath]]; &#125; @catch (NSException *exception) &#123; YTKLog(@&quot;Save cache failed, reason = %@&quot;, exception.reason); &#125; &#125; &#125;&#125; 我们可以看到, requestCompletePreprocessor方法的任务是将响应数据保存起来，也就是做缓存。但是，缓存的保存有两个条件，一个是需要cacheTimeInSeconds方法返回正整数（缓存时间，单位是秒，后续会详细说明）；另一个条件是isDataFromCache方法返回NO。但是我们知道，如果缓存可用，就会将这个属性设置为YES，所以走到这里的时候，就不做缓存了。 接着看下5.2：requestCompleteFilter方法则是需要用户自己提供具体实现的，专门作为回调成功之前的一些处理： 123//YTKBaseRequest.m- (void)requestCompleteFilter &#123;&#125; 到这里，回调之前的处理都结束了，下面来看一下在缓存可用的情况下的回调： 123456789101112131415161718//YTKRequest.m- (void)start&#123; ... YTKRequest *strongSelf = self; //6. 执行回调 //6.1 请求完成的代理 [strongSelf.delegate requestFinished:strongSelf]; //6.2 请求成功的block if (strongSelf.successCompletionBlock) &#123; strongSelf.successCompletionBlock(strongSelf); &#125; //7. 把成功和失败的block都设置为nil，避免循环引用 [strongSelf clearCompletionBlock];&#125; 我们可以看到 ，这里面同时存在两种回调：代理的回调和block的回调。先执行的是代理的回调，然后执行的是block的回调。而且在回调结束之后，YTKNetwork会帮助我们清空回调的block： 123456//YTKBaseRequest.m- (void)clearCompletionBlock &#123; // 清空请求结束的block，避免循环引用 self.successCompletionBlock = nil; self.failureCompletionBlock = nil;&#125; 注意，在用户同时实现了代理和block的情况下，二者都会被调用。 到这里，我们了解了YTKNetwork在网络请求之前是如何验证缓存，以及在缓存有效的情况下是如何回调的。 反过来，如果缓存无效（或忽略缓存）时，需要立即请求网络。那么我们现在来看一看在这个时候YTKNetwork都做了什么： 仔细看一下上面的start方法，我们会发现，如果缓存不满足条件时，会直接调用startWithoutCache方法： 1234567891011121314151617181920//YTKRequest.m- (void)start&#123; //1. 如果忽略缓存 -&gt; 请求 if (self.ignoreCache) &#123; [self startWithoutCache]; return; &#125; //2. 如果存在下载未完成的文件 -&gt; 请求 if (self.resumableDownloadPath) &#123; [self startWithoutCache]; return; &#125; //3. 获取缓存失败 -&gt; 请求 if (![self loadCacheWithError:nil]) &#123; [self startWithoutCache]; return; &#125; ......&#125; 那么在startWithoutCache方法里都做了什么呢？ 123456789101112131415161718//YTKRequest.m- (void)startWithoutCache &#123; //1. 清除缓存 [self clearCacheVariables]; //2. 调用父类的发起请求 [super start];&#125;//清除当前请求对应的所有缓存- (void)clearCacheVariables &#123; _cacheData = nil; _cacheXML = nil; _cacheJSON = nil; _cacheString = nil; _cacheMetadata = nil; _dataFromCache = NO;&#125; 在这里，首先清除了关于缓存的所有数据，然后调用父类的start方法: 12345678//YTKBaseRequest.m:- (void)start &#123; //1. 告诉Accessories即将回调了（其实是即将发起请求） [self toggleAccessoriesWillStartCallBack]; //2. 令agent添加请求并发起请求，在这里并不是组合关系，agent只是一个单例 [[YTKNetworkAgent sharedAgent] addRequest:self];&#125; 第一步里的Accessories是一些遵从代理的对象。这个代理定义了一些用来追踪请求状况的方法。它被定义在了YTKBaseRequest.h文件里： 123456789101112131415161718//用来跟踪请求的状态的代理。@protocol YTKRequestAccessory &lt;NSObject&gt;@optional/// Inform the accessory that the request is about to start.////// @param request The corresponding request.- (void)requestWillStart:(id)request;/// Inform the accessory that the request is about to stop. This method is called/// before executing `requestFinished` and `successCompletionBlock`.////// @param request The corresponding request.- (void)requestWillStop:(id)request;/// Inform the accessory that the request has already stoped. This method is called/// after executing `requestFinished` and `successCompletionBlock`.////// @param request The corresponding request.- (void)requestDidStop:(id)request;@end 所以只要某个对象遵从了这个代理，就可以追踪到请求将要开始，将要结束，已经结束的状态。 接着看一下第二步：YTKNetworkAgent把当前的请求对象添加到了自己身上并发送请求。来看一下它的具体实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//YTKNetworkAgent.m- (void)addRequest:(YTKBaseRequest *)request &#123; //1. 获取task NSParameterAssert(request != nil); NSError * __autoreleasing requestSerializationError = nil; //获取用户自定义的requestURL NSURLRequest *customUrlRequest= [request buildCustomUrlRequest]; if (customUrlRequest) &#123; __block NSURLSessionDataTask *dataTask = nil; //如果存在用户自定义request，则直接走AFNetworking的dataTaskWithRequest:方法 dataTask = [_manager dataTaskWithRequest:customUrlRequest completionHandler:^(NSURLResponse * _Nonnull response, id _Nullable responseObject, NSError * _Nullable error) &#123; //响应的统一处理 [self handleRequestResult:dataTask responseObject:responseObject error:error]; &#125;]; request.requestTask = dataTask; &#125; else &#123; //如果用户没有自定义url，则直接走这里 request.requestTask = [self sessionTaskForRequest:request error:&amp;requestSerializationError]; &#125; //序列化失败，则认定为请求失败 if (requestSerializationError) &#123; //请求失败的处理 [self requestDidFailWithRequest:request error:requestSerializationError]; return; &#125; NSAssert(request.requestTask != nil, @&quot;requestTask should not be nil&quot;); // 优先级的映射 // !!Available on iOS 8 + if ([request.requestTask respondsToSelector:@selector(priority)]) &#123; switch (request.requestPriority) &#123; case YTKRequestPriorityHigh: request.requestTask.priority = NSURLSessionTaskPriorityHigh; break; case YTKRequestPriorityLow: request.requestTask.priority = NSURLSessionTaskPriorityLow; break; case YTKRequestPriorityDefault: /*!!fall through*/ default: request.requestTask.priority = NSURLSessionTaskPriorityDefault; break; &#125; &#125; // Retain request YTKLog(@&quot;Add request: %@&quot;, NSStringFromClass([request class])); //2. 将request放入保存请求的字典中，taskIdentifier为key，request为值 [self addRequestToRecord:request]; //3. 开始task [request.requestTask resume];&#125; 这个方法挺长的，但是请不要被吓到，它总共分为三个部分： 第一部分是获取当前请求对应的task并赋给request的requestTask属性（以后提到的request，都为用户自定义的当前请求类的实例）。 第二部分是把request放入专门用来保存请求的字典中，key为taskIdentifier。 第三部分是启动task。 下面我来依次讲解每个部分： 第一部分：获取当前请求对应的task并赋给request： 123456789101112131415161718192021//YTKNetworkAgent.m- (void)addRequest:(YTKBaseRequest *)request &#123; ... if (customUrlRequest) &#123; __block NSURLSessionDataTask *dataTask = nil; //如果存在用户自定义request，则直接走AFNetworking的dataTaskWithRequest:方法 dataTask = [_manager dataTaskWithRequest:customUrlRequest completionHandler:^(NSURLResponse * _Nonnull response, id _Nullable responseObject, NSError * _Nullable error) &#123; //统一处理请求响应 [self handleRequestResult:dataTask responseObject:responseObject error:error]; &#125;]; request.requestTask = dataTask; &#125; else &#123; //如果用户没有自定义url，则直接走这里 request.requestTask = [self sessionTaskForRequest:request error:&amp;requestSerializationError]; &#125; ...&#125; 在这里判断了用户是否自定义了request： 如果是，则直接调用AFNetworking的dataTaskWithRequest:方法。 如果不是，则调用YTKRequest自己的生成task的方法。 第一种情况就不说了，因为AF帮我们做好了。在这里看一下第二种情况，sessionTaskForRequest: error :方法内部： 从这个方法最后的switch语句可以看出，这个方法的作用是返回当前request的NSURLSessionTask的实例。而且最终生成NSURLSessionTask实例的方法都是通过dataTaskWithHTTPMethod:requestSerializer:URLString:parameters:error:这个私有方法来实现的。在讲解这个关键的私有方法之前，先来逐步讲解一下这个私有方法需要的每个参数的获取方法： 获得请求类型（GET，POST等）： 123456//YTKNetworkAgent.m- (NSURLSessionTask *)sessionTaskForRequest:(YTKBaseRequest *)request error:(NSError * _Nullable __autoreleasing *)error &#123; ... YTKRequestMethod method = [request requestMethod]; ...&#125; requestMethod方法最初在YTKBaseRequest里面已经实现了，默认返回了YTKRequestMethodGET。 它的枚举类型在YTKBaseRequest.h里面定义： 12345678910//YTKBaseRequest.h/// HTTP Request method.typedef NS_ENUM(NSInteger, YTKRequestMethod) &#123; YTKRequestMethodGET = 0, YTKRequestMethodPOST, YTKRequestMethodHEAD, YTKRequestMethodPUT, YTKRequestMethodDELETE, YTKRequestMethodPATCH,&#125;; 用户可以根据实际的需求在自定义request类里面重写这个方法： 1234//RegisterAPI.m- (YTKRequestMethod)requestMethod &#123; return YTKRequestMethodPOST;&#125; 获得请求url： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//YTKNetworkAgent.m- (NSURLSessionTask *)sessionTaskForRequest:(YTKBaseRequest *)request error:(NSError * _Nullable __autoreleasing *)error &#123; ... NSString *url = [self buildRequestUrl:request]; ...&#125;//返回当前请求url- (NSString *)buildRequestUrl:(YTKBaseRequest *)request &#123; NSParameterAssert(request != nil); //用户自定义的url（不包括在YTKConfig里面设置的base_url） NSString *detailUrl = [request requestUrl]; NSURL *temp = [NSURL URLWithString:detailUrl]; // 存在host和scheme的url立即返回正确 if (temp &amp;&amp; temp.host &amp;&amp; temp.scheme) &#123; return detailUrl; &#125; // 如果需要过滤url，则过滤 NSArray *filters = [_config urlFilters]; for (id&lt;YTKUrlFilterProtocol&gt; f in filters) &#123; detailUrl = [f filterUrl:detailUrl withRequest:request]; &#125; NSString *baseUrl; if ([request useCDN]) &#123; //如果使用CDN，在当前请求没有配置CDN地址的情况下，返回全局配置的CDN if ([request cdnUrl].length &gt; 0) &#123; baseUrl = [request cdnUrl]; &#125; else &#123; baseUrl = [_config cdnUrl]; &#125; &#125; else &#123; //如果使用baseUrl，在当前请求没有配置baseUrl，返回全局配置的baseUrl if ([request baseUrl].length &gt; 0) &#123; baseUrl = [request baseUrl]; &#125; else &#123; baseUrl = [_config baseUrl]; &#125; &#125; // 如果末尾没有/，则在末尾添加一个／ NSURL *url = [NSURL URLWithString:baseUrl]; if (baseUrl.length &gt; 0 &amp;&amp; ![baseUrl hasSuffix:@&quot;/&quot;]) &#123; url = [url URLByAppendingPathComponent:@&quot;&quot;]; &#125; return [NSURL URLWithString:detailUrl relativeToURL:url].absoluteString;&#125; 获得请求参数 123456789//YTKNetworkAgent.m- (NSURLSessionTask *)sessionTaskForRequest:(YTKBaseRequest *)request error:(NSError * _Nullable __autoreleasing *)error &#123; ... //获取用户提供的请求参数 id param = request.requestArgument; //获取用户提供的构造请求体的block（默认是没有的） AFConstructingBlock constructingBlock = [request constructingBodyBlock]; ...&#125; 在这里，requestArgument是一个get方法，需要用户自己定义请求体，例如在RegisterAPI里面就定义了两个请求参数： 1234567//RegisterApi.m- (id)requestArgument &#123; return @&#123; @&quot;username&quot;: _username, @&quot;password&quot;: _password &#125;;&#125; 获得request serializer 123456789101112131415161718192021222324252627282930313233343536373839//YTKNetworkAgent.m- (NSURLSessionTask *)sessionTaskForRequest:(YTKBaseRequest *)request error:(NSError * _Nullable __autoreleasing *)error &#123; ... //4. 获得request serializer AFHTTPRequestSerializer *requestSerializer = [self requestSerializerForRequest:request]; ...&#125;- (AFHTTPRequestSerializer *)requestSerializerForRequest:(YTKBaseRequest *)request &#123; AFHTTPRequestSerializer *requestSerializer = nil; //HTTP or JSON if (request.requestSerializerType == YTKRequestSerializerTypeHTTP) &#123; requestSerializer = [AFHTTPRequestSerializer serializer]; &#125; else if (request.requestSerializerType == YTKRequestSerializerTypeJSON) &#123; requestSerializer = [AFJSONRequestSerializer serializer]; &#125; //超时时间 requestSerializer.timeoutInterval = [request requestTimeoutInterval]; //是否允许数据服务 requestSerializer.allowsCellularAccess = [request allowsCellularAccess]; //如果当前请求需要验证 NSArray&lt;NSString *&gt; *authorizationHeaderFieldArray = [request requestAuthorizationHeaderFieldArray]; if (authorizationHeaderFieldArray != nil) &#123; [requestSerializer setAuthorizationHeaderFieldWithUsername:authorizationHeaderFieldArray.firstObject password:authorizationHeaderFieldArray.lastObject]; &#125; //如果当前请求需要自定义 HTTPHeaderField NSDictionary&lt;NSString *, NSString *&gt; *headerFieldValueDictionary = [request requestHeaderFieldValueDictionary]; if (headerFieldValueDictionary != nil) &#123; for (NSString *httpHeaderField in headerFieldValueDictionary.allKeys) &#123; NSString *value = headerFieldValueDictionary[httpHeaderField]; [requestSerializer setValue:value forHTTPHeaderField:httpHeaderField]; &#125; &#125; return requestSerializer;&#125; 上面这个方法通过传入的request实例，根据它的一些配置（用户提供）来获取AFHTTPRequestSerializer的实例。 到现在为止，获取NSURLSessionTask实例的几个参数都拿到了，剩下的就是调用dataTaskWithHTTPMethod:requestSerializer:URLString:parameters:error:方法来获取NSURLSessionTask实例了。我们来看一下这个方法的具体实现： 12345678910111213141516171819202122232425262728293031//YTKNetworkAgent.m- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method requestSerializer:(AFHTTPRequestSerializer *)requestSerializer URLString:(NSString *)URLString parameters:(id)parameters error:(NSError * _Nullable __autoreleasing *)error &#123; return [self dataTaskWithHTTPMethod:method requestSerializer:requestSerializer URLString:URLString parameters:parameters constructingBodyWithBlock:nil error:error];&#125;//最终返回NSURLSessionDataTask实例- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method requestSerializer:(AFHTTPRequestSerializer *)requestSerializer URLString:(NSString *)URLString parameters:(id)parameters constructingBodyWithBlock:(nullable void (^)(id &lt;AFMultipartFormData&gt; formData))block error:(NSError * _Nullable __autoreleasing *)error &#123; NSMutableURLRequest *request = nil; //根据有无构造请求体的block的情况来获取request if (block) &#123; request = [requestSerializer multipartFormRequestWithMethod:method URLString:URLString parameters:parameters constructingBodyWithBlock:block error:error]; &#125; else &#123; request = [requestSerializer requestWithMethod:method URLString:URLString parameters:parameters error:error]; &#125; //获得request以后来获取dataTask __block NSURLSessionDataTask *dataTask = nil; dataTask = [_manager dataTaskWithRequest:request completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *_error) &#123; //响应的统一处理 [self handleRequestResult:dataTask responseObject:responseObject error:_error]; &#125;]; return dataTask;&#125; 这两个方法，上面的方法调用了下面的来获取最终的NSURLSessionDataTask实例。 OK，现在我们已经知道了NSURLSessionDataTask实例是如何获取的，再来看一下在addRequest：方法里接下来做的是对序列化失败的处理： 123456789101112//YTKNetworkAgent.m- (void)addRequest:(YTKBaseRequest *)request &#123; ... //序列化失败 if (requestSerializationError) &#123; //请求失败的处理 [self requestDidFailWithRequest:request error:requestSerializationError]; return; &#125; ...&#125; requestDidFailWithRequest:方法专门处理请求失败的情况，因为它被包含在统一处理请求回调的方法中，所以在稍后会在讲解统一处理请求回调的方法的时候再详细讲解这个方法。 继续往下走，到了优先级的映射部分： 1234567891011121314151617181920212223//YTKNetworkAgent.m- (void)addRequest:(YTKBaseRequest *)request &#123; ... // 优先级的映射 // !!Available on iOS 8 + if ([request.requestTask respondsToSelector:@selector(priority)]) &#123; switch (request.requestPriority) &#123; case YTKRequestPriorityHigh: request.requestTask.priority = NSURLSessionTaskPriorityHigh; break; case YTKRequestPriorityLow: request.requestTask.priority = NSURLSessionTaskPriorityLow; break; case YTKRequestPriorityDefault: /*!!fall through*/ default: request.requestTask.priority = NSURLSessionTaskPriorityDefault; break; &#125; &#125; ...&#125; requestPriority是YTKBaseRequest的一个枚举属性，它的枚举在YTKBaseRequest.h里面被定义： 12345typedef NS_ENUM(NSInteger, YTKRequestPriority) &#123; YTKRequestPriorityLow = -4L, YTKRequestPriorityDefault = 0, YTKRequestPriorityHigh = 4,&#125;; 在这里，将用户设置的YTKRequestPriority映射到NSURLSessionTask的priority上。 到这里，我们拿到了task的实例并设置好了优先级，紧接着就是addRequest:方法里的第二个部分：YTKNetworkAgent将request实例放在了一个字典中，保存起来： 第二部分：把request放入专门用来保存请求的字典中，key为taskIdentifier： 123456789101112131415161718//YTKNetworkAgent.m- (void)addRequest:(YTKBaseRequest *)request &#123; ... ... //将request实例放入保存请求的字典中，taskIdentifier为key，request为值 [self addRequestToRecord:request]; ...&#125;- (void)addRequestToRecord:(YTKBaseRequest *)request &#123; //加锁 Lock(); _requestsRecord[@(request.requestTask.taskIdentifier)] = request; Unlock();&#125;#define Lock() pthread_mutex_lock(&amp;_lock)#define Unlock() pthread_mutex_unlock(&amp;_lock) 可以看到，在添加前和添加后是进行了加锁和解锁的处理的。而且request实例被保存的时候，将其task的identifier作为key来保存。 在当前的request被保存以后，就到了最后一步，正式发起请求： 第三部分：启动task 1234567//YTKNetworkAgent.m- (NSURLSessionTask *)sessionTaskForRequest:(YTKBaseRequest *)request error:(NSError * _Nullable __autoreleasing *)error &#123; ... [request.requestTask resume]; ...&#125; 到现在为止，我们了解了YTKNetwork里面，一个请求开始之前做的事情：查找可用缓存，生成NSURLSessionTask实例，获取url，requestSerializer，将request放到YTKNetworkAgent的一个字典里等等（详细流程会在稍后给出）。 那么接下来我们看一下YTKNetwork是如何处理请求的回调的。 眼尖的同学们可能会注意到，在获取NSURLSessionTask实例的时候，出现了两次“响应的统一处理”的注释，大家可以搜索这个注释就可以找到这个方法：handleRequestResult:responseObject:error:。这个方法负责的是对请求回调的处理，当然包括了成功和失败的情况。我们来看一下在这个方法里都做了什么： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//YTKNetworkAgent.m//统一处理请求结果，包括成功和失败的情况- (void)handleRequestResult:(NSURLSessionTask *)task responseObject:(id)responseObject error:(NSError *)error &#123; //1. 获取task对应的request Lock(); YTKBaseRequest *request = _requestsRecord[@(task.taskIdentifier)]; Unlock(); //如果不存在对应的request，则立即返回 if (!request) &#123; return; &#125; 。。。 //2. 获取request对应的response request.responseObject = responseObject; //3. 获取responseObject，responseData和responseString if ([request.responseObject isKindOfClass:[NSData class]]) &#123; //3.1 获取 responseData request.responseData = responseObject; //3.2 获取responseString request.responseString = [[NSString alloc] initWithData:responseObject encoding:[YTKNetworkUtils stringEncodingWithRequest:request]]; //3.3 获取responseObject（或responseJSONObject） //根据返回的响应的序列化的类型来得到对应类型的响应 switch (request.responseSerializerType) &#123; case YTKResponseSerializerTypeHTTP: // Default serializer. Do nothing. break; case YTKResponseSerializerTypeJSON: request.responseObject = [self.jsonResponseSerializer responseObjectForResponse:task.response data:request.responseData error:&amp;serializationError]; request.responseJSONObject = request.responseObject; break; case YTKResponseSerializerTypeXMLParser: request.responseObject = [self.xmlParserResponseSerialzier responseObjectForResponse:task.response data:request.responseData error:&amp;serializationError]; break; &#125; &#125; //4. 判断是否有错误，将错误对象赋值给requestError，改变succeed的布尔值。目的是根据succeed的值来判断到底是进行成功的回调还是失败的回调 if (error) &#123; //如果该方法传入的error不为nil succeed = NO; requestError = error; &#125; else if (serializationError) &#123; //如果序列化失败了 succeed = NO; requestError = serializationError; &#125; else &#123; //即使没有error而且序列化通过，也要验证request是否有效 succeed = [self validateResult:request error:&amp;validationError]; requestError = validationError; &#125; //5. 根据succeed的布尔值来调用相应的处理 if (succeed) &#123; //请求成功的处理 [self requestDidSucceedWithRequest:request]; &#125; else &#123; //请求失败的处理 [self requestDidFailWithRequest:request error:requestError]; &#125; //6. 回调完成的处理 dispatch_async(dispatch_get_main_queue(), ^&#123; //6.1 在字典里移除当前request [self removeRequestFromRecord:request]; //6.2 清除所有block [request clearCompletionBlock]; &#125;);&#125; 简单讲解一下上面的代码： 首先通过task的identifier值从YTKNetworkAgent保存的字典里获取对应的请求。 然后将获得的responseObject进行处理，将处理后获得的responseObject，responseData和responseString赋值给当前的请求实例request。 再根据这些值的获取情况来判断最终回调的成败（改变succeed的值）。 最后根据succeed的值来进行成功和失败的回调。 这里先重点介绍一下是如何判断json的有效性的： 1234567891011121314151617181920212223242526272829303132//YTKNetworkAgent.m//判断code是否符合范围和json的有效性- (BOOL)validateResult:(YTKBaseRequest *)request error:(NSError * _Nullable __autoreleasing *)error &#123; //1. 判断code是否在200~299之间 BOOL result = [request statusCodeValidator]; if (!result) &#123; if (error) &#123; *error = [NSError errorWithDomain:YTKRequestValidationErrorDomain code:YTKRequestValidationErrorInvalidStatusCode userInfo:@&#123;NSLocalizedDescriptionKey:@&quot;Invalid status code&quot;&#125;]; &#125; return result; &#125; //2. result 存在的情况判断json是否有效 id json = [request responseJSONObject]; id validator = [request jsonValidator]; if (json &amp;&amp; validator) &#123; //通过json和validator来判断json是否有效 result = [YTKNetworkUtils validateJSON:json withValidator:validator]; //如果json无效 if (!result) &#123; if (error) &#123; *error = [NSError errorWithDomain:YTKRequestValidationErrorDomain code:YTKRequestValidationErrorInvalidJSONFormat userInfo:@&#123;NSLocalizedDescriptionKey:@&quot;Invalid JSON format&quot;&#125;]; &#125; return result; &#125; &#125; return YES;&#125; 在这里，首先，用statusCodeValidator方法判断响应的code是否在正确的范围: 12345678//YTKBaseReqiest.m- (BOOL)statusCodeValidator &#123; NSInteger statusCode = [self responseStatusCode]; return (statusCode &gt;= 200 &amp;&amp; statusCode &lt;= 299);&#125;- (NSInteger)responseStatusCode &#123; return self.response.statusCode;&#125; 然后再判断json的有效性： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//YTKNetworkUtils.m//判断json的有效性+ (BOOL)validateJSON:(id)json withValidator:(id)jsonValidator &#123; if ([json isKindOfClass:[NSDictionary class]] &amp;&amp; [jsonValidator isKindOfClass:[NSDictionary class]]) &#123; NSDictionary * dict = json; NSDictionary * validator = jsonValidator; BOOL result = YES; NSEnumerator * enumerator = [validator keyEnumerator]; NSString * key; while ((key = [enumerator nextObject]) != nil) &#123; id value = dict[key]; id format = validator[key]; if ([value isKindOfClass:[NSDictionary class]] || [value isKindOfClass:[NSArray class]]) &#123; result = [self validateJSON:value withValidator:format]; if (!result) &#123; break; &#125; &#125; else &#123; if ([value isKindOfClass:format] == NO &amp;&amp; [value isKindOfClass:[NSNull class]] == NO) &#123; result = NO; break; &#125; &#125; &#125; return result; &#125; else if ([json isKindOfClass:[NSArray class]] &amp;&amp; [jsonValidator isKindOfClass:[NSArray class]]) &#123; NSArray * validatorArray = (NSArray *)jsonValidator; if (validatorArray.count &gt; 0) &#123; NSArray * array = json; NSDictionary * validator = jsonValidator[0]; for (id item in array) &#123; BOOL result = [self validateJSON:item withValidator:validator]; if (!result) &#123; return NO; &#125; &#125; &#125; return YES; &#125; else if ([json isKindOfClass:jsonValidator]) &#123; return YES; &#125; else &#123; return NO; &#125;&#125; 注意，YTKNetworkUtils这个类是在YTKNetworkPirvate里面定义的，YTKNetworkPirvate里面有一些工具类的方法，在后面还会遇到。 在验证返回的JSON数据是否有效以后，就可以进行回调了： 123456789101112131415161718192021//YTKNetworkAgent.m- (void)handleRequestResult:(NSURLSessionTask *)task responseObject:(id)responseObject error:(NSError *)error &#123; ... //5. 根据succeed的布尔值来调用相应的处理 if (succeed) &#123; //请求成功的处理 [self requestDidSucceedWithRequest:request]; &#125; else &#123; //请求失败的处理 [self requestDidFailWithRequest:request error:requestError]; &#125; //6. 回调完成的处理 dispatch_async(dispatch_get_main_queue(), ^&#123; //6.1 在字典里移除当前request [self removeRequestFromRecord:request]; //6.2 清除所有block [request clearCompletionBlock]; &#125;); ...&#125; 我们先来分别看一下请求成功的处理和失败的处理： 请求成功的处理： 123456789101112131415161718192021222324252627282930//YTKNetworkAgent.m//请求成功：主要负责将结果写入缓存&amp;回调成功的代理和block- (void)requestDidSucceedWithRequest:(YTKBaseRequest *)request &#123; @autoreleasepool &#123; //写入缓存 [request requestCompletePreprocessor]; &#125; dispatch_async(dispatch_get_main_queue(), ^&#123; //告诉Accessories请求就要停止了 [request toggleAccessoriesWillStopCallBack]; //在真正的回调之前做的处理,用户自定义 [request requestCompleteFilter]; //如果有代理，则调用成功的代理 if (request.delegate != nil) &#123; [request.delegate requestFinished:request]; &#125; //如果传入了成功回调的代码，则调用 if (request.successCompletionBlock) &#123; request.successCompletionBlock(request); &#125; //告诉Accessories请求已经结束了 [request toggleAccessoriesDidStopCallBack]; &#125;);&#125; 我么可以看到，在请求成功以后，第一个做的是写入缓存，我们来看一下requestCompletePreprocessor方法的实现： 12345678910111213141516171819202122232425262728293031323334353637383940//YTKRequest.m- (void)requestCompletePreprocessor &#123; [super requestCompletePreprocessor]; //是否异步将responseData写入缓存（写入缓存的任务放在专门的队列进行） if (self.writeCacheAsynchronously) &#123; dispatch_async(ytkrequest_cache_writing_queue(), ^&#123; //写入缓存文件 [self saveResponseDataToCacheFile:[super responseData]]; &#125;); &#125; else &#123; //写入缓存文件 [self saveResponseDataToCacheFile:[super responseData]]; &#125;&#125;//写入缓存文件- (void)saveResponseDataToCacheFile:(NSData *)data &#123; if ([self cacheTimeInSeconds] &gt; 0 &amp;&amp; ![self isDataFromCache]) &#123; if (data != nil) &#123; @try &#123; // 1. 保存request的responseData到cacheFilePath [data writeToFile:[self cacheFilePath] atomically:YES]; // 2. 保存request的metadata到cacheMetadataFilePath YTKCacheMetadata *metadata = [[YTKCacheMetadata alloc] init]; metadata.version = [self cacheVersion]; metadata.sensitiveDataString = ((NSObject *)[self cacheSensitiveData]).description; metadata.stringEncoding = [YTKNetworkUtils stringEncodingWithRequest:self]; metadata.creationDate = [NSDate date]; metadata.appVersionString = [YTKNetworkUtils appVersionString]; [NSKeyedArchiver archiveRootObject:metadata toFile:[self cacheMetadataFilePath]]; &#125; @catch (NSException *exception) &#123; YTKLog(@&quot;Save cache failed, reason = %@&quot;, exception.reason); &#125; &#125; &#125;&#125; 首先看一下写入缓存操作的执行条件：当cacheTimeInSeconds方法返回大于0并且isDataFromCache为NO的时候会进行写入缓存。 cacheTimeInSeconds方法返回的是缓存保存的时间，它最初定义在YTKBaseRquest里面，默认返回是-1： 1234//YTKBaseRequest.m- (NSInteger)cacheTimeInSeconds &#123; return -1;&#125; 所以说YTKNetwork默认是不进行缓存的，如果用户需要做缓存，则需要在自定义的request类里面返回一个大于0的整数，这个整数的单位是秒。 isDataFromCache属性在上面讲解发送请求部分里的查询缓存的步骤里有介绍。在这里再强调一下：isDataFromCache的默认值是NO。在请求发起之前，-查询缓存的时候： 如果发现缓存不可用（或忽略缓存），则立即发送请求，这个时候，isDataFromCache的值不做更改，仍然是NO。 如果发现缓存可用（在不忽略缓存的情况下），就要将isDataFromCache属性设置为YES，说明将不需要发送请求，直接在里获取数据了。 即是说，如果发送了请求，则isDataFromCache一定是NO的，那么在上面这个判断里面，(!isDataFromCache)就一定为YES了。 因此，如果用户设置了缓存保存的时间，在请求返回成功后，就会写入缓存。 我们接着往下看，对于缓存，YTKNetwork保存的是两种缓存：第一种是纯粹的NSData类型的实例。第二种是描述当前NSData实例的元数据YTKCacheMetadata的实例，从它的属性来看，分为这几种： 缓存的版本，默认返回为0，用户可以自定义。 敏感数据，类型为id，默认返回nil，用户可以自定义。 NSString的编码格式，在YTKNetworkPrivate内的YTKNetworkUtils实现。 元数据的创建时间。 app的版本号，在YTKNetworkPrivate内的YTKNetworkUtils实现。 在将元数据的实例的这些属性都被赋值以后，将元数据实例序列化写入磁盘中。保存的路径通过cacheMetadataFilePath方法获取。 现在知道了YTKRequest的缓存内容，我们来看一下这两种缓存的位置： 12345678910111213141516171819202122232425262728293031323334353637383940414243//YTKRequest.m//纯NSData数据缓存的文件名- (NSString *)cacheFileName &#123; NSString *requestUrl = [self requestUrl]; NSString *baseUrl = [YTKNetworkConfig sharedConfig].baseUrl; id argument = [self cacheFileNameFilterForRequestArgument:[self requestArgument]]; NSString *requestInfo = [NSString stringWithFormat:@&quot;Method:%ld Host:%@ Url:%@ Argument:%@&quot;, (long)[self requestMethod], baseUrl, requestUrl, argument]; NSString *cacheFileName = [YTKNetworkUtils md5StringFromString:requestInfo]; return cacheFileName;&#125;//纯NSData数据的缓存位置- (NSString *)cacheFilePath &#123; NSString *cacheFileName = [self cacheFileName]; NSString *path = [self cacheBasePath]; path = [path stringByAppendingPathComponent:cacheFileName]; return path;&#125;//元数据的缓存位置- (NSString *)cacheMetadataFilePath &#123; NSString *cacheMetadataFileName = [NSString stringWithFormat:@&quot;%@.metadata&quot;, [self cacheFileName]]; NSString *path = [self cacheBasePath]; path = [path stringByAppendingPathComponent:cacheMetadataFileName]; return path;&#125;//创建用户保存所有YTKNetwork缓存的文件夹- (NSString *)cacheBasePath &#123; //获取全路径 NSString *pathOfLibrary = [NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES) objectAtIndex:0]; NSString *path = [pathOfLibrary stringByAppendingPathComponent:@&quot;LazyRequestCache&quot;]; // YTKCacheDirPathFilterProtocol定义了用户可以自定义存储位置的代理方法 NSArray&lt;id&lt;YTKCacheDirPathFilterProtocol&gt;&gt; *filters = [[YTKNetworkConfig sharedConfig] cacheDirPathFilters]; if (filters.count &gt; 0) &#123; for (id&lt;YTKCacheDirPathFilterProtocol&gt; f in filters) &#123; path = [f filterCacheDirPath:path withRequest:self]; &#125; &#125; //创建文件夹 [self createDirectoryIfNeeded:path]; return path;&#125; 可以看出，纯NSData数据缓存的文件名包含了请求方法（GET,POST..），baseURL，requestURL，请求参数拼接的字符串再进行md5加密而成。 而元数据的的文件名则在纯NSData数据缓存的文件名后面加上了.metadata后缀。 为了更形象地看到这两种缓存，我将缓存的保存时间设置为200秒之后再请求一次，然后打开文件夹找到了它们： 而且我们也确认了保存所有YTKNetwork缓存的文件夹的名字为LazyRequestCache。 OK，现在我们知道了在请求成功回调后的缓存写入，接下来看一下是如何回调的： 1234567891011121314//YTKNetworkAgent.m- (void)handleRequestResult:(NSURLSessionTask *)task responseObject:(id)responseObject error:(NSError *)error &#123; ... YTKRequest *strongSelf = self; //6. 执行回调 //6.1 请求完成的代理 [strongSelf.delegate requestFinished:strongSelf]; //6.2 请求成功的block if (strongSelf.successCompletionBlock) &#123; strongSelf.successCompletionBlock(strongSelf); &#125; //7. 把成功和失败的block都设置为nil，避免循环引用 [strongSelf clearCompletionBlock];&#125; 我们可以看到,代理的回调是先于block的回调的。而且在block回调结束以后，会立即调用clearCompletionBlock方法将block清空。该方法的实现是在YTKBaseRequest里： 123456//YTKBaseRequest.m- (void)clearCompletionBlock &#123; // 清空请求结束的block，避免循环引用 self.successCompletionBlock = nil; self.failureCompletionBlock = nil;&#125; 现在我们知道了请求成功的处理，那么再来看一下请求失败时的处理： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//YTKNetworkAgent.m//请求失败- (void)requestDidFailWithRequest:(YTKBaseRequest *)request error:(NSError *)error &#123; request.error = error; YTKLog(@&quot;Request %@ failed, status code = %ld, error = %@&quot;, NSStringFromClass([request class]), (long)request.responseStatusCode, error.localizedDescription); // 储存未完成的下载数据 NSData *incompleteDownloadData = error.userInfo[NSURLSessionDownloadTaskResumeData]; if (incompleteDownloadData) &#123; [incompleteDownloadData writeToURL:[self incompleteDownloadTempPathForDownloadPath:request.resumableDownloadPath] atomically:YES]; &#125; // Load response from file and clean up if download task failed. //如果下载任务失败，则取出对应的响应文件并清空 if ([request.responseObject isKindOfClass:[NSURL class]]) &#123; NSURL *url = request.responseObject; //isFileURL：是否是文件，如果是，则可以再isFileURL获取；&amp;&amp;后面是再次确认是否存在改url对应的文件 if (url.isFileURL &amp;&amp; [[NSFileManager defaultManager] fileExistsAtPath:url.path]) &#123; //将url的data和string赋给request request.responseData = [NSData dataWithContentsOfURL:url]; request.responseString = [[NSString alloc] initWithData:request.responseData encoding:[YTKNetworkUtils stringEncodingWithRequest:request]]; [[NSFileManager defaultManager] removeItemAtURL:url error:nil]; &#125; //清空request request.responseObject = nil; &#125; @autoreleasepool &#123; //请求失败的预处理，YTK没有定义，需要用户定义 [request requestFailedPreprocessor]; &#125; dispatch_async(dispatch_get_main_queue(), ^&#123; //告诉Accessories请求就要停止了 [request toggleAccessoriesWillStopCallBack]; //在真正的回调之前做的处理 [request requestFailedFilter]; //如果有代理，就调用代理 if (request.delegate != nil) &#123; [request.delegate requestFailed:request]; &#125; //如果传入了失败回调的block代码，就调用block if (request.failureCompletionBlock) &#123; request.failureCompletionBlock(request); &#125; //告诉Accessories请求已经停止了 [request toggleAccessoriesDidStopCallBack]; &#125;);&#125; 在这个方法里，首先判断了当前任务是否为下载任务，如果是，则储存当前已经下载好的data到resumableDownloadPath里面。而如果下载任务失败，则将其对应的在本地保存的路径上的文件清空。 到这里，我已经把单个请求从配置，发送，响应，回调的步骤都讲解完了。为了帮助大家理解整个过程，这里提供了整个的流程图： 我们说YTKNetworkAgent是请求的发送者，既然有发送，也就会有取消等操作，这就不得不提它的另外两个接口： 12345//YTKNetworkAgent.h/// 取消某个request- (void)cancelRequest:(YTKBaseRequest *)request;/// 取消所有添加的request- (void)cancelAllRequests; 首先我们看下取消某个request这个方法的实现： 1234567891011121314151617181920//YTKNetworkAgent.m/// 取消某个request- (void)cancelRequest:(YTKBaseRequest *)request &#123; NSParameterAssert(request != nil); //获取request的task，并取消 [request.requestTask cancel]; //从字典里移除当前request [self removeRequestFromRecord:request]; //清理所有block [request clearCompletionBlock];&#125;//从字典里移除某request- (void)removeRequestFromRecord:(YTKBaseRequest *)request &#123; //加锁 Lock(); [_requestsRecord removeObjectForKey:@(request.requestTask.taskIdentifier)]; YTKLog(@&quot;Request queue size = %zd&quot;, [_requestsRecord count]); Unlock();&#125; 取消所有在字典里添加的request： 12345678910111213141516//YTKNetworkAgent.m- (void)cancelAllRequests &#123; Lock(); NSArray *allKeys = [_requestsRecord allKeys]; Unlock(); if (allKeys &amp;&amp; allKeys.count &gt; 0) &#123; NSArray *copiedKeys = [allKeys copy]; for (NSNumber *key in copiedKeys) &#123; Lock(); YTKBaseRequest *request = _requestsRecord[key]; Unlock(); //stop每个请求 [request stop]; &#125; &#125;&#125; 这个stop方法是在YTKBaseRequest里面定义的： 123456789101112131415//YTKBaseRequest.m- (void)stop &#123; //告诉Accessories将要回调了 [self toggleAccessoriesWillStopCallBack]; //清空代理 self.delegate = nil; //调用agent的取消某个request的方法 [[YTKNetworkAgent sharedAgent] cancelRequest:self]; //告诉Accessories回调完成了 [self toggleAccessoriesDidStopCallBack];&#125; OK，看到这里，相信你对YTKNetwork单个请求的流程有了比较好的了解了，下面我们来看一下YTKNetwork的高级功能：批量请求和链式请求。 3.3 批量请求和链式请求YTKNetwork支持的批量请求有两种： 批量请求：多个请求几乎同时发起。 链式请求：当前个请求结束后才能发起下一个请求。 其实无论是批量请求，还是链式请求，我们都可以想到很可能是用一个数组将这些请求管理了起来。那么具体是如何实现的呢？ 我们首先来看一下YTKNetwork是如何实现批量请求的。 3.31批量请求YTKNetwork 使用YTKBatchRequest类来发送无序的批量请求，它需要用一个含有YTKRequest子类的数组来初始化，并将这个数组保存起来赋给它的_requestArray实例变量： 1234567891011121314151617181920//YTKBatchRequest.m- (instancetype)initWithRequestArray:(NSArray&lt;YTKRequest *&gt; *)requestArray &#123; self = [super init]; if (self) &#123; //保存为属性 _requestArray = [requestArray copy]; //批量请求完成的数量初始化为0 _finishedCount = 0; //类型检查，所有元素都必须为YTKRequest或的它的子类，否则强制初始化失败 for (YTKRequest * req in _requestArray) &#123; if (![req isKindOfClass:[YTKRequest class]]) &#123; YTKLog(@&quot;Error, request item must be YTKRequest instance.&quot;); return nil; &#125; &#125; &#125; return self;&#125; 初始化以后，我们就可以调用start方法来发起当前YTKBatchRequest实例所管理的所有请求了： 1234567891011121314151617181920212223242526272829303132333435//YTKBatchRequest.m//batch请求开始- (void)startWithCompletionBlockWithSuccess:(void (^)(YTKBatchRequest *batchRequest))success failure:(void (^)(YTKBatchRequest *batchRequest))failure &#123; [self setCompletionBlockWithSuccess:success failure:failure]; [self start];&#125;//设置成功和失败的block- (void)setCompletionBlockWithSuccess:(void (^)(YTKBatchRequest *batchRequest))success failure:(void (^)(YTKBatchRequest *batchRequest))failure &#123; self.successCompletionBlock = success; self.failureCompletionBlock = failure;&#125;- (void)start &#123; //如果batch里第一个请求已经成功结束，则不能再start if (_finishedCount &gt; 0) &#123; YTKLog(@&quot;Error! Batch request has already started.&quot;); return; &#125; //最开始设定失败的request为nil _failedRequest = nil; //使用YTKBatchRequestAgent来管理当前的批量请求 [[YTKBatchRequestAgent sharedAgent] addBatchRequest:self]; [self toggleAccessoriesWillStartCallBack]; //遍历所有request，并开始请求 for (YTKRequest * req in _requestArray) &#123; req.delegate = self; [req clearCompletionBlock]; [req start]; &#125;&#125; 在这里，我们可以看出： 在至少完成了其中一个请求以后，调用当前YTKBatchRequest实例的start方法会立即返回，否则可以无限制start。 YTKBatchRequest的实例是需要在发起请求之前，要被添加在YTKBatchRequestAgent里的数组里： 123456//YTKBatchRequestAgent.m- (void)addBatchRequest:(YTKBatchRequest *)request &#123; @synchronized(self) &#123; [_requestArray addObject:request]; &#125;&#125; 因为是批量发送请求，所以在这里是遍历YTKBatchRequest实例的_requestArray并逐一发送请求。因为已经封装好了单个的请求，所以在这里直接start就好了。 发起请求以后，在每个请求回调的代理方法里，来判断这次批量请求是否成功。 YTKRequest子类成功的回调： 123456789101112131415161718192021222324252627282930313233//YTKBatchRequest.m#pragma mark - Network Request Delegate- (void)requestFinished:(YTKRequest *)request &#123; //某个request成功后，首先让_finishedCount + 1 _finishedCount++; //如果_finishedCount等于_requestArray的个数，则判定当前batch请求成功 if (_finishedCount == _requestArray.count) &#123; //调用即将结束的代理 [self toggleAccessoriesWillStopCallBack]; //调用请求成功的代理 if ([_delegate respondsToSelector:@selector(batchRequestFinished:)]) &#123; [_delegate batchRequestFinished:self]; &#125; //调用批量请求成功的block if (_successCompletionBlock) &#123; _successCompletionBlock(self); &#125; //清空成功和失败的block [self clearCompletionBlock]; //调用请求结束的代理 [self toggleAccessoriesDidStopCallBack]; //从YTKBatchRequestAgent里移除当前的batch [[YTKBatchRequestAgent sharedAgent] removeBatchRequest:self]; &#125;&#125; 我们可以看到，在某个请求的回调成功以后，会让成功计数+1。在+1以后，如果成功计数和当前批量请求数组里元素的个数相等，则判定当前批量请求成功，并进行当前批量请求的成功回调。 接下来我们看一下某个请求失败的处理： YTKReques子类失败的回调： 12345678910111213141516171819202122232425262728293031//YTKBatchRequest.m- (void)requestFailed:(YTKRequest *)request &#123; _failedRequest = request; //调用即将结束的代理 [self toggleAccessoriesWillStopCallBack]; //停止batch里所有的请求 for (YTKRequest *req in _requestArray) &#123; [req stop]; &#125; //调用请求失败的代理 if ([_delegate respondsToSelector:@selector(batchRequestFailed:)]) &#123; [_delegate batchRequestFailed:self]; &#125; //调用请求失败的block if (_failureCompletionBlock) &#123; _failureCompletionBlock(self); &#125; //清空成功和失败的block [self clearCompletionBlock]; //调用请求结束的代理 [self toggleAccessoriesDidStopCallBack]; //从YTKBatchRequestAgent里移除当前的batch [[YTKBatchRequestAgent sharedAgent] removeBatchRequest:self];&#125; 在这里不难看出，当前批量请求里面只要有一个request失败了，则判定当前批量请求失败。而当前批量请求失败的回调（代理和block）会传入这个失败的request的实例。而且这个失败的request会先被赋给_failedRequest这个实例变量里。 总的来说，YTKBatchRequest类用一个数组来保存当前批量请求所要处理的所有request实例。而且用一个成功计数来判定当前批量请求整体是否成功。而当前批量请求的失败则是由这些request实例里面第一个失败的实例导致的：只要有一个request回调失败了，则立即停止其他的所有请求并调用当前批量请求的失败回调。 现在讲完了批量请求的处理，我们接下来看一下链式请求的处理。 3.32链式请求和批量请求类似，处理链式请求的类是YTKChainRequest，并且用YTKChainRequestAgent单例来管理YTKChainRequest的实例。 但是和批量请求不同的是，YTKChainRequest实例的初始化是不需要传入一个含有request的数组的： 12345678910111213141516171819202122//YTKChainRequest.m- (instancetype)init &#123; self = [super init]; if (self) &#123; //下一个请求的index _nextRequestIndex = 0; //保存链式请求的数组 _requestArray = [NSMutableArray array]; //保存回调的数组 _requestCallbackArray = [NSMutableArray array]; //空回调，用来填充用户没有定义的回调block _emptyCallback = ^(YTKChainRequest *chainRequest, YTKBaseRequest *baseRequest) &#123; // do nothing &#125;; &#125; return self;&#125; 但是它提供了添加和删除request的接口： 1234567891011121314//YTKChainRequest.m//在当前chain添加request和callback- (void)addRequest:(YTKBaseRequest *)request callback:(YTKChainCallback)callback &#123; //保存当前请求 [_requestArray addObject:request]; if (callback != nil) &#123; [_requestCallbackArray addObject:callback]; &#125; else &#123; //之所以特意弄一个空的callback，是为了避免在用户没有给当前request的callback传值的情况下，造成request数组和callback数组的不对称 [_requestCallbackArray addObject:_emptyCallback]; &#125;&#125; 注意，在给YTKChainRequest实例添加request实例的同时，还可以传入回调的block。当然也可以不传，但是为了保持request数组和callback数组的对称性（因为回调的时候是需要根据request数组里的index来获取callback数组里对应的callback的），YTKNetwork给我们提供了一个空的block。 我们接着看一下链式请求的发起： 123456789101112131415161718//YTKChainRequest.m- (void)start &#123; //如果第1个请求已经结束，就不再重复start了 if (_nextRequestIndex &gt; 0) &#123; YTKLog(@&quot;Error! Chain request has already started.&quot;); return; &#125; //如果请求队列数组里面还有request，则取出并start if ([_requestArray count] &gt; 0) &#123; [self toggleAccessoriesWillStartCallBack]; //取出当前request并start [self startNextRequest]; //在当前的_requestArray添加当前的chain（YTKChainRequestAgent允许有多个chain） [[YTKChainRequestAgent sharedAgent] addChainRequest:self]; &#125; else &#123; YTKLog(@&quot;Error! Chain request array is empty.&quot;); &#125;&#125; 我们可以看到，YTKChainRequest用_nextRequestIndex来保存下一个请求的index，它的默认值是0。而它的值的累加是在当前请求结束后，发起下面的请求之前进行的。所以说，如果已经完成了请求队列里的第一个请求，就无法在启动当前的请求队列了，会立即返回。 这里startNextRequest方法比较重要：在判断请求队列数组里面还有request的话，就会调用这个方法： 12345678910111213//YTKChainRequest.m- (BOOL)startNextRequest &#123; if (_nextRequestIndex &lt; [_requestArray count]) &#123; YTKBaseRequest *request = _requestArray[_nextRequestIndex]; _nextRequestIndex++; request.delegate = self; [request clearCompletionBlock]; [request start]; return YES; &#125; else &#123; return NO; &#125;&#125; 这个方法有两个作用： 第一个作用是判断是否能进行下一个request（如果index 大于或等于 request数组的count的话就不能在request数组里取出request，因为会造成数组越界） 第二个作用是如果可以进行下一个request，则发起该request。并将_nextRequestIndex+1。 所以和批量请求不同的是，链式请求的请求队列是可以变动的，用户可以无限制地添加请求。只要请求队列里面有请求存在，则YTKChainRequest就会继续发送它们。 现在我们知道了YTKChainRequest的发送，接下来看一下回调部分: 和YTKBatchRequest相同的是，YTKChainRequest也实现了YTKRequest的代理： 12345678910111213141516171819//某个request请求成功的代理的实现//YTKChainRequest.m- (void)requestFinished:(YTKBaseRequest *)request &#123; //1. 取出当前的request和callback，进行回调 NSUInteger currentRequestIndex = _nextRequestIndex - 1; YTKChainCallback callback = _requestCallbackArray[currentRequestIndex]; callback(self, request);//注意：这个回调只是当前request的回调，而不是当前chain全部完成的回调。当前chain的回调在下面 //2. 如果不能再继续请求了，说明当前成功的request已经是chain里最后一个request，也就是说当前chain里所有的回调都成功了，即这个chain请求成功了。 if (![self startNextRequest]) &#123; [self toggleAccessoriesWillStopCallBack]; if ([_delegate respondsToSelector:@selector(chainRequestFinished:)]) &#123; [_delegate chainRequestFinished:self]; [[YTKChainRequestAgent sharedAgent] removeChainRequest:self]; &#125; [self toggleAccessoriesDidStopCallBack]; &#125;&#125; 我们可以看到，在某个request回调成功以后，会根据当前请求的index（_nextRequestIndex-1）来获取其对应的block并调用。接着，再调用startNextRequest方法来判断当前的YTKChainRequest的请求队列里面是否还有其他的请求了： 如果没有了，则调用当前YTKChainRequest的最终成功的回调。 如果还有，则发起接下来的request（按顺序）。 接下来我们再看一下某个request失败的代理的实现： 123456789101112//YTKChainRequest.m//某个reqeust请求失败的代理- (void)requestFailed:(YTKBaseRequest *)request &#123; //如果当前 chain里的某个request失败了，则判定当前chain失败。调用当前chain失败的回调 [self toggleAccessoriesWillStopCallBack]; if ([_delegate respondsToSelector:@selector(chainRequestFailed:failedBaseRequest:)]) &#123; [_delegate chainRequestFailed:self failedBaseRequest:request]; [[YTKChainRequestAgent sharedAgent] removeChainRequest:self]; &#125; [self toggleAccessoriesDidStopCallBack];&#125; 如果当前的request请求失败了，则判定当前链式请求是失败的，则立即调用当前链式请求的失败回调。 现在我们知道了链式请求的请求和回调，再来看一下链式请求的终止： 123456789101112//YTKChainRequest.m//终止当前的chain- (void)stop &#123; //首先调用即将停止的callback [self toggleAccessoriesWillStopCallBack]; //然后stop当前的请求，再清空chain里所有的请求和回掉block [self clearRequest]; //在YTKChainRequestAgent里移除当前的chain [[YTKChainRequestAgent sharedAgent] removeChainRequest:self]; //最后调用已经结束的callback [self toggleAccessoriesDidStopCallBack];&#125; 这个stop方法是可以在外部调用的，所以用户可以随时终止当前链式请求的进行。它首先调用clearReuqest方法，将当前request停止，再将请求队列数组和callback数组清空。 1234567891011//YTKChainRequest.m- (void)clearRequest &#123; //获取当前请求的index NSUInteger currentRequestIndex = _nextRequestIndex - 1; if (currentRequestIndex &lt; [_requestArray count]) &#123; YTKBaseRequest *request = _requestArray[currentRequestIndex]; [request stop]; &#125; [_requestArray removeAllObjects]; [_requestCallbackArray removeAllObjects];&#125; 然后在YTKChainRequestAgent单例里面，将自己移除掉。 4. 最后的话阅读这个框架的源码我的收获是：加深了对命令模式，对Block的理解，知道了一个网络请求都需要什么元素组成，知道了网络缓存该怎么设计，也知道了链式请求怎么设计等等。 我还记得当初听说YTKNetwork能发起链式请求的时候觉得毫无思路的感觉，不过现在应该没什么问题了。 所以说多阅读源码对技术水平的提升是很有帮助的，除了能增多对本语言API的了解，其实更有意义的是它能让你接触到一些新的设计和解决问题的办法，这些都是脱离某个语言本身的东西，也是作为一名程序员所必不可少的东西。 希望这篇文章能对读者们有所帮助~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F16%2Fhexo%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS代码规范]]></title>
    <url>%2F2018%2F03%2F15%2FiOS%2FiOS%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[利用业余时间，整理出来了这份规范，我会将这份规范作为以后我们团队的代码规范，并且我也会根据读者的反馈以及项目的实践不定时更新，希望大家多多指正批评。 这篇规范一共分为三个部分： 核心原则：介绍这篇代码规范所遵循的核心原则。 通用规范：不局限iOS的通用性的代码规范（使用C语言和Swift语言） iOS规范：仅适用于iOS的代码规范（使用Objective-C） 一、核心原则原则一：代码应该简洁易懂，逻辑清晰以为软件是需要人来维护的。这个人在未来很可能不是你。所以首先是为人编写程序，其次才是计算机。 不要分追求技巧，降低程序的可读性 简洁的代码可以让bug无处藏身。要写出明显没有bug的代码，而不是没有明显bug的代码。 原则二：面向变化编程，而不是面向需求编程需求是暂时的，只有变化才是永恒的。本次迭代不能仅仅为了当前的需求，要写出拓展性强，易修改的程序才是责任的做法，对自己负责，对公司负责。 原则三：先保证程序的正确性，防止过度工程过度工程（over-engineering）：在正确可用的代码写出之前就过度地考虑拓展，重用的的问题，使得工程过度复杂。引用《王垠：编程的智慧》里的话： 先把眼前的问题解决掉，解决好，再考虑将来的扩展问题。 先写出可用的代码，反复推敲，再考虑是否需要重用的问题。 先写出可用，简单，明显没有bug的代码，再考虑测试的问题。 二、通用规范关于大括号 控制语句(if,for,while,switch)中，大括号开始与行尾 函数中，大括号要开始于行首 推荐这样写： 12345678910//控制语句white(someCondition)&#123;&#125;//函数void function(param1,param2)&#123;&#125; 运算符 1.运算符与变量之间的间隔1.1 一元运算符与变量之间没有空格：12345!bValue~iValue++iCount*strSource&amp;fSum 1.2 二元运算符与变量之间必须有空格：1234fWidth = 5 + 5;fLength = fWidth * 2;fHeight = fWidth + fLength;for(int i = 0; i &lt; 10; i++) 2. 多个不同的运算符同时存在时应该使用括号来明确优先级在多个不同的运算符同时存在的时候应该合理使用括号，不要盲目依赖操作符优先级。因为有的时候不能保证阅读你代码的人就一定能了解你写的算式里面所有操作符的优先级。 来看一下这个算式：2 &lt;&lt; 2 + 1 * 3 - 4 这里的&lt;&lt;是移位操作直观上却很容易认为它的优先级很高，所以就把这个算式误认为：(2 &lt;&lt; 2) + 13 - 4但事实上，它的优先级是比加减法还要低的，所以该算式应该等同于：2 &lt;&lt; (2 + 13 - 4).所以在以后写这种复杂一点的算式的时候，尽量多加一点括号，避免让其他人误解（甚至是自己）。 变量 1.一个变量有且只有一个功能，尽量不要把一个变量用作多种用途2.变量在使用前应该初始化，防止未初始化的变量被引用3.局部变量应该尽量接近使用它的地方推荐这样写： 1234567891011func someFunction() &#123; let index = ...; //Do something With index ... ... let count = ...; //Do something With count &#125; 不推荐这样写： 12345678910func someFunction() &#123; let index = ...; let count = ...; //Do something With index ... ... //Do something With count&#125; if语句 1.必须列出所有的分支（列举所有的情况），而且每个分支都必须给出明确的结果。推荐这样写： 123456var hintStr;if (count &lt; 3) &#123; hintStr = &quot;Good&quot;;&#125; else &#123; hintStr = &quot;&quot;;&#125; 不推荐这样写： 1234var hintStr;if (count &lt; 3) &#123; hintStr = &quot;Good&quot;;&#125; 2.不要使用过多的分支，要善于使用return来提前返回错误的情况推荐这样写： 123456- (void)someMethod &#123; if (!goodCondition) &#123; return; &#125; //Do something&#125; 不推荐这样写： 12345- (void)someMethod &#123; if (goodCondition) &#123; //Do something &#125;&#125; 比较典型的例子： 12345678910111213141516171819202122232425262728293031323334-(id)initWithDictionary:(NSDictionary*)dict error:(NSError)err&#123; //方法1. 参数为nil if (!dict) &#123; if (err) *err = [JSONModelError errorInputIsNil]; return nil; &#125; //方法2. 参数不是nil，但也不是字典 if (![dict isKindOfClass:[NSDictionary class]]) &#123; if (err) *err = [JSONModelError errorInvalidDataWithMessage:@&quot;Attempt to initialize JSONModel object using initWithDictionary:error: but the dictionary parameter was not an &apos;NSDictionary&apos;.&quot;]; return nil; &#125; //方法3. 初始化 self = [self init]; if (!self) &#123; //初始化失败 if (err) *err = [JSONModelError errorModelIsInvalid]; return nil; &#125; //方法4. 检查用户定义的模型里的属性集合是否大于传入的字典里的key集合（如果大于，则返回NO） if (![self __doesDictionary:dict matchModelWithKeyMapper:self.__keyMapper error:err]) &#123; return nil; &#125; //方法5. 核心方法：字典的key与模型的属性的映射 if (![self __importDictionary:dict withKeyMapper:self.__keyMapper validation:YES error:err]) &#123; return nil; &#125; //方法6. 可以重写[self validate:err]方法并返回NO，让用户自定义错误并阻拦model的返回 if (![self validate:err]) &#123; return nil; &#125; //方法7. 终于通过了！成功返回model return self;&#125; 可以看到，在这里，首先判断出各种错误的情况然后提前返回，把最正确的情况放到最后返回。 3.条件表达式如果很长，则需要将他们提取出来赋值给一个BOOL值推荐这样写： 123456let nameContainsSwift = sessionName.hasPrefix(&quot;Swift&quot;)let isCurrentYear = sessionDateCompontents.year == 2014let isSwiftSession = nameContainsSwift &amp;&amp; isCurrentYearif (isSwiftSession) &#123; // Do something&#125; 不推荐这样写： 123if ( sessionName.hasPrefix(&quot;Swift&quot;) &amp;&amp; (sessionDateCompontents.year == 2014) ) &#123; // Do something&#125; 4.条件语句的判断应该是变量在左，常量在右推荐这样写： 12if ( count == 6) &#123;&#125; 或者 12if ( object == nil) &#123;&#125; 或者 12if ( !object ) &#123;&#125; 不推荐这样写： 12if ( 6 == count) &#123;&#125; 或者 12f ( nil == object ) &#123;&#125; 5.每个分支必须的实现代码必须用大括号包围推荐这样写： 123if (!error) &#123; return success;&#125; 不推荐这样写：12if (!error) return success; 或者 1if (!error) return success; 6.条件过多，过长的时候应该换行推荐这样写： 123456if (condition1() &amp;&amp; condition2() &amp;&amp; condition3() &amp;&amp; condition4()) &#123; // Do something&#125; 不推荐这样写： 123if (condition1() &amp;&amp; condition2() &amp;&amp; condition3() &amp;&amp; condition4()) &#123; // Do something&#125; for语句 1.不可在for循环内修改循环变量，防止for循环失去控制。1234for (int index = 0; index &lt; 10; index++)&#123; ... logicToChange(index)&#125; 2.避免使用continue和break。continue和break做描述的是“什么时候不做什么”，所以为了读懂二者所在的代码，我们需要在头脑里将他们取反。 其实最好不要让这两个东西出现，移位我们的代码只要体现出“什么时候做什么”就好了，而且通过适当的方法，是可以将这两个东西消灭掉的； 2.1 如果出现了continue，只需要把continue的条件取反即可1234567var filteredProducts = Array&lt;String&gt;()for level in products &#123; if level.hasPrefix(&quot;bad&quot;) &#123; continue &#125; filteredProducts.append(level)&#125; 我们可以看到，通过判断字符串里是否还有“bad”这个prefix老过滤掉一些值。其实我们是可以通过取反，来避免使用continue的： 12345for level in products &#123; if !level.hasPrefix(&quot;bad&quot;) &#123; filteredProducts.append(level) &#125;&#125; 2.2 消除while里的break；讲break的条件取反，合并并到主循环里在while里的block其实就相当于“不存在”，既然是不存在的东西就完全可以子啊最开始的条件语句中将其排除。 while里的break: 123456while (condition1) &#123; ... if (condition2) &#123; break; &#125;&#125; 取反并合并到主条件： 123while (condition1 &amp;&amp; !condition2) &#123; ...&#125; 2.3 在有返回值的方法里消除break：将break转换为return立即返回有些朋友喜欢这样做：在有返回值的方法里break之后，再返回某个值。其实完全可以在break的那一行直接返回。 123456789func hasBadProductIn(products: Array&lt;String&gt;) -&gt; Bool &#123; var result = false for level in products &#123; if level.hasPrefix(&quot;bad&quot;) &#123; result = true &#125; &#125; return result&#125; 遇到错误条件直接返回： 12345678func hasBadProductIn(products: Array&lt;String&gt;) -&gt; Bool &#123; for level in products &#123; if level.hasPrefix(&quot;bad&quot;) &#123; return true &#125; &#125; return false&#125; 这样写的话不用特意声明一个变量来特意保存需要返回的值，看起来非常简洁，可读性高。 Switch语句 1. 每个分支都必须用大括号括起来推荐这样写： 123456789101112131415161718switch (integer) &#123; case 1: &#123; // ... &#125; break; case 2: &#123; // ... break; &#125; case 3: &#123; // ... break; &#125; default:&#123; // ... break; &#125;&#125; 2. 使用枚举类型时，不能有default分支， 除了使用枚举类型以外，都必须有default分支123456789101112131415RWTLeftMenuTopItemType menuType = RWTLeftMenuTopItemMain; switch (menuType) &#123; case RWTLeftMenuTopItemMain: &#123; // ... break; &#125; case RWTLeftMenuTopItemShows: &#123; // ... break; &#125; case RWTLeftMenuTopItemSchedule: &#123; // ... break; &#125;&#125; 在Switch语句使用枚举类型的时候，如果使用了default分支，在将来就无法通过编译器来检查新增的枚举类型了。 函数 1. 一个函数的长度必须限制在50行以内常来说，在阅读一个函数的时候，如果视需要跨过很长的垂直距离会非常影响代码的阅读体验。如果需要来回滚动眼球或代码才能看全一个方法，就会很影响思维的连贯性，对阅读代码的速度造成比较大的影响。最好的情况是在不滚动眼球或代码的情况下一眼就能将该方法的全部代码映入眼帘。 2. 一个函数只做一件事（单一原则）每个函数的职责都应该划分的很明确（就像类一样）。 推荐这样写： 12dataConfiguration()viewConfiguration() 不推荐这样写： 12345void dataConfiguration()&#123; ... viewConfiguration()&#125; 3. 对于有返回值的函数（方法），每一个分支都必须有返回值推荐这样写： 12345678910int function()&#123; if(condition1)&#123; return count1 &#125;else if(condition2)&#123; return count2 &#125;else&#123; return defaultCount &#125; &#125; 不推荐这样写： 12345678int function()&#123; if(condition1)&#123; return count1 &#125;else if(condition2)&#123; return count2 &#125;&#125; 4. 对输入参数的正确性和有效性进行检查，参数错误立即返回推荐这样写： 1234567891011void function(param1,param2)&#123; if(param1 is unavailable)&#123; return; &#125; if(param2 is unavailable)&#123; return; &#125; //Do some right thing&#125; 5. 如果在不同的函数内部有相同的功能，应该把相同的功能抽取出来单独作为另一个函数原来的调用： 123456789void logic() &#123; a(); b()； if (logic1 condition) &#123; c(); &#125; else &#123; d(); &#125;&#125; 将a，b函数抽取出来作为单独的函数 12345678910111213void basicConfig() &#123; a(); b();&#125; void logic1() &#123; basicConfig(); c();&#125;void logic2() &#123; basicConfig(); d();&#125; 6. 将函数内部比较复杂的逻辑提取出来作为单独的函数一个函数内的不清晰（逻辑判断比较多，行数较多）的那片代码，往往可以被提取出去，构成一个新的函数，然后在原来的地方调用它这样你就可以使用有意义的函数名来代替注释，增加程序的可读性。 举一个发送邮件的例子： 123456789openEmailSite();login();writeTitle(title);writeContent(content);writeReceiver(receiver);addAttachment(attachment);send(); 中间的部分稍微长一些，我们可以将它们提取出来： 1234567void writeEmail(title, content,receiver,attachment)&#123; writeTitle(title); writeContent(content); writeReceiver(receiver); addAttachment(attachment); &#125; 然后再看一下原来的代码： 1234openEmailSite();login();writeEmail(title, content,receiver,attachment)send(); 7.避免使用全局变量，类成员（class member）来传递信息，尽量使用局部变量和参数。在一个类里面，经常会有传递某些变量的情况。而如果需要传递的变量是某个全局变量或者属性的时候，有些朋友不喜欢将它们作为参数，而是在方法内部就直接访问了： 1234567891011class A &#123; var x; func updateX() &#123; ... x = ...; &#125; func printX() &#123; updateX(); print(x); &#125;&#125; 我们可以看到，在printX方法里面，updateX和print方法之间并没有值的传递，乍一看我们可能不知道x从哪里来的，导致程序的可读性降低了。 而如果你使用局部变量而不是类成员来传递信息，那么这两个函数就不需要依赖于某一个类，而且更加容易理解，不易出错： 12345678func updateX() -&gt; String&#123; x = ...; return x; &#125; func printX() &#123; String x = updateX(); print(x); &#125; 注释 优秀的代码大部分是可以自描述的，我们完全可以用程代码本身来表达它到底在干什么，而不需要注释的辅助。 但并不是说一定不能写注释，有以下三种情况比较适合写注释： 公共接口（注释要告诉阅读代码的人，当前类能实现什么功能）。涉及到比较深层专业知识的代码（注释要体现出实现原理和思想）。容易产生歧义的代码（但是严格来说，容易让人产生歧义的代码是不允许存在的）。除了上述这三种情况，如果别人只能依靠注释才能读懂你的代码的时候，就要反思代码出现了什么问题。 最后，对于注释的内容，相对于“做了什么”，更应该说明“为什么这么做”。 Code Review 换行、注释、方法长度、代码重复等这些是通过机器检查出来的问题，是无需通过人来做的。 而且除了审查需求的实现的程度，bug是否无处藏身以外，更应该关注代码的设计。比如类与类之间的耦合程度，设计的可扩展性，复用性，是否可以将某些方法抽出来作为接口等等。 三. iOS规范变量 1. 变量名必须使用驼峰格式类，协议使用大驼峰： 12HomePageViewController.h&lt;HeaderViewDelegate&gt; 对象等局部变量使用小驼峰： 12NSString *personName = @&quot;&quot;;NSUInteger totalCount = 0; 2. 变量的名称必须同时包含功能与类型123UIButton *addBtn //添加按钮UILabel *nameLbl //名字标签NSString *addressStr//地址字符串 3. 系统常用类作实例变量声明时加入后缀 类型 后缀 UIViewController VC UIView View UILabel Lbl UIButton Btn UIImage Img UIImageView ImagView NSArray Array NSMutableArray Marray NSDictionary Dict NSMutableDictionary MDdict NSString Str NSMutableString MStr NSSet Set NSMutableSet Mset 常量 1. 常量以相关类名作为前缀推荐这样写： 1static const NSTimeInterval ZOCSignInViewControllerFadeOutAnimationDuration = 0.4; 不推荐这样写： 1static const NSTimeInterval fadeOutTime = 0.4; 2. 建议使用类型常量，不建议使用#define预处理命令首先比较一下这两种声明常量的区别： 预处理命令：简单的文本替换，不包括类型信息，并且可被任意修改。 类型常量：包括类型信息，并且可以设置其使用范围，而且不可被修改。 使用预处理虽然能达到替换文本的目的，但是本身还是有局限性的： 不具备类型信息。 可以被任意修改。 3. 对外公开某个常量：如果我们需要发送通知，那么就需要在不同的地方拿到通知的“频道”字符串（通知的名称），那么显然这个字符串是不能被轻易更改，而且可以在不同的地方获取。这个时候就需要定义一个外界可见的字符串常量。 推荐这样写： 12//头文件extern NSString *const ZOCCacheControllerDidClearCacheNotification; 123//实现文件static NSString * const ZOCCacheControllerDidClearCacheNotification = @&quot;ZOCCacheControllerDidClearCacheNotification&quot;;static const CGFloat ZOCImageThumbnailHeight = 50.0f; 不推荐这样写： 12#define CompanyName @&quot;Apple Inc.&quot; #define magicNumber 42 宏 1. 宏、常量名都要使用大写字母，用下划线‘_’分割单词。123#define URL_GAIN_QUOTE_LIST @&quot;/v1/quote/list&quot;#define URL_UPDATE_QUOTE_LIST @&quot;/v1/quote/update&quot;#define URL_LOGIN @&quot;/v1/user/login” 2. 宏定义中如果包含表达式或变量，表达式和变量必须用小括号括起来。1#define MY_MIN(A, B) ((A)&gt;(B)?(B):(A)) CGRect函数 其实iOS内部已经提供了相应的获取CGRect各个部分的函数了，它们的可读性比较高，而且简短，推荐使用： 推荐这样写： 123456CGRect frame = self.view.frame; CGFloat x = CGRectGetMinX(frame); CGFloat y = CGRectGetMinY(frame); CGFloat width = CGRectGetWidth(frame); CGFloat height = CGRectGetHeight(frame); CGRect frame = CGRectMake(0.0, 0.0, width, height); 而不是 123456CGRect frame = self.view.frame; CGFloat x = frame.origin.x; CGFloat y = frame.origin.y; CGFloat width = frame.size.width; CGFloat height = frame.size.height; CGRect frame = (CGRect)&#123; .origin = CGPointZero, .size = frame.size &#125;; 范型 建议在定义NSArray和NSDictionary时使用泛型，可以保证程序的安全性： 12NSArray&lt;NSString *&gt; *testArr = [NSArray arrayWithObjects:@&quot;Hello&quot;, @&quot;world&quot;, nil];NSDictionary&lt;NSString *, NSNumber *&gt; *dic = @&#123;@&quot;key&quot;:@(1), @&quot;age&quot;:@(10)&#125;; Block为常用的Block类型创建typedef 如果我们需要重复创建某种block（相同参数，返回值）的变量，我们就可以通过typedef来给某一种块定义属于它自己的新类型 例如： 1234int (^variableName)(BOOL flag, int value) =^(BOOL flag, int value)&#123; // Implementation return someInt;&#125; 这个Block有一个bool参数和一个int参数，并返回int类型。我们可以给它定义类型： 12345int(^EOCSomeBlock)(BOOL flag, int value);//再次定义的时候，就可以通过简单的赋值来实现：EOCSomeBlock block = ^(BOOL flag, int value)&#123;// Implementation&#125;; 定义作为参数的Block： 1(void)startWithCompletionHandler: (void(^)(NSData data, NSError error))completion; 这里的Block有一个NSData参数，一个NSError参数并没有返回值 1typedef void(^EOCCompletionHandler)(NSData data, NSError error); 1(void)startWithCompletionHandler:(EOCCompletionHandler)completion;” 通过typedef定义Block签名的好处是:如果要某种块增加参数，那么只修改定义签名的那行代码即可。 字面量语法 尽量使用字面量值来创建 NSString , NSDictionary , NSArray , NSNumber 这些不可变对象： 推荐这样写： 123NSArray *names = @[@&quot;Brian&quot;, @&quot;Matt&quot;, @&quot;Chris&quot;, @&quot;Alex&quot;, @&quot;Steve&quot;, @&quot;Paul&quot;];NSDictionary *productManagers = @&#123;@&quot;iPhone&quot; : @&quot;Kate&quot;, @&quot;iPad&quot; : @&quot;Kamal&quot;, @&quot;Mobile Web&quot; : @&quot;Bill&quot;&#125;; NSNumber *shouldUseLiterals = @YES;NSNumber *buildingZIPCode = @10018; 123NSArray *names = [NSArray arrayWithObjects:@&quot;Brian&quot;, @&quot;Matt&quot;, @&quot;Chris&quot;, @&quot;Alex&quot;, @&quot;Steve&quot;, @&quot;Paul&quot;, nil];NSDictionary *productManagers = [NSDictionary dictionaryWithObjectsAndKeys: @&quot;Kate&quot;, @&quot;iPhone&quot;, @&quot;Kamal&quot;, @&quot;iPad&quot;, @&quot;Bill&quot; ];NSNumber *shouldUseLiterals = [NSNumber numberWithBool:YES];NSNumber *buildingZIPCode = [NSNumber numberWithInteger:10018]; 属性 1. 属性的命名使用小驼峰推荐这样写： 1@property (nonatomic, readwrite, strong) UIButton *confirmButton; 2. 属性的关键字推荐按照 原子性，读写，内存管理的顺序排列推荐这样写： 123@property (nonatomic, readwrite, copy) NSString *name;@property (nonatomic, readonly, copy) NSString *gender;@property (nonatomic, readwrite, strong) UIView *headerView; Block属性应该使用copy关键字 推荐这样写： 12typedef void (^ErrorCodeBlock) (id errorCode,NSString *message);@property (nonatomic, readwrite, copy) ErrorCodeBlock errorBlock;//将block拷贝到堆中 4. 形容词性的BOOL属性的getter应该加上is前缀推荐这样写： 1@property (assign, getter=isEditable) BOOL editable; 5. 使用getter方法做懒加载实例化一个对象是需要耗费资源的，如果这个对象里的某个属性的实例化要调用很多配置和计算，就需要懒加载它，在使用它的前一刻对它进行实例化： 123456789- (NSDateFormatter *)dateFormatter &#123; if (!_dateFormatter) &#123; _dateFormatter = [[NSDateFormatter alloc] init]; NSLocale *enUSPOSIXLocale = [[NSLocale alloc] initWithLocaleIdentifier:@&quot;en_US_POSIX&quot;]; [_dateFormatter setLocale:enUSPOSIXLocale]; [_dateFormatter setDateFormat:@&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss.SSS&quot;]; &#125; return _dateFormatter;&#125; 但是也有对这种做法的争议：getter方法可能会产生某些副作用，例如如果它修改了全局变量，可能会产生难以排查的错误。 6. 除了init和dealloc方法，建议都使用点语法访问属性使用点语法的好处：setter： setter会遵守内存管理语义(strong, copy, weak)。 通过在内部设置断点，有助于调试bug。 可以过滤一些外部传入的值。 捕捉KVO通知。getter： 允许子类化。 通过在内部设置断点，有助于调试bug。 实现懒加载（lazy initialization）。 注意： 懒加载的属性，必须通过点语法来读取数据。因为懒加载是通过重写getter方法来初始化实例变量的，如果不通过属性来读取该实例变量，那么这个实例变量就永远不会被初始化。 在init和dealloc方法里面使用点语法的后果是：因为没有绕过setter和getter，在setter和getter里面可能会有很多其他的操作。而且如果它的子类重载了它的setter和getter方法，那么就可能导致该子类调用其他的方法。 7. 不要滥用点语法，要区分好方法调用和属性访问推荐这样写： 12view.backgroundColor = [UIColor orangeColor]; [UIApplication sharedApplication].delegate; 不推荐这样写： 12[view setBackgroundColor:[UIColor orangeColor]]; UIApplication.sharedApplication.delegate; 8. 尽量使用不可变对象建议尽量把对外公布出来的属性设置为只读，在实现文件内部设为读写。具体做法是： 在头文件中，设置对象属性为 在实现文件中设置为123456 这样一来，在外部就只能读取该数据，而不能修改它，使得这个类的实例所持有的数据更加安全。而且，对于集合类的对象，更应该仔细考虑是否可以将其设为可变的。 如果在公开部分只能设置其为只读属性，那么就在非公开部分存储一个可变型。所以当在外部获取这个属性时，获取的只是内部可变型的一个不可变版本, 例如： 在公共API中： @interface EOCPerson : NSObject @property (nonatomic, copy, readonly) NSString firstName;@property (nonatomic, copy, readonly) NSString lastName;@property (nonatomic, strong, readonly) NSSet *friends //向外公开的不可变集合 (id)initWithFirstName:(NSString)firstName andLastName:(NSString)lastName;(void)addFriend:(EOCPerson)person;(void)removeFriend:(EOCPerson)person;@end1234&gt;在这里，我们将friends属性设置为不可变的set。然后，提供了来增加和删除这个set里的元素的公共接口。在实现文件里： @interface EOCPerson () @property (nonatomic, copy, readwrite) NSString firstName;@property (nonatomic, copy, readwrite) NSString lastName; @end @implementation EOCPerson {NSMutableSet *_internalFriends; //实现文件里的可变集合} (NSSet*)friends { return [_internalFriends copy]; //get方法返回的永远是可变set的不可变型} 12##### 2. 方法实现时，如果参数过长，则令每个参数占用一行，以冒号对齐。 (void)doSomethingWith:(NSString *)theFoo rect:(CGRect)theRect interval:(CGFloat)theInterval { //Implementation} 12##### 3. 私有方法应该在实现文件中申明。 @interface ViewController () (void)basicConfiguration;@end@implementation ViewController (void)basicConfiguration{ //Do some basic configuration}@end 123##### 4. 方法名用小写字母开头的单词组合而成 (NSString *)descriptionWithLocale:(id)locale; 123456##### 5. 方法名前缀* 刷新视图的方法名要以refresh为首。* 更新数据的方法名要以update为首。推荐这样写： (void)refreshHeaderViewWithCount:(NSUInteger)count; (void)updateDataSourceWithViewModel:(ViewModel*)viewModel;123456789101112### 面向协议编程-------如果某些功能（方法）具备可复用性，我们就需要将它们抽取出来放入一个抽象接口文件中（在iOS中，抽象接口即协议），让不同类型的对象遵循这个协议，从而拥有相同的功能。因为协议是不依赖于某个对象的，所以通过协议，我们可以解开两个对象之间的耦合。如何理解呢？我们来看一下下面这个例子：现在有一个需求：在一个`UITableViewController`里面拉取feed并展示出来。#### 方案一：定义一个拉取feed的类ZOCFeedParser，这个类有一些代理方法实现feed相关功能： @protocol ZOCFeedParserDelegate @optional (void)feedParserDidStart:(ZOCFeedParser *)parser; (void)feedParser:(ZOCFeedParser )parser didParseFeedInfo:(ZOCFeedInfoDTO )info; (void)feedParser:(ZOCFeedParser )parser didParseFeedItem:(ZOCFeedItemDTO )item; (void)feedParserDidFinish:(ZOCFeedParser *)parser; (void)feedParser:(ZOCFeedParser )parser didFailWithError:(NSError )error;@end@interface ZOCFeedParser : NSObject@property (nonatomic, weak) id delegate;@property (nonatomic, strong) NSURL *url; (id)initWithURL:(NSURL *)url; (BOOL)start; (void)stop;@end1然后在ZOCTableViewController里面传入ZOCFeedParser，并遵循其代理方法，实现feed的拉取功能。 @interface ZOCTableViewController : UITableViewController (instancetype)initWithFeedParser:(ZOCFeedParser *)feedParser;@end1然后在ZOCTableViewController里面传入ZOCFeedParser，并遵循其代理方法，实现feed的拉取功能。 @interface ZOCTableViewController : UITableViewController (instancetype)initWithFeedParser:(ZOCFeedParser *)feedParser;@end12具体应用： NSURL feedURL = [NSURL URLWithString:@”http://bbc.co.uk/feed.rss“];ZOCFeedParser feedParser = [[ZOCFeedParser alloc] initWithURL:feedURL];ZOCTableViewController *tableViewController = [[ZOCTableViewController alloc] initWithFeedParser:feedParser];feedParser.delegate = tableViewController;1234567OK，现在我们实现了需求：在`ZOCTableViewController`里面存放了一个`ZOCFeedParser`对象来处理feed的拉取功能。于是我们重新审视一下这个需求：其实我们实际上只需要`ZOCTableViewController`拉取feed就可以了，而具体是由哪个对象来拉取，`ZOCTableViewController`并不需要关心。也就是说，我们需要提供给`ZOCTableViewController`的是一个更范型的对象，这个对象具备了拉取feed的功能就好了，而不应该仅仅局限于某个具体的对象（`ZOCFeedParser`）。所以，刚才的设计需要重新做一次修改：#### 方案二：首先需要在一个接口文件`ZOCFeedParserProtocol.h`里面定义抽象的，具有拉取feed功能的协议： @protocol ZOCFeedParserDelegate @optional (void)feedParserDidStart:(id)parser; (void)feedParser:(id)parser didParseFeedInfo:(ZOCFeedInfoDTO *)info; (void)feedParser:(id)parser didParseFeedItem:(ZOCFeedItemDTO *)item; (void)feedParserDidFinish:(id)parser; (void)feedParser:(id)parser didFailWithError:(NSError )error;@end@protocol ZOCFeedParserProtocol @property (nonatomic, weak) id delegate;@property (nonatomic, strong) NSURL url; (BOOL)start; (void)stop;@end1而原来的`ZOCFeedParser`仅仅是需要遵循上面这个协议就具备了拉取feed的功能 @interface ZOCFeedParser : NSObject (id)initWithURL:(NSURL *)url;//仅仅需要通过传入url即可，其他事情都交给ZOCFeedParserProtocol@end1而且，`ZOCTableViewController`也不直接依赖于`ZOCFeedParser`对象，我们只需要传给它一个遵循`&lt;ZOCFeedParserProtocol&gt;`的对象即可。 @interface ZOCTableViewController : UITableViewController (instancetype)initWithFeedParser:(id)feedParser;@end 123456789101112131415这样一来，`ZOCTableViewController`和`wController`和`之间就没有直接的关系了。以后，如果我们想：* 给这个feed拉取器增加新的功能：仅需要修改`ZOCFeedParserProtocol.h`文件。* 更换一个feed拉取器实例：创建一个新类型来遵循`ZOCFeedParserProtocol.h`即可。### iOS 中委托的设计-------#### 1. 要区分好代理和数据源的区别在iOS开发中的委托模式包含了delegate（代理）和datasource（数据源）。虽然二者同属于委托模式，但是这两者是有区别的。这个区别就是二者的信息流方向是不同的：* delegate ：事件发生的时候，委托者需要通知代理。（信息流从委托者到代理）* datasource：委托者需要从数据源拉取数据。（信息流从数据源到委托者）然而包括苹果也没有做好榜样，将它们彻底的区分开。就拿UITableView来说，在它的delegate方法中有一个方法： (void)tableView:(UITableView )tableView didSelectRowAtIndexPath:(NSIndexPath )indexPath; 12这个方法正确地体现了代理的作用：委托者（tableview）告诉代理（控制器）“我的某个cell被点击了”。但是，UITableViewDelegate的方法列表里还有这个方法： (CGFloat)tableView:(UITableView )tableView heightForRowAtIndexPath:(NSIndexPath )indexPath 1234该方法的作用是 由控制器来告诉tabievlew的行高，也就是说，它的信息流是从控制器（数据源）到委托者（tableview）的。准确来讲，它应该是一个数据源方法，而不是代理方法。在UITableViewDataSource中，就有标准的数据源方法： (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView; 1234567这个方法的作用就是让tableview向控制器拉取一个section数量的数据。所以，在我们设计一个视图控件的代理和数据源时，一定要区分好二者的区别，合理地划分哪些方法属于代理方法，哪些方法属于数据源方法。#### 2. 代理方法的第一个参数必须为委托者代理方法必须以委托者作为第一个参数（参考UITableViewDelegate）的方法。其目的是为了区分不同委托着的实例。因为同一个控制器是可以作为多个tableview的代理的。若要区分到底是哪个tableview的cell被点击了，就需要在 (void)tableView:(UITableView )tableView didSelectRowAtIndexPath:(NSIndexPath )indexPath``方法中做个区分。123##### 向代理发送消息时需要判断其是否实现该方法最后，在委托着向代理发送消息的时候，需要判断委托着是否实现了这个代理方法: if ([self.delegate respondsToSelector:@selector(signUpViewControllerDidPressSignUpButton:)]) { [self.delegate signUpViewControllerDidPressSignUpButton:self];}1#### 3. 遵循代理过多的时候，换行对齐显示 @interface ShopViewController () 12#### 4. 代理的方法需要明确必须执行和可不执行代理方法在默认情况下都是必须执行的，然而在设计一组代理方法的时候，有些方法可以不是必须执行（是因为存在默认配置），这些方法就需要使用@optional关键字来修饰： @protocol ZOCServiceDelegate @optional- (void)generalService:(ZOCGeneralService )service didRetrieveEntries:(NSArray )entries;@end123456### 类-------#### 1. 类的名称应该以三个大写字母为前缀；创建子类的时候，应该把代表子类特点的部分放在前缀和父类名的中间推荐这样写： //父类ZOCSalesListViewController//子类ZOCDaySalesListViewControllerZOCMonthSalesListViewController1234567891011#### 2. initializer &amp;&amp; dealloc推荐：* 将 dealloc 方法放在实现文件的最前面* 将init方法放在dealloc方法后面。如果有多个初始化方法，应该将指定初始化方法放在最前面，其他初始化方法放在其后。##### 2.1 dealloc方法里面应该直接访问实例变量，不应该用点语法访问##### 2.2 init方法的写法：* init方法返回类型必须是instancetype，不能是id。* 必须先实现[super init]。 (instancetype)init { self = [super init]; // call the designated initializer if (self) { // Custom initialization } return self;}1234##### 2.3 指定初始化方法指定初始化方法(designated initializer)是提供所有的（最多的）参数的初始化方法，间接初始化方法(secondary initializer)有一个或部分参数的初始化方法。注意事项1：间接初始化方法必须调用指定初始化方法。 @implementation ZOCEvent//指定初始化方法 (instancetype)initWithTitle:(NSString )title date:(NSDate )datelocation:(CLLocation *)location{ self = [super init]; if (self) { _title = title; _date = date; _location = location; } return self;}//间接初始化方法 (instancetype)initWithTitle:(NSString )title date:(NSDate )date{ return [self initWithTitle:title date:date location:nil];}//间接初始化方法 (instancetype)initWithTitle:(NSString *)title{ return [self initWithTitle:title date:[NSDate date] location:nil];}@end 12注意事项2：如果直接父类有指定初始化方法，则必须调用其指定初始化方法 (id)initWithNibName:(NSString )nibNameOrNil bundle:(NSBundle )nibBundleOrNil { self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil]; if (self) { } return self;} 12345678注意事项3：如果想在当前类自定义一个新的全能初始化方法，则需要如下几个步骤1. 定义新的指定初始化方法，并确保调用了直接父类的初始化方法。2. 重载直接父类的初始化方法，在内部调用新定义的指定初始化方法。3. 为新的指定初始化方法写文档。看一个标准的例子： @implementation ZOCNewsViewController//新的指定初始化方法 (id)initWithNews:(ZOCNews *)news { self = [super initWithNibName:nil bundle:nil]; if (self) {_news = news; } return self;}// 重载父类的初始化方法 (id)initWithNibName:(NSString )nibNameOrNil bundle:(NSBundle )nibBundleOrNil{ return [self initWithNews:nil];}@end123456789101112在这里，重载父类的初始化方法并在内部调用新定义的指定初始化方法的原因是你不能确定调用者调用的就一定是你定义的这个新的指定初始化方法，而不是原来从父类继承来的指定初始化方法。假设你没有重载父类的指定初始化方法，而调用者却恰恰调用了父类的初始化方法。那么调用者可能永远都调用不到你自己定义的新指定初始化方法了。而如果你成功定义了一个新的指定初始化方法并能保证调用者一定能调用它，你最好要在文档中明确写出哪一个才是你定义的新初始化方法。或者你也可以使用编译器指令`__attribute__((objc_designated_initializer))`来标记它。#### 3. 所有返回类对象和实例对象的方法都应该使用instancetype将instancetype关键字作为返回值的时候，可以让编译器进行类型检查，同时适用于子类的检查，这样就保证了返回类型的正确性（一定为当前的类对象或实例对象）推荐这样写： @interface ZOCPerson (instancetype)personWithName:(NSString *)name;@end1不推荐这样写： @interface ZOCPerson (id)personWithName:(NSString *)name;@end1234#### 4. 在类的头文件中尽量少引用其他头文件有时，类A需要将类B的实例变量作为它公共API的属性。这个时候，我们不应该引入类B的头文件，而应该使用向前声明（forward declaring）使用class关键字，并且在A的实现文件引用B的头文件。 // EOCPerson.h #import @class EOCEmployer;@interface EOCPerson : NSObject@property (nonatomic, copy) NSString firstName;@property (nonatomic, copy) NSString lastName;@property (nonatomic, strong) EOCEmployer *employer;//将EOCEmployer作为属性@end// EOCPerson.m #import “EOCEmployer.h”12345678910111213这样做有什么优点呢：&gt; * 不在A的头文件中引入B的头文件，就不会一并引入B的全部内容，这样就减少了编译时间。&gt; * 可以避免循环引用：因为如果两个类在自己的头文件中都引入了对方的头文件，那么就会导致其中一个类无法被正确编译。但是个别的时候，必须在头文件中引入其他类的头文件: &gt; 主要有两种情况：&gt; 1. 该类继承于某个类，则应该引入父类的头文件。&gt; 2. 该类遵从某个协议，则应该引入该协议的头文件。而且最好将协议单独放在一个头文件中。#### 5. 类的布局 #pragma mark - Life Cycle Methods (instancetype)init (void)dealloc (void)viewWillAppear:(BOOL)animated (void)viewDidAppear:(BOOL)animated (void)viewWillDisappear:(BOOL)animated (void)viewDidDisappear:(BOOL)animated#pragma mark - Override Methods#pragma mark - Intial Methods#pragma mark - Network Methods#pragma mark - Target Methods#pragma mark - Public Methods#pragma mark - Private Methods#pragma mark - UITableViewDataSource#pragma mark - UITableViewDelegate#pragma mark - Lazy Loads#pragma mark - NSCopying#pragma mark - NSObject Methods1234567### 分类-------#### 1. 分类添加的方法需要添加前缀和下划线推荐这样写： @interface NSDate (ZOCTimeExtensions) (NSString *)zoc_timeAgoShort;@end12不推荐这样写： @interface NSDate (ZOCTimeExtensions) (NSString *)zoc_timeAgoShort;@end12345678#### 2. 把类的实现代码分散到便于管理的多个分类中一个类可能会有很多公共方法，而且这些方法往往可以用某种特有的逻辑来分组。我们可以利用Objecctive-C的分类机制，将类的这些方法按一定的逻辑划入几个分区中。举个🌰：先看一个没有使用无分类的类： #import @interface EOCPerson : NSObject@property (nonatomic, copy, readonly) NSString firstName;@property (nonatomic, copy, readonly) NSString lastName;@property (nonatomic, strong, readonly) NSArray *friends; (id)initWithFirstName:(NSString)firstName andLastName:(NSString)lastName;/ Friendship methods / (void)addFriend:(EOCPerson*)person; (void)removeFriend:(EOCPerson*)person; (BOOL)isFriendsWith:(EOCPerson)person;/ Work methods */ (void)performDaysWork; (void)takeVacationFromWork;/ Play methods / (void)goToTheCinema; (void)goToSportsGame;@end12分类之后： #import @interface EOCPerson : NSObject@property (nonatomic, copy, readonly) NSString firstName;@property (nonatomic, copy, readonly) NSString lastName;@property (nonatomic, strong, readonly) NSArray *friends; (id)initWithFirstName:(NSString)firstNameandLastName:(NSString)lastName;@end@interface EOCPerson (Friendship) (void)addFriend:(EOCPerson*)person; (void)removeFriend:(EOCPerson*)person; (BOOL)isFriendsWith:(EOCPerson*)person;@end@interface EOCPerson (Work) (void)performDaysWork; (void)takeVacationFromWork;@end@interface EOCPerson (Play) (void)goToTheCinema; (void)goToSportsGame;@end12其中，FriendShip分类的实现代码可以这么写： // EOCPerson+Friendship.h #import “EOCPerson.h”@interface EOCPerson (Friendship) (void)addFriend:(EOCPerson*)person; (void)removeFriend:(EOCPerson*)person; (BOOL)isFriendsWith:(EOCPerson*)person;@end// EOCPerson+Friendship.m#import “EOCPerson+Friendship.h”@implementation EOCPerson (Friendship) (void)addFriend:(EOCPerson)person {/ … */} (void)removeFriend:(EOCPerson)person {/ … */} (BOOL)isFriendsWith:(EOCPerson)person {/ … */}@end1234567891011121314151617&gt; 注意：在新建分类文件时，一定要引入被分类的类文件。通过分类机制，可以把类代码分成很多个易于管理的功能区，同时也便于调试。因为分类的方法名称会包含分类的名称，可以马上看到该方法属于哪个分类中。利用这一点，我们可以创建名为Private的分类，将所有私有方法都放在该类里。这样一来，我们就可以根据private一词的出现位置来判断调用的合理性，这也是一种编写“自我描述式代码（self-documenting）”的办法。### 单例-------#### 1. 单例不能作为容器对象来使用单例对象不应该暴露出任何属性，也就是说它不能作为让外部存放对象的容器。它应该是一个处理某些特定任务的工具，比如在iOS中的GPS和加速度传感器。我们只能从他们那里得到一些特定的数据。#### 2. 使用dispatch_once来生成单例推荐这样写： (instancetype)sharedInstance {static id sharedInstance = nil;static dispatch_once_t onceToken = 0; dispatch_once(&amp;onceToken, ^{ sharedInstance = [[self alloc] init];});return sharedInstance;} 12不推荐这样写： (instancetype)sharedInstance {static id sharedInstance;@synchronized(self) {if (sharedInstance == nil) { sharedInstance = [[MyClass alloc] init];} }return sharedInstance;} 12345### 相等性的判断-------判断两个person类是否相等的合理做法： (BOOL)isEqual:(id)object { if (self == object) { return YES; //判断内存地址}if (![object isKindOfClass:[ZOCPerson class]]) { return NO; //是否为当前类或派生类 }return [self isEqualToPerson:(ZOCPerson *)object]; }//自定义的判断相等性的方法 (BOOL)isEqualToPerson:(Person *)person { if (!person) { return NO; } BOOL namesMatch = (!self.name &amp;&amp; !person.name) || [self.name isEqualToString:person.name]; BOOL birthdaysMatch = (!self.birthday &amp;&amp; !person.birthday) || [self.birthday isEqualToDate:person.birthday]; return haveEqualNames &amp;&amp; haveEqualBirthdays;}12345678910111213141516171819### 方法文档-------一个函数(方法)必须有一个字符串文档来解释，除非它：* 非公开，私有函数。* 很短。* 显而易见。 而其余的，包括公开接口，重要的方法，分类，以及协议，都应该伴随文档（注释）：* 以/开始* 第二行识总结性的语句* 第三行永远是空行* 在与第二行开头对齐的位置写剩下的注释。建议这样写： /This comment serves to demonstrate the format of a doc string.Note that the summary line is always at most one line long, and after the opening block comment,and each line of text is preceded by a single space.*/12看一个指定初始化方法的注释： / Designated initializer. * @param store The store for CRUD operations. @param searchService The search service used to query the store. @return A ZOCCRUDOperationsStore object.*/ (instancetype)initWithOperationsStore:(id)store searchService:(id)searchService;1234567### 多用队列，少用同步锁来避免资源抢夺-------多个线程执行同一份代码时，很可能会造成数据不同步。建议使用GCD来为代码加锁的方式解决这个问题。#### 方案一：使用串行同步队列来将读写操作都安排到同一个队列里： _syncQueue = dispatch_queue_create(“com.effectiveobjectivec.syncQueue”, NULL);//读取字符串 (NSString*)someString { __block NSString *localSomeString; dispatch_sync(_syncQueue, ^{ localSomeString = _someString; }); return localSomeString; }//设置字符串 (void)setSomeString:(NSString*)someString { dispatch_sync(_syncQueue, ^{_someString = someString; });}123456这样一来，读写操作都在串行队列进行，就不容易出错。但是，还有一种方法可以让性能更高：#### 方案二：将写操作放入栅栏快中，让他们单独执行；将读取操作并发执行。 _syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);//读取字符串 (NSString)someString { __block NSString localSomeString; dispatch_sync(_syncQueue, ^{localSomeString = _someString; }); return localSomeString;}12 //设置字符串 (void)setSomeString:(NSString*)someString { dispatch_barrier_async(_syncQueue, ^{ _someString = someString; });} 12345678910111213显然，数据的正确性主要取决于写入操作，那么只要保证写入时，线程是安全的，那么即便读取操作是并发的，也可以保证数据是同步的。这里的`dispatch_barrier_async`方法使得操作放在了同步队列里“有序进行”，保证了写入操作的任务是在串行队列里。### 实现description方法打印自定义对象信息-------在打印我们自己定义的类的实例对象时，在控制台输出的结果往往是这样的：`object = &lt;EOCPerson: 0x7fd9a1600600&gt;`这里只包含了类名和内存地址，它的信息显然是不具体的,远达不到调试的要求。但是！如果在我们自己定义的类覆写description方法，我们就可以在打印这个类的实例时输出我们想要的信息。例如： (NSString*)description { return [NSString stringWithFormat:@”&lt;%@: %p, %@ %@&gt;”, [self class], self, firstName, lastName];} 1234在这里，显示了内存地址，还有该类的所有属性。而且，如果我们将这些属性值放在字典里打印，则更具有可读性： (NSString*)description { return [NSString stringWithFormat:@”&lt;%@: %p, %@&gt;”,[self class],self, @{ @”title”:_title, @&quot;latitude&quot;:@(_latitude), @&quot;longitude&quot;:@(_longitude)} ];} 12输出结果： location = 12345678910111213141516171819202122232425262728293031我们可以看到，通过重写`description`方法可以让我们更加了解对象的情况，便于后期的调试，节省开发时间。### NSArray&amp; NSMutableArray-------#### 1. addObject之前要非空判断。#### 2. 取下标的时候要判断是否越界。#### 3. 取第一个元素或最后一个元素的时候使用firtstObject和lastObject### NSCache-------#### 1. 构建缓存时选用NSCache 而非NSDictionary如果我们缓存使用得当，那么应用程序的响应速度就会提高。只有那种“重新计算起来很费事的数据，才值得放入缓存”，比如那些需要从网络获取或从磁盘读取的数据。在构建缓存的时候很多人习惯用NSDictionary或者NSMutableDictionary，但是作者建议大家使用NSCache，它作为管理缓存的类，有很多特点要优于字典，因为它本来就是为了管理缓存而设计的。#### 2. NSCache优于NSDictionary的几点：* 当系统资源将要耗尽时，NSCache具备自动删减缓冲的功能。并且还会先删减“最久未使用”的对象。* NSCache不拷贝键，而是保留键。因为并不是所有的键都遵从拷贝协议（字典的键是必须要支持拷贝协议的，有局限性）。* NSCache是线程安全的：不编写加锁代码的前提下，多个线程可以同时访问NSCache。### NSNotification-------#### 1. 通知的名称建议将通知的名字作为常量，保存在一个专门的类中： // Const.hextern NSString const ZOCFooDidBecomeBarNotification// Const.mNSString const ZOCFooDidBecomeBarNotification = @”ZOCFooDidBecomeBarNotification”;1234567891011#### 2. 通知的移除通知必须要在对象销毁之前移除掉。### 其他-------#### 1. Xcode工程文件的物理路径要和逻辑路径保持一致。#### 2. 忽略没有使用变量的编译警告对于某些暂时不用，以后可能用到的临时变量，为了避免警告，我们可以使用如下方法将这个警告消除： (NSInteger)giveMeFive {NSString *foo;#pragma unused (foo)return 5;} 1234#### 3. 手动标明警告和错误手动明确一个错误： (NSInteger)divide:(NSInteger)dividend by:(NSInteger)divisor {#error Whoa, buddy, you need to check for zero here!return (dividend / divisor);} 1手动明确一个警告： (float)divide:(float)dividend by:(float)divisor {#warning Dude, don’t compare floating point numbers like this!if (divisor != 0.0) {return (dividend / divisor);} else { return NAN;}}``` 参考文献： 王垠：编程的智慧 美团点评技术团队：聊聊clean code 禅与 Objective-C 编程艺术 J_Knight 的文集：iOS - 《Effective Objective-C 2.0》 蝴蝶之梦天使：iOS代码编程规范-根据项目经验汇总 高家二少爷：Objective-C高质量代码参考规范 J_Knight 的文集：iOS 代码规范]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub Pages + Hexo搭建博客]]></title>
    <url>%2F2018%2F03%2F15%2Fhexo%2FGitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[GitHub Pages + Hexo搭建博客一、 前言这是一篇是单纯地利用GitHub Pages搭建自己独立博客的过程，并没有额外使用独立域名之类的。 如果是小小白，可以先花时间去了解下： Git GitHub GitHub Pages Hexo Markdown 二、 必要配置2.1 GitHub Pages 仓库2.1.1 创建对应仓库在自己的GitHub账号下创建一个新的仓库，命名为username.github.io（username是你的账号名)。 在这里，要知道，GitHub Pages有两种类型：User/Organization Pages 和 Project Pages，而我所使用的是User Pages。 简单来说，User Pages 与 Project Pages的区别是： User Pages 是用来展示用户的，而 Project Pages 是用来展示项目的。 用于存放 User Pages 的仓库必须使用username.github.io的命名规则，而 Project Pages 则没有特殊的要求。 User Pages 将使用仓库的 master 分支，而 Project Pages 将使用 gh-pages 分支。 User Pages 通过 http(s)://username.github.io 进行访问，而 Projects Pages通过 http(s)://username.github.io/projectname 进行访问。 2.1.2 相关资料 GitHub Pages Basics / User, Organization, and Project Pages 2.2 Git2.2.1 安装 Git在windows下安装git比较常用的有两种方式： Git 官方版本的安装 GitHub for Windows 2.2.2 配置 Git当安装完Git应该做的第一件事情就是设置用户名称和邮件地址。这样做很重要，因为每一个Git的提交都会使用这些信息，并且它会写入你的每一次提交中，不可更改： 12$ git config --global user.name &quot;username&quot;$ git config --global user.email &quot;username@example.com&quot; 对于user.email，因为在GitHub的commits信息上是可见的，所以如果你不想让人知道你的email，可以Keeping your email address private: 在GitHub右上方点击你的头像，选择”Settings”； 在右边的”Personal settings”侧边栏选择”Emails”； 选择”Keep my email address private”。 这样，你就可以使用如下格式的email进行配置： 1$ git config --global user.email &quot;username@users.noreply.github.com&quot; 2.2.3 相关资料 安装 Git 配置 Git Setting your email in Git Keeping your email address private 2.3 Git 与 GitHub2.3.1 git与github的区别这里，我们要区分清楚git与github。 git是一个版本控制的工具，而github有点类似于远程仓库，用于存放用git管理的各种项目。 2.3.2 与github建立联系为了能够在本地使用git管理github上的项目，需要进行一些配置，这里介绍SSH的方法。 2.3.2.1 检查电脑是否已经有SSH KEYS。12$ ls -al ~/.ssh# Lists the files in your .ssh directory, if they exist 默认情况下，public keys的文件名是以下的格式之一：id_dsa.pub、id_ecdsa.pub、id_ed25519.pub、id_rsa.pub。因此，如果列出的文件有public和private钥匙对（例如id_ras.pub和id_rsa），证明已存在SSH keys。 2.3.2.2 如果没有SSH KEY，则生成新的SSH KEY。12$ ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;# Creates a new ssh key, using the provided email as a label 之后一路回车即可。 2.3.2.3 向SSH-AGENT添加KEY。首先确保ssh-agent可运行： 12# start the ssh-agent in the background$ ssh-agent -s 然后添加SSH key： 1$ ssh-add ~/.ssh/id_rsa 2.3.2.4 在GITHUB添加SSH KEY。首先，拷贝key： 12clip &lt; ~/.ssh/id_rsa.pub# Copies the contents of the id_rsa.pub file to your cllipboard 然后，在GitHub右上方点击头像，选择”Settings”，在右边的”Personal settings”侧边栏选择”SSH Keys”。接着粘贴key，点击”Add key”按钮。最后，测试链接： 12$ ssh -T git@github.com# Attempts to ssh to GitHub 如果你看到： 123The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 就键入：yes。之后将会看到如下信息： 12Hi username! You&apos;ve successfully authenticated, but GitHub does notprovide shell access. 2.3.3 相关资料 Generating SSH keys 2.4 Hexo2.4.1 安装Hexo安装Hexo相当简单。在安装之前，必须检查电脑中是否已经安装下列应用程序： Node.js Git 如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。 1$ npm install -g hexo-cli 2.4.2 使用Hexo建站安装完后，在你喜欢的文件夹内（例如D：\Hexo），点击鼠标右键选择Git bash，输入以下指令： 1$ hexo init 该命令会在目标文件夹内建立网站所需要的所有文件。接下来是安装依赖包： 1$ npm install 这样，我们就已经搭建起本地的Hexo博客了。可以先执行以下命令（在对应文件夹下），然后再浏览器输入localhost:4000查看。 12$ hexo generate$ hexo server 这个博客只是本地的，别人是浏览不了的，之后需要部署到GitHub上。 2.4.3 相关资料 Hexo 官方文档 三、一般的搭建方法在上面，我们已经配置好了所需的所有东西，也成功地搭建了一个本地Hexo博客。现在，需要使用GitHub Pages搭建一个别人能够访问的Hexo博客了。 3.1 使用默认theme我们继续使用上面的文件夹D:\Hexo（也可以新建一个文件夹重新生成），然后编辑该文件夹下的_config.yml。 默认生成的_config.yml： 1234# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy: type: 修改后的_config.yml： 1234deploy: type: git repo: 对应仓库的SSH地址（可以在GitHub对应的仓库中复制） branch: 分支（User Pages为master，Project Pages为gh-pages） 为了能够使Hexo部署到GitHub上，需要安装一个插件： 1$ npm install hexo-deployer-git --save 然后，执行下列指令即可完成部署： 12$ hexo generate$ hexo deploy 之后，可以通过在浏览器键入：username.github.io进行浏览，开心吧~ 3.2 其他theme如果想要使用其他主题，可以使用git clone将别人的主题拷贝到D:\Hexo\themes下，然后将_config.yml中的theme: landscape改为对应的主题名字。 下面是next主题的个性化配置教程: next个性化配置教程 四、 优化部署与管理4.1 概述Hexo部署到GitHub上的文件，是.md（你的博文）转化之后的.html（静态网页）。因此，当你重装电脑或者想在不同电脑上修改博客时，就不可能了（除非你自己写html o(^▽^)o ）。 其实，Hexo生成的网站文件中有.gitignore文件，因此它的本意也是想我们将Hexo生成的网站文件存放到GitHub上进行管理的（而不是用U盘或者云备份啦(╬▔皿▔)凸）。这样，不仅解决了上述的问题，还可以通过git的版本控制追踪你的博文的修改过程，是极赞的。 但是，如果每一个GitHub Pages都需要创建一个额外的仓库来存放Hexo网站文件，我感觉很麻烦（10个项目需要20个仓库(ˉ▽ˉ)…）。 所以，我利用了分支！！！ 简单地说，每个想建立GitHub Pages的仓库，起码有两个分支，一个用来存放Hexo网站的文件，一个用来发布网站。 下面以我的博客作为例子详细地讲述。 4.2 我的博客搭建流程 创建仓库，liuxc123.github.io； 创建两个分支：master 与 hexo； 设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）； 使用git clone git@github.com:liuxc123/liuxc123.github.io.git拷贝仓库； 修改_config.yml中的deploy参数，分支应为master； 依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件； 执行hexo generate -d生成网站并部署到GitHub上。 这样一来，在GitHub上的CrazyMilk.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。完美( •̀ ω •́ )y！ 4.3 我的博客管理流程4.3.1 日常修改在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理： 依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）； 然后才执行hexo generate -d发布网站到master分支上。 虽然两个过程顺序调转一般不会有问题，不过逻辑上这样的顺序是绝对没问题的（例如突然死机要重装了，悲催….的情况，调转顺序就有问题了）。 4.3.2 本地资料丢失当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤： 使用git clone git@github.com:liuxc123/liuxc123.github.io.git拷贝仓库（默认分支为hexo）； 在本地新拷贝的liuxc123.github.io文件夹下通过Git bash依次执行下列指令：npm install hexo、npm install、npm install hexo-deployer-git（记得，不需要hexo init这条指令）。 ###五、结尾ok,现在你就可以轻松的搭建自己的博客了。(ˉ▽ˉ)]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
