<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Swift访问控制]]></title>
    <url>%2F2018%2F04%2F18%2FiOS%2FSwift%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[前言本文章主要让大家了解掌握Swift中一些关键字的作用。 模块和源文件Swift的访问控制模型基于模块和源文件的概念。 模块是单一的代码分配单元———— 一个框架或应用程序会作为独立的单元构建和发布并且可以使用Swift的import关键字导入另一个模块。 Xcode 中的每个构建目标（例如应用程序包或框架）在 Swift 中被视为一个独立的模块。 如果你将应用程序的代码作为独立的框架组合在一起——或许可以在多个应用程序中封装和重用该代码——那么当在一个应用程序中导入和使用时，在该框架中定义的所有内容都将作为独立模块的一部分 ，或是当它在另一个框架中使用时。 源文件是一个模块中的单个 Swift 源代码文件（实际上，是一个应用程序或是框架中的单个文件）。虽然通常在单独源文件中定义单个类型，但是一个源文件可以包含多个类型。函数等的定义。 访问级别Swift 为代码的实体提供个五个不同的访问级别。这些访问级别和定义实体的源文件相关，并且也和源文件所属的模块相关。 Open访问和public访问 允许实体被定义被模块中的任意源文件访问，同样可以被另一模块的源文件通过导入该定义模块来访问。在指定框架的公共接口时，通常使用open或public访问。open和public访问 之间的区别将在之后给出。 Internal访问 允许实体被定义模块中的任意源文件访问，但不能被该模块之外的任意源文件访问。通常在定义程序或是框架的内部结构时使用。 private访问 将实体的使用限制于封闭声明中。当一些细节仅在单独的声明中使用时，使用private访问隐藏特定功能的实现细节。 open访问时最高的（限制最少）访问级别，private是最低的（限制最多的）访问级别。 open访问仅适用于类和类成员，他与public访问区别如下： public访问，或任何更严格的访问级别的类，只能在其定义模块中被继承。 public访问，或任何更严格的访问级别的类成员，只能被其定义模块的子类重写。 open类可以在其定义的模块中被继承，也可在任何导入定义模块的其他模块中被继承。 open类成员可以在其定义的模块的子类重写，也可以被导入其定义模块的任何模块重写。 显式地标记类为 open 意味着你考虑过其他模块使用该类作为父类对代码的影响，并且相应地设计了类的代码。 访问级别的指导准则Swift 中的访问级别遵循一个总体指导准则：实体不可以被更低（限制更多）访问级别的实体定义。 例如： 一个 public 的变量其类型的访问级别不能是 internal, file-private 或是 private，因为在使用 public 变量的地方可能没有这些类型的访问权限。 一个函数不能比它的参数类型和返回类型访问级别高，因为函数可以使用的环境而其参数和返回类型却不能使用。 默认访问级别如果你不指明访问级别的话，你的代码中的所有实体（以及本章后续提及的少数例外）都会默认为 internal 级别。因此，大多数情况下你不需要明确指定访问级别。 单目标应用的访问级别当你编写一个简单的单目标应用时，你的应用中的代码都是在本应用中使用的并且不会在应用模块之外使用。默认的 internal 访问级别已经匹配了这种需求。因此，你不需要明确自定访问级别。但你可能会将代码的一些部分标注为 file private 或private 以对模块中的其他代码隐藏它们的实现细节。 框架的访问级别当你开发一个框架时，将该框架的面向公众的接口标注为 open 或 public，这样它就能被其他的模块看到或访问，比如导入该框架的应用。这个面相公众的接口就是该框架的应用编程接口（API）。 注意 你框架的任何内部实现细节仍可以使用 internal 默认访问级别，如果你想从框架的其他部分隐藏细节也可以将它们标注为 private 或 file private 。仅当你想将它设为框架的API时你才能将实体标注为 open 或 public 。 单元测试目标的访问级别当你在写一个有单元测试目标的应用时，你的代码应该能被模块访问到以进行测试。默认情况下只有标注为 open 或 public 的才可以被其他模块访问。但是，如果你使用 @testable 属性标注了导入的生产模块并且用使能测试的方式编译了这个模块，单元测试目标就能访问任何 internal 的实体。 访问控制语法通过在实体的引入之前添加 open ， public ， internal ， fileprivate ，或 private 修饰符来定义访问级别。 123456789public class SomePublicClass &#123;&#125;internal class SomeInternalClass &#123;&#125;fileprivate class SomeFilePrivateClass &#123;&#125;private class SomePrivateClass &#123;&#125; public var somePublicVariable = 0internal let someInternalConstant = 0fileprivate func someFilePrivateFunction() &#123;&#125;private func somePrivateFunction() &#123;&#125; 除非已经标注，否则都会使用默认的 internal 访问级别，这一点在[默认访问级别]一节已经说明。这意味着 SomeInternalClass 和 someInternalConstant 不需要指明访问级别也会是 internal 级别。 123class SomeInternalClass &#123;&#125; // implicitly internal let someInternalConstant = 0 // implicitly internal 自定类型如果你想给自定类型指明访问级别，那就在定义时指明。只要访问级别允许，新类型就可以被使用。例如，你定义了一个 file-private 的类，它就只能在定义文件中被当作属性类型、函数参数或返回类型使用。 类型的访问控制级别也会影响它的成员的默认访问级别（它的属性，方法，初始化方法，下标）。如果你将类型定义为 private 或 file private 级别，那么它的成员的默认访问级别也会是 private 或file private。如果你将类型定义为 internal 或 public级别（或直接使用默认级别而不显式指出），那么它的成员的默认访问级别会是 internal 。 重要public 的类型默认拥有 internal 级别的成员，而不是 public。如果你想让其中的一个类型成员是 public 的，你必须按实示例代码指明。这个要求确保类型的面向公众的 API 是你选择的，并且可以避免将类型的内部工作细节公开成 API 的失误。 123456789101112131415161718192021public class SomePublicClass &#123; // explicitly public class public var somePublicProperty = 0 // explicitly public class member var someInternalProperty = 0 // implicitly internal class member fileprivate func someFilePrivateMethod() &#123;&#125; // explicitly file-private class member private func somePrivateMethod() &#123;&#125; // explicitly private class member&#125; class SomeInternalClass &#123; // implicitly internal class var someInternalProperty = 0 // implicitly internal class member fileprivate func someFilePrivateMethod() &#123;&#125; // explicitly file-private class member private func somePrivateMethod() &#123;&#125; // explicitly private class member&#125; fileprivate class SomeFilePrivateClass &#123; // explicitly file-private class func someFilePrivateMethod() &#123;&#125; // implicitly file-private class member private func somePrivateMethod() &#123;&#125; // explicitly private class member&#125; private class SomePrivateClass &#123; // explicitly private class func somePrivateMethod() &#123;&#125; // implicitly private class member&#125; 元组类型元组类型的访问级别是所有类型里最严格的。例如，如果你将两个不同类型的元素组成一个元组，一个元素的访问级别是 internal，另一个是 private，那么这个元组类型是 private 级别的。 注意元组类型不像类、结构体、枚举和函数那样有一个单独的定义。元组类型的访问级别会在使用的时候被自动推断出来，不需要显式指明。 函数类型函数类型的访问级别由函数成员类型和返回类型中的最严格访问级别决定。如果函数的计算访问级别与上下文环境默认级别不匹配，你必须在函数定义时显式指出。 下面的例子定义了一个称为someFunction() 的全局函数，而没有指明它的访问级别。你或许以为它会是默认的 “internal” 级别，但事实不是这样。这样的 someFuniction()是无法通过编译的： 123func someFunction() -&gt; (SomeInternalClass, SomePrivateClass) &#123; // function implementation goes here&#125; 这个函数的返回类型是一个由两个在自定义类型里定义的类组成的元组。其中一个类是 “internal” 级别的，另一个是 “private”。因此，这个元组的访问级别是“private”（元组成员的最严级别）。 由于返回类型是 private 级别的，你必须使用 private 修饰符使其合法: 123private func someFunction() -&gt; (SomeInternalClass, SomePrivateClass) &#123; // function implementation goes here&#125; 使用 public 或 internal 标注someFunction() 的定义是无效的，使用默认的 internal 也是无效的，7的函数可能无法访问到 private 的函数返回值。 枚举类型枚举中的独立成员自动使用该枚举类型的访问级别。你不能给独立的成员指明一个不同的访问级别。 在下面的例子中 CompassPoint 有一个指明的“public”级别。里面的成员 north , south , east , 和 west因此是“public”： 123456public enum CompassPoint &#123; case north case south case east case west&#125; 原始值和关联值枚举定义中的原始值和关联值使用的类型必须有一个不低于枚举的访问级别。例如，你不能使用一个 private 类型作为一个 internal 级别的枚举类型中的原始值类型。 嵌套类型private 级别的类型中定义的嵌套类型自动为 private 级别。fileprivate 级别的类型中定义的嵌套类型自动为 fileprivate 级别。public 或 internal 级别的类型中定义的嵌套类型自动为 internal 级别。如果你想让嵌套类型是 public 级别的，你必须将其显式指明为 public。 子类你可以继承任何类只要是在当前可以访问的上下文环境中。但子类不能高于父类的访问级别，例如，你不能写一个 internal 父类的 public 子类。 而且，你可以重写任何类成员（方法，属性，初始化器或下标），只要是在确定的访问域中是可见的。 重写可以让一个继承类成员比它的父类中的更容易访问。在下例中，public 级别的类 A 有一个 fileprivate 级别的 someMethod() 函数。 B 是 A 的子类，有一个降低的“internal”级别。但是，类 B 对 someMethod() 函数进行了重写即改为“internal”级别，这比 someMethod() 的原本实现级别更高： 123456public class A &#123; fileprivate func someMethod() &#123;&#125;&#125;internal class B: A &#123; override internal func someMethod() &#123;&#125;&#125; 子类成员调用父类中比子类更低访问级别的成员，只要这个调用发生在一个允许的访问级别上下文中（即对 fileprivate 成员的调用要求父类在同一个源文件中，对 internal 成员的调用要求父类在同一个模块中）： 12345678public class A &#123; fileprivate func someMethod() &#123;&#125;&#125;internal class B: A &#123; override internal func someMethod() &#123; super.someMethod() &#125;&#125; 因为父类 A 和子类 B 定义在同一个源文件中，那么 B 类可以在 someMethod() 中调用父类的 someMethod()。 常量，变量，属性和下标常量、变量、属性不能拥有比它们类型更高的访问级别。例如，你不能写一个public 的属性而它的类型是 private 的。类似的，下标也不能拥有比它的索引类型和返回类型更高的访问级别。 如果常量、变量、属性或下标由private类型组成，那么常量、变量、属性或下标也要被标注为 private ： 1private var privateInstance = SomePrivateClass() Getters 和 Setters常量、变量、属性和下标的 getter 和 setter 自动接收它们所属常量、变量、属性和下标的访问级别。 你可以给 setter 函数一个比相对应 getter 函数更低的访问级别以限制变量、属性、下标的读写权限。你可以通过在 var 和 subscript 的置入器之前书写 fileprivate(set) , private(set), 或 internal(set) 来声明更低的访问级别。 注意这个规则应用于存储属性和计算属性。即使你没有给一个存储属性书写一个明确的 getter 和 setter，Swift 会为你合成一个 getter 和 setter 以访问到存储属性的隐式存储。使用 fileprivate(set) , private(set) 和 internal(set) 可以改变这个合成的 setter 的访问级别，同样也可以改变计算属性的访问级别。 下面的例子定义了一个称为 TrackedString 的结构体，它保持追踪一个字符串属性的修改次数： 12345678struct TrackedString &#123; private(set) var numberOfEdits = 0 var value: String = &quot;&quot; &#123; didSet &#123; numberOfEdits += 1 &#125; &#125;&#125; TrackedString 结构体定义了一个可存储字符串的属性 value ，它又一个初始值 “” （空字符串）。这个结构图同样定义了一个可存储整数的属性 numberOfEdits ，它被用于记录 value 的修改次数。这个记录由 value 属性中的didset属性实现，它会增加 numberOfEdits 的值一旦 value 被设为一个新值。 TrackedString 结构体和 value 属性都没有显式指出访问级别修饰符，因此它们都遵循默认的 internal 级别。 numberOfEdits 属性的访问级别已经标注为private(set) 以说明这个属性的 getter 是默认的 internal 级别，但是这个属性只能被 TrackedString 内的代码设置。这允许 TrackedString 在内部修改 numberOfEdits 属性，而且可以展示这个属性作为一个只读属性当在结构体定义之外使用时——包括 TrackedString 的扩展。 如果你创建了一个 TrackedString 的实例并修改了几次字符串的值，你可以看到 numberOfEdits 属性的值更新到匹配修改的次数： 123456var stringToEdit = TrackedString()stringToEdit.value = &quot;This string will be tracked.&quot;stringToEdit.value += &quot; This edit will increment numberOfEdits.&quot;stringToEdit.value += &quot; So will this one.&quot;print(&quot;The number of edits is \(stringToEdit.numberOfEdits)&quot;)// Prints &quot;The number of edits is 3&quot; 尽管你可以从别的源文件中询问到 numberOfEdits 属性的当前值，但你不能从别的源文件中修改该属性的值。这个限制保护了 TrackedString 编辑追踪功能的实现细节，并同时为该功能的一个方面提供方便的访问。 你若有必要也可以显式指明 getter 和 setter方法。下面的例子提供了一个定义为 public 级别的 TrackedString 结构体。结构体成员（包括 numberOfEdits 属性）因此有一个默认的 internal 级别。你可以设置 numberOfEdits 属性的getter方法为 public，setter 方法为 private 级别，通过结合 public 和 private(set) 访问级别修饰符： 123456789public struct TrackedString &#123; public private(set) var numberOfEdits = 0 public var value: String = &quot;&quot; &#123; didSet &#123; numberOfEdits += 1 &#125; &#125; public init() &#123;&#125;&#125; 初始化器我们可以给自定义初始化方法设置一个低于或等于它的所属的类的访问级别。唯一的例外是必要初始化器（定义在必要初始化器）。必要初始化器必须和它所属类的访问级别一致。 就像函数和方法的参数一样，初始化器的参数类型不能比初始化方法的访问级别还低。 默认初始化器正如默认初始化器中描述的那样，Swift 自动为任何结构体和类提供一个无参数的默认初始化方法，以给它的属性提供默认值但不会提供给初始化器自身。 默认初始化方法与所属类的访问级别一致，除非该类型定义为 public 。如果一个类定义为 public ，那么默认初始化方法为 internal 级别。如果你想一个 public 类可以被一个无参初始化器初始化当在另一个模块中使用时，你必须显式提供一个 public 的无参初始化方法。 结构体的默认成员初始化器如果结构体的存储属性时 private 的，那么它的默认成员初始化方法就是 private 级别。如果结构体的存储属性时 file private 的，那么它的默认成员初始化方法就是 file private 级别。否则就是默认的 internal 级别。正如以上默认初始化的描述，如果你想在另一个模块中使用结构体的成员初始化方法，你必须提供在定义中提供一个 public 的成员初始化方法。 协议如果你想给一个协议类型分配一个显式的访问级别，那就在定义时指明。这让你创建的协议可以在一个明确的访问上下文中被接受。 协议定义中的每一个要求的访问级别都自动设为与该协议相同。你不能将一个协议要求的访问级别设为与协议不同。这保证协议的所有要求都能被接受该协议的类型所见。 注意如果你定义了一个 public 的协议，该协议的规定要求在被实现时拥有一个 public 的访问级别。这个行为不同于其他类型，一个 public 的类型的成员时 internal 访问级别。 协议继承如果你定义了一个继承已有协议的协议，这个新协议最高与它继承的协议访问级别一致。例如你不能写一个 public 的协议继承一个 internal 的协议。 协议遵循类型可以遵循更低访问级别的协议。例如，你可以定义一个可在其他模块使用的 public 类型，但它就只能在定义模块中使用如果遵循一个 internal 的协议。 遵循了协议的类的访问级别取这个协议和该类的访问级别的最小者。如果这个类型是 public 级别的，它所遵循的协议是 internal 级别，这个类型就是 internal 级别的。 当你写或是扩张一个类型以遵循协议时，你必须确保该类按协议要求的实现方法与该协议的访问级别一致。例如，一个 public 的类遵循一个 internal 协议，该类的方法实现至少是 “internal” 的。 注意在 Swift 和 Objective-C 中协议遵循是全局的——一个类不可能在一个程序中用不同方法遵循一个协议。 扩展你可以在任何可访问的上下文环境中对类、结构体、或枚举进行扩展。在扩展中添加的任何类型成员都有着被扩展类型相同的访问权限。如果你扩展一个公开或者内部类型，你添加的任何新类型成员都拥有默认的内部访问权限。如果你扩展一个文件内私有的类型，你添加的任何新类型成员都拥有默认的私有访问权限。如果你扩展一个私有类型，你添加的任何新类型成员都拥有默认的私有访问权限。 或者，你可以显式标注扩展的访问级别（例如， private extension ）已给扩展中的成员设置新的默认访问级别。这个默认同样可以在扩展中为单个类型成员重写。 你不能给用于协议遵循的扩展显式标注访问权限修饰符。相反，在扩展中使用协议自身的访问权限作为协议实现的默认访问权限。 扩展中的私有成员在同一文件中的扩展比如类、结构体或者枚举，可以写成类似多个部分的类型声明。你可以： 在原本的声明中声明一个私有成员，然后在同一文件的扩展中访问它； 在扩展中声明一个私有成员，然后在同一文件的其他扩展中访问它； 在扩展中声明一个私有成员，然后在同一文件的原本声明中访问它。 这样的行为意味着你可以和组织代码一样使用扩展，无论你的类型是否拥有私有成员。比如说，假设下面这样的简单协议： 123protocol SomeProtocol &#123; func doSomething()&#125; 你可以使用扩展来添加协议遵循，比如这样： 123456789struct SomeStruct &#123; private var privateVariable = 12&#125; extension SomeStruct: SomeProtocol &#123; func doSomething() &#123; print(privateVariable) &#125;&#125; 泛型泛指类型和泛指函数的访问级别取泛指类型或函数以及泛型类型参数的访问级别的最小值。 类型别名任何你定义的类型同义名都被视为不同的类型以进行访问控制。一个类型同义名的访问级别不高于原类型。例如，一个 private 的类型同义名可联系到 private ，file-private ，internal ，public 或open 的类型，但 public 的类型同义名不可联系到 internal ，file-private 或 private 类型。 注意这条规则适用于为满足协议遵循而给类型别名关联值的情况。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[23个经典设计模式的Swift实现]]></title>
    <url>%2F2018%2F04%2F16%2FDesign%20Mode%2F23%E4%B8%AA%E7%BB%8F%E5%85%B8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84Swift%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[前言 这是一篇主观的文章，文字解释也尽可能简单，写作目的是一次团队内的知识分享，想让不了解设计模式的同事迅速对这些生词混个脸熟。所以本文适合懂Swift语法，想快速了解23个设计模式大概在讲什么的同学。 基本结构 比喻 让我联想到的一些事物 官方定义 原版定义 UML 不是原版UML 只保留了我觉得核心的部分 代码 Swift实现，这个是本体 讲解 假设已经看过代码的一些零散评注 目录 Creational 创建型 5 Abstract Factory 抽象工厂模式 Builder 建造者模式 Factory Method 工厂方法模式 Prototype 原型模式 Singleton 单例模式 Structural 结构型 7 Adapter 适配器模式 Bridge 桥接模式 Composite 组合模式 Decorator 装饰者模式 Facade 外观模式 Flyweight 享元模式 Proxy 代理模式 Behavioral 行为型 11 Chain of responsibility 责任链模式 Command 命令模式 Interpreter 解释器模式 Iterator 迭代器模式 Mediator 中介模式 Memento 备忘录模式 Observer 观察者模式 State 状态模式 Strategy 策略模式 Template Method 模板方法模式 Visitor 访问者模式 工厂模式 工厂模式顾名思义，就像一个工厂生产你所需要的产品 配图：http://cdn1.alphr.com/sites/alphr/files/2016/02/tesla_factory_tour_1.jpg 无工厂 Non-Factory也就是工厂问题想解决的原始问题。 12345678910111213141516protocol Product&#123;&#125;class ConcreteProductA: Produce &#123;&#125;class ConcreteProductB: Produce &#123;&#125;class Client &#123; func createProduct(type: Int) -&gt; Produce &#123; if type == 0 &#123; return ConcreteProductA() &#125; else &#123; return ConcreteProductB() &#125; &#125;&#125;let c = Client()c.createProduct(type: 0) // get ConcreteProductA 从代码和UML可以看出，为了得到产品A，调用者Client要同时依赖Product, ConcreteProductA和ConcreteProductB，并亲自写一个创建产品的方法。 每当需求新增一个产品，就要改动到调用方Client。如果这一堆创建代码如果可以抽离出去就好了，于是简单工厂出现了。 简单工厂 Simple Factory简单工厂就做了一件事，把Client要做的创建工作，挪到了另一个类里。 1234567891011121314151617181920protocol Product&#123;&#125;class ConcreteProductA: Produce &#123;&#125;class ConcreteProductB: Produce &#123;&#125;class Client &#123; let s = Factory()&#125;class Factory &#123; func createProduct(type: Int) -&gt; Product &#123; if type == 0 &#123; return ConcreteProductA() &#125; else &#123; return ConcreteProductA() &#125; &#125;&#125;let c = Client()c.s.createProduct(type: 0) // get ConcreteProductA Factory代替了Client对具体Product的依赖，那么当需求变化的时候，我们不再需要改动调用方。这固然有所进步，但无法避免的是，每次变动都要在createProduct的方法内部新增一个if-else分支，这显然违背了开闭原则。 为了解决这个问题，我们引入另一个模式。 工厂方法 Factory Method官方定义 定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。 123456789101112131415161718192021222324252627282930313233343536protocol Product&#123;&#125;class ConcreteProductA: Produce &#123;&#125;class ConcreteProductB: Produce &#123;&#125;class Client &#123; let f = Factory()&#125;class Factory &#123; func createProduct() -&gt; Product? &#123; return nil &#125; //用于继承 func createProduct(type: Int) -&gt; Product? &#123; //用于调用 if type == 0 &#123; return ConcreteFactoryA().createProduct() &#125; else &#123; return ConcreteFactoryB().createProduct() &#125; &#125;&#125;class ConcreteFactoryA: Factory &#123; override func createProduct() -&gt; Product? &#123; // ... 产品加工过程 return ConcreteProductA() &#125;&#125;class ConcreteFactoryB: Factory &#123; override func createProduct() -&gt; Product? &#123; // ... 产品加工过程 return ConcreteProductB() &#125;&#125;let c = Client()c.f.createProduct(type: 0) // get ConcreteProductA 对于工厂方法的实现，有众多不同的解法，比如Factory只保留一个createProduct让子类实现，让Client来选择生成哪个具体工厂实例；或是引入一个FactoryMaker的中间层，作为生产工厂的“简单工厂”。我这里采用的方式是Factory既作为工厂父类，让具体工厂决定生产生么产品，又作为接口类，让Client可以通过依赖注入选择特定工厂。我这样做的目的是，在不引入新的中间层的情况下，最小化Client的依赖。 工厂方法在简单工厂的基础上做了两件事： 多了一层抽象，把生产产品的工作延迟到子类执行。 把“选择如何生产产品的工作”转化为“选择让哪个具体工厂生产”。 工厂方法的贡献在于，这样做虽然不能完美避免对一个if-else的扩展，但是这个扩展规模被极大限制住了（只需要new一个类）。 工厂方法着重点是解决了单一产品线的派生问题。那如果有多个相关产品线呢？ 抽象工厂 Abstract Factory官方定义 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758protocol ProductA &#123;&#125;class ConcreteProductA1: ProductA &#123;&#125;class ConcreteProductA2: ProductA &#123;&#125;protocol ProductB &#123;&#125;class ConcreteProductB1: ProductB &#123;&#125;class ConcreteProductB2: ProductB &#123;&#125;class Client &#123; let f = Factory()&#125;class Factory &#123; func createProductA() -&gt; ProductA? &#123; return nil &#125; // 用于继承 func createProductB() -&gt; ProductB? &#123; return nil &#125; // 用于继承 func createProductA(type: Int) -&gt; ProductA? &#123; // 用于调用 if type == 0 &#123; return ConcreteFactory1().createProductA() &#125; else &#123; return ConcreteFactory2().createProductA() &#125; &#125; func createProductB(type: Int) -&gt; ProductB? &#123; // 用于调用 if type == 0 &#123; return ConcreteFactory1().createProductB() &#125; else &#123; return ConcreteFactory2().createProductB() &#125; &#125;&#125;class ConcreteFactory1: Factory &#123; override func createProductA() -&gt; ProductA? &#123; // ... 产品加工过程 return ConcreteProductA1() &#125; override func createProductB() -&gt; ProductB? &#123; // ... 产品加工过程 return ConcreteProductB1() &#125;&#125;class ConcreteFactory2: Factory &#123; override func createProductA() -&gt; ProductA? &#123; // ... 产品加工过程 return ConcreteProductA2() &#125; override func createProductB() -&gt; ProductB? &#123; // ... 产品加工过程 return ConcreteProductB2() &#125;&#125;let c = Client()c.f.createProductA(type: 0) // get ConcreteProductA1c.f.createProductA(type: 1) // get ConcreteProductA2c.f.createProductB(type: 0) // get ConcreteProductB1c.f.createProductB(type: 1) // get ConcreteProductB2 图很吓人，其实很简单。 当我们有两个相关的产品线ProductA和ProductB, 例如螺丝和螺母，他们派生出ProductA1，ProductB1 和 ProductA2，ProductB2，前者我们由工厂ConcreteFactory1来制作，后者由 ConcreteFactory2来制作。 对于Client来说，他只需要知道有一个抽象的工厂能同时生产ProductA和ProductB就行了，那就是图中的Factory。 重点来了，这个抽象的Factory是通过“工厂方法”模式把构造过程延迟到子类执行的，也就是说，抽象工厂是建立在工厂方法的基础上的模式。所以抽象工厂，换句话说，就是多个产品线需要绑定在一起，形成一个抽象的综合工厂，由具体的综合工厂来批量实现“工厂方法”的一种更“高级”的模式。 总结有点绕，说完这些感觉我已经中文十级了。总之，我想表达的观点是：这些工厂模式并不是割裂的存在，而是一个递进的思想。 Builder 建造者模式 建造者模式就像你委托一个室内设计师装修你的新家 配图: http://tse2.mm.bing.net/th?id=OIP.N3hIhcOq32Bh6Ezi6q6kGwHaFj&amp;pid=Api 官方定义 将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。 如果说之前的谈到的工厂模式是把创建产品(对象)的工作抽离出去的话，这次要聊的建造者模式，就是把产品内部的组件生产工作抽离出去。这样做的场景，适用于那些有着复杂、规则模块的对象生成流程。换句话说，工厂模式是一个类(工厂)创建另一个类(产品)，而建造者是一个类(产品)自身的属性(组件)构造过程。 对于建造者模式的实现网上也是版本不一：复杂点的版本会引入一个Director的角色，做一个整体上下文，组装更傻瓜化的builder和product。或是抽象一层Builder协议，用不同的具体Builder来构造不同的产品。但我认为这些都模糊了这个模式要传达的焦点，对理解没有帮助，所以这里我选择一个极简的模型。 123456789101112131415161718struct Builder &#123; var partA: String var partB: String&#125;struct Product &#123; var partA: String var partB: String init(builder: Builder) &#123; partA = builder.partA partB = builder.partB &#125;&#125;// 通过builder完成产品创建工作let b = Builder(partA: &quot;A&quot;, partB: &quot;B&quot;)// 这样产品只需要一个builder就可以完成制作let p = Product(builder: b) 我们让Product的生成由自己发起，但是它的组件(属性)全都委托给Builder来实现，而它只需要依赖一个Builder就完成了自身的生产工作。 Prototype 原型模式 原型模式让你有了一个可以源源不断自我赋值的类。 配图: http://thumbs.dreamstime.com/z/cell-division-two-cells-divide-osmosis-background-other-cells-48181492.jpg 官方定义 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 原型模式很简单，你只要实现一个返回你自己的新对象的方法即可。这里我采用的实现还不是最简单的，这个interface并不是必须的。 原型模式实现了深拷贝。 1234567891011121314protocol Prototype &#123; func clone() -&gt; Prototype&#125;struct Product: Prototype &#123; var title: String func clone() -&gt; Prototype &#123; return Product(title: title) &#125;&#125;let p1 = Product(title: &quot;p1&quot;)let p2 = p1.clone()(p2 as? Product)?.title // OUTPUT: p1 Singleton 单例模式 单例就像一个公司的IT部门，他们是唯一的存在，并且被所有人直接访问。 配图：The IT Crowd 官方定义 保证一个类仅有一个实例，并提供一个访问它的全局访问点。 因为第二点常常被忽视，所以过度使用的危害极大，你无从知道调用从何而来，这种goto一般的存在会变成维护的噩梦。 单例比较常见的应用是例如数据库，网络框架的全局访问点。 单例其实就是变种的原型模式，只不过原型每次返回的是一个拷贝。 Swift的简单实现： 12345678class Singleton &#123; static let sharedInstance = Singleton() private init() &#123; // 用private防止被new &#125;&#125;let s = Singleton.sharedInstancelet s2 = Singleton() // ERROR: initializer is inaccessible due to &apos;private&apos; protection level Swift的完整实现： 12345678910111213class Singleton &#123; static var singleton: Singleton? = nil private init() &#123;&#125; static func sharedInstance() -&gt; Singleton &#123; if singleton == nil &#123; singleton = Singleton() &#125; return singleton! &#125;&#125;let s = Singleton.sharedInstance()let s2 = Singleton() // ERROR: initializer is inaccessible due to &apos;private&apos; protection level]]></content>
      <categories>
        <category>iOS</category>
        <category>Design Mode</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
        <tag>Design Mode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[YTKNetwork源码解析]]></title>
    <url>%2F2018%2F04%2F10%2FiOS%2F%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2FYTKNetwork%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[作为一名iOS开发工作者，大家应该都听过YTKNetwork框架吧。它是猿题库技术团队开源的一个网络请求框架，内部封装了AFNetworking。它把每个请求实例化，管理它的生命周期，也可以管理多个请求。 在正式讲解源码之前，我会先讲一下该框架所用的架构和设计模式。我总觉得对架构和设计有一定的了解的话，会有助于对源码的理解。 1. 架构 先上图： 在这里简单说明一下： YTKNetwork框架将每一个请求实例化，YTKBaseRequest是所有请求类的基类，YTKRequest是它的子类。所以如果我们想要发送一个请求，则需要创建并实例化一个继承于YTKRequest的自定义的请求类（CustomRequest）并发送请求。 YTKNetworkAgent是一个单例，负责管理所有的请求类（例如CustomRequest）。当CustomRequest发送请求以后，会把自己放在YTKNetworkAgent持有的一个字典里，让其管理自己。 我们说YTKNetwork封装了AFNetworking，实际上是YTKNetworkAgent封装了AFNetworking，由它负责AFNetworking请求的发送和AFNetworking的回调处理。所以如果我们想更换一个第三方网络请求库，就可以在这里更换一下。而YTKRequest更多的是只是负责缓存的处理。 YTKNetworkConfig与YTKPriviate的具体职能现在不做介绍，会在后文给出。 OK，现在我们知道了YTKNetwork中类与类之间的关系以及关键类的大致职能，接下来我会告诉你YTKNetwork为什么会采用这种关系来架构，以及采用这种架构会有什么好处。 2. 设计模式 YTKNetwork框架采用的设计模式是命令模式（Command Pattern）。 首先看一下命令模式的定义： 命令模式将请求封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。摘自：《Head First 设计模式》 看一下命令模式的类图： 图中英文的含义： 英文 中文 Command 抽象命令类 ConcreteCommand 命令类的实现类（子类） Invoker 调用者 Receiver 命令接收者（执行者) Client 客户端 详细介绍一下： 命令模式的本质是对命令的封装，将发出命令的责任和执行命令的责任分割开。 命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。 可能还是觉得有点抽象，在这里举一个《Head First 设计模式》里的例子，一个客人在餐厅点餐的过程： 你将点的菜写在订单里，交给了服务员。 服务员将订单交给厨师。 厨师做好菜之后将做好的菜交给服务员。 最后服务员把菜递给你。 在这里，命令就好比是订单，而你是命令的发起者。你的命令（订单）通过服务员（调用者）交给了命令的执行者（厨师）。所以至于这道菜具体是谁做，怎么做，你是不知道的，你做的只是发出命令和接受结果。而且对于餐厅来说，厨师是可以随便换的，而你可能对此一无所知。反过来，厨师只需要好好把菜做好，至于是谁点的菜也不需要他考虑。 结合上面命令模式的类图以及餐厅点餐的例子，我们来理清一下YTKNetwork内部的职能 场景 Command ConcreteCommand Invoker Receiver Client 餐厅 空白订单 填入菜名的订单 服务员 厨师 客人 YTKNetwork YTKBaseRequest CustomRequest YTKNetworkAgent AFNetworking ViewController/ViewModel 可以看到，YTKNetwork对命令模式的实现是很符合其设计标准的，它将请求的发起者和接收者分离开来(中间隔着调用者)，可以让我们随时更换接受者。 另外，因为封装了请求，我们既可以管理单个请求，也可以同时管理多个请求，甚至实现琏式请求的发送。关于多个请求的发送，我们也可以想象在餐厅里，你可以在吃的过程中还想起来要吃别的东西，例如点心，饮料之类的，你就可以填多个订单（当然也可以写在一起）交给服务员。 相信到这里，大家应该对YTKNetwork的设计与架构有了足够的认识了，下面进入到真正的源码解析，我们结合一下它的代码来看一下YTKNetwork是如何实现和管理网络请求的。 3. 源码解析 在真正讲解源码之前，我先详细说一下各个类的职责: 3.1 责任介绍 类名 职责 YTKBaseRequest 所有请求类的基类。持有NSURLSessionTask实例，responseData，responseObject，error等重要数据，提供一些需要子类实现的与网络请求相关的方法，处理回调的代理和block，命令YTKNetworkAgent发起网络请求。 YTKRequest YTKBaseRequest的子类。负责缓存的处理：请求前查询缓存；请求后写入缓存。 YTKNetworkConfig 被YTKRequest和YTKNetworkAgent访问。负责所有请求的全局配置，例如baseUrl和CDNUrl等等。 YTKNetworkPrivate 提供JSON验证，appVersion等辅助性的方法；给YTKBaseRequest增加一些分类。 YTKNetworkAgent 真正发起请求的类。负责发起请求，结束请求，并持有一个字典来存储正在执行的请求。 YTKBatchRequest 可以发起批量请求，持有一个数组来保存所有的请求类。在请求执行后遍历这个数组来发起请求，如果其中有一个请求返回失败，则认定本组请求失败。 YTKBatchRequestAgent 负责管理多个YTKBatchRequest实例，持有一个数组来保存YTKBatchRequest。支持添加和删除YTKBatchRequest实例。 YTKChainRequest 可以发起链式请求，持有一个数组来保存所有的请求类。当某个请求结束后才能发起下一个请求，如果其中有一个请求返回失败，则认定本请求链失败。 YTKChainRequestAgent 负责管理多个YTKChainRequestAgent实例，持有一个数组来保存YTKChainRequest。支持添加和删除YTKChainRequest实例。 OK，现在知道了YTKNetwork内部的责任分配，下面我们先从单个请求的全部流程（配置，发起，结束）来看一下YTKNetwork都做了什么。 3.2 单个请求3.21 单个请求的配置官方的教程建议我们将请求的全局配置是在AppDelegate.m文件里，设定baseUrl以及cdnUrl等参数。 1234567- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; YTKNetworkConfig *config = [YTKNetworkConfig sharedConfig]; config.baseUrl = @&quot;http://yuantiku.com&quot;; config.cdnUrl = @&quot;http://fen.bi&quot;;&#125; 如果我们需要新建一个注册的请求，则需要创建一个继承于YTKRequest的注册接口的类RegisterApi，并将针对该请求参数配置好： 12345678910111213141516171819202122232425262728293031323334353637// RegisterApi.h#import &quot;YTKRequest.h&quot;@interface RegisterApi : YTKRequest- (id)initWithUsername:(NSString *)username password:(NSString *)password;@end// RegisterApi.m#import &quot;RegisterApi.h&quot;@implementation RegisterApi &#123; NSString *_username; NSString *_password;&#125;//初始化的时候将两个参数值传入- (id)initWithUsername:(NSString *)username password:(NSString *)password &#123; self = [super init]; if (self) &#123; _username = username; _password = password; &#125; return self;&#125;//需要和baseUrl拼接的地址- (NSString *)requestUrl &#123; // “ http://www.yuantiku.com ” 在 YTKNetworkConfig 中设置，这里只填除去域名剩余的网址信息 return @&quot;/iphone/register&quot;;&#125;//请求方法，某人是GET- (YTKRequestMethod)requestMethod &#123; return YTKRequestMethodPOST;&#125;//请求体- (id)requestArgument &#123; return @&#123; @&quot;username&quot;: _username, @&quot;password&quot;: _password &#125;;&#125;@end 现在我们知道如何配置全局的参数和针对某个请求的参数了，接下来看一下单个请求是如何发起的。 3.22 单个请求的发起还是刚才的注册API，在实例化以后，直接调用startWithCompletionBlockWithSuccess:failure方法（或start方法）就可以发起它： 123456789101112131415//LoginViewController.m- (void)loginButtonPressed:(id)sender &#123; NSString *username = self.UserNameTextField.text; NSString *password = self.PasswordTextField.text; if (username.length &gt; 0 &amp;&amp; password.length &gt; 0) &#123; RegisterApi *api = [[RegisterApi alloc] initWithUsername:username password:password]; [api startWithCompletionBlockWithSuccess:^(YTKBaseRequest *request) &#123; // 你可以直接在这里使用 self NSLog(@&quot;succeed&quot;); &#125; failure:^(YTKBaseRequest *request) &#123; // 你可以直接在这里使用 self NSLog(@&quot;failed&quot;); &#125;]; &#125;&#125; 上面是以block的形式回调，YTKNetwork也支持代理的回调： 12345678910111213141516//LoginViewController.m- (void)loginButtonPressed:(id)sender &#123; NSString *username = self.UserNameTextField.text; NSString *password = self.PasswordTextField.text; if (username.length &gt; 0 &amp;&amp; password.length &gt; 0) &#123; RegisterApi *api = [[RegisterApi alloc] initWithUsername:username password:password]; api.delegate = self; [api start]; &#125;&#125;- (void)requestFinished:(YTKBaseRequest *)request &#123; NSLog(@&quot;succeed&quot;);&#125;- (void)requestFailed:(YTKBaseRequest *)request &#123; NSLog(@&quot;failed&quot;);&#125; 有两点需要注意的是： 必须给自定义请求类（RegisterApi）调用startWithCompletionBlockWithSuccess:failure方法（或start方法），才能真正发起请求。 在同时设置了回调代理和回调block的情况下，首先回调的是回调代理方法，然后再走回调block。 知道了YTKRequest请求是如何在外部发起的，我们现在从startWithCompletionBlockWithSuccess:failure方法开始，来看一下YTKNetwork都做了什么： 首先来到YTKBaseRequest类（因为最早是由它定义的该方法）： 123456789101112131415//YTKBaseRequest.m//传入成功和失败的block,并保存起来- (void)startWithCompletionBlockWithSuccess:(YTKRequestCompletionBlock)success failure:(YTKRequestCompletionBlock)failure &#123; //保存成功和失败的回调block，便于将来调用 [self setCompletionBlockWithSuccess:success failure:failure]; //发起请求 [self start];&#125;//保存成功和失败的block- (void)setCompletionBlockWithSuccess:(YTKRequestCompletionBlock)success failure:(YTKRequestCompletionBlock)failure &#123; self.successCompletionBlock = success; self.failureCompletionBlock = failure;&#125; 当保存完成功和失败的block以后，调用start方法，于是来到了YTKRequest类（注意，虽然YTKBaseRequest也实现了start方法，但是由于YTKRequest类是它的子类并也实现了start方法，所以这里最先走的是YTKRequest类的start方法）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344//YTKRequest.m- (void)start &#123; //1. 如果忽略缓存 -&gt; 请求 if (self.ignoreCache) &#123; [self startWithoutCache]; return; &#125; //2. 如果存在下载未完成的文件 -&gt; 请求 if (self.resumableDownloadPath) &#123; [self startWithoutCache]; return; &#125; //3. 获取缓存失败 -&gt; 请求 if (![self loadCacheWithError:nil]) &#123; [self startWithoutCache]; return; &#125; //4. 到这里，说明一定能拿到可用的缓存，可以直接回调了（因为一定能拿到可用的缓存，所以一定是调用成功的block和代理） _dataFromCache = YES; dispatch_async(dispatch_get_main_queue(), ^&#123; //5. 回调之前的操作 //5.1 缓存处理 [self requestCompletePreprocessor]; //5.2 用户可以在这里进行真正回调前的操作 [self requestCompleteFilter]; YTKRequest *strongSelf = self; //6. 执行回调 //6.1 请求完成的代理 [strongSelf.delegate requestFinished:strongSelf]; //6.2 请求成功的block if (strongSelf.successCompletionBlock) &#123; strongSelf.successCompletionBlock(strongSelf); &#125; //7. 把成功和失败的block都设置为nil，避免循环引用 [strongSelf clearCompletionBlock]; &#125;);&#125; 我们之前说过YTKRequest负责缓存的相关处理，所以在上面这个start方法里，它做的是请求之前缓存的查询和检查工作: 如果忽略缓存，或者缓存获取失败，调用startWithoutCache方法（参考1-3的情况），发起请求。 如果能成功获取到缓存，则直接回调（参考4-7的情况）。 我们来看一下每一步的具体实现： ignoreCache属性是用户手动设置的，如果用户强制忽略缓存，则无论是否缓存是否存在，直接发送请求。 resumableDownloadPath是断点下载路径，如果该路径不为空，说明有未完成的下载任务，则直接发送请求继续下载。 loadCacheWithError：方法验证了加载缓存是否成功的方法（返回值为YES，说明可以加载缓存；反之亦然），看一下具体实现： 123456789101112131415161718192021222324252627282930//YTKRequest.m- (BOOL)loadCacheWithError:(NSError * _Nullable __autoreleasing *)error &#123; // 缓存时间小于0，则返回（缓存时间默认为-1，需要用户手动设置，单位是秒） if ([self cacheTimeInSeconds] &lt; 0) &#123; if (error) &#123; *error = [NSError errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorInvalidCacheTime userInfo:@&#123; NSLocalizedDescriptionKey:@&quot;Invalid cache time&quot;&#125;]; &#125; return NO; &#125; // 是否有缓存的元数据，如果没有，返回错误 if (![self loadCacheMetadata]) &#123; if (error) &#123; *error = [NSError errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorInvalidMetadata userInfo:@&#123; NSLocalizedDescriptionKey:@&quot;Invalid metadata. Cache may not exist&quot;&#125;]; &#125; return NO; &#125; // 有缓存，再验证是否有效 if (![self validateCacheWithError:error]) &#123; return NO; &#125; // 有缓存，而且有效，再验证是否能取出来 if (![self loadCacheData]) &#123; if (error) &#123; *error = [NSError errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorInvalidCacheData userInfo:@&#123; NSLocalizedDescriptionKey:@&quot;Invalid cache data&quot;&#125;]; &#125; return NO; &#125; return YES;&#125; 先讲一下什么是元数据：元数据是指数据的数据，在这里描述了缓存数据本身的一些特征：包括版本号，缓存时间，敏感信息等等， 稍后会做详细介绍。 我们来看一下上面关于缓存的元数据的获取方法：loadCacheMetadata方法 1234567891011121314151617//YTKRequest.m- (BOOL)loadCacheMetadata &#123; NSString *path = [self cacheMetadataFilePath]; NSFileManager * fileManager = [NSFileManager defaultManager]; if ([fileManager fileExistsAtPath:path isDirectory:nil]) &#123; @try &#123; //将序列化之后被保存在磁盘里的文件反序列化到当前对象的属性cacheMetadata _cacheMetadata = [NSKeyedUnarchiver unarchiveObjectWithFile:path]; return YES; &#125; @catch (NSException *exception) &#123; YTKLog(@&quot;Load cache metadata failed, reason = %@&quot;, exception.reason); return NO; &#125; &#125; return NO;&#125; cacheMetadata（YTKCacheMetadata） 是当前reqeust类用来保存缓存元数据的属性。 YTKCacheMetadata类被定义在YTKRequest.m文件里面： 12345678910//YTKRequest.m@interface YTKCacheMetadata : NSObject&lt;NSSecureCoding&gt;@property (nonatomic, assign) long long version;@property (nonatomic, strong) NSString *sensitiveDataString;@property (nonatomic, assign) NSStringEncoding stringEncoding;@property (nonatomic, strong) NSDate *creationDate;@property (nonatomic, strong) NSString *appVersionString;@end 它描述的是缓存的版本号，敏感信息，创建时间，app版本等信息，并支持序列化处理，可以保存在磁盘里。因此，loadCacheMetadata方法的目的是将之前被序列化保存的缓存元数据信息反序列化，赋给自身的cacheMetadata属性上。 现在获取了缓存的元数据并赋给了自身的cacheMetadata属性上，那么接下来就要逐一验证元数据里的各项信息是否符合要求，在下面的validateCacheWithError：里面验证： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//YTKRequest.m- (BOOL)validateCacheWithError:(NSError * _Nullable __autoreleasing *)error &#123; // 是否大于过期时间 NSDate *creationDate = self.cacheMetadata.creationDate; NSTimeInterval duration = -[creationDate timeIntervalSinceNow]; if (duration &lt; 0 || duration &gt; [self cacheTimeInSeconds]) &#123; if (error) &#123; *error = [NSError errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorExpired userInfo:@&#123; NSLocalizedDescriptionKey:@&quot;Cache expired&quot;&#125;]; &#125; return NO; &#125; // 缓存的版本号是否符合 long long cacheVersionFileContent = self.cacheMetadata.version; if (cacheVersionFileContent != [self cacheVersion]) &#123; if (error) &#123; *error = [NSError errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorVersionMismatch userInfo:@&#123; NSLocalizedDescriptionKey:@&quot;Cache version mismatch&quot;&#125;]; &#125; return NO; &#125; // 敏感信息是否符合 NSString *sensitiveDataString = self.cacheMetadata.sensitiveDataString; NSString *currentSensitiveDataString = ((NSObject *)[self cacheSensitiveData]).description; if (sensitiveDataString || currentSensitiveDataString) &#123; // If one of the strings is nil, short-circuit evaluation will trigger if (sensitiveDataString.length != currentSensitiveDataString.length || ![sensitiveDataString isEqualToString:currentSensitiveDataString]) &#123; if (error) &#123; *error = [NSError errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorSensitiveDataMismatch userInfo:@&#123; NSLocalizedDescriptionKey:@&quot;Cache sensitive data mismatch&quot;&#125;]; &#125; return NO; &#125; &#125; // app的版本是否符合 NSString *appVersionString = self.cacheMetadata.appVersionString; NSString *currentAppVersionString = [YTKNetworkUtils appVersionString]; if (appVersionString || currentAppVersionString) &#123; if (appVersionString.length != currentAppVersionString.length || ![appVersionString isEqualToString:currentAppVersionString]) &#123; if (error) &#123; *error = [NSError errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorAppVersionMismatch userInfo:@&#123; NSLocalizedDescriptionKey:@&quot;App version mismatch&quot;&#125;]; &#125; return NO; &#125; &#125; return YES;&#125; 如果每项元数据信息都能通过，再在loadCacheData方法里面验证缓存是否能被取出来： 123456789101112131415161718192021222324//YTKRequest.m- (BOOL)loadCacheData &#123; NSString *path = [self cacheFilePath]; NSFileManager *fileManager = [NSFileManager defaultManager]; NSError *error = nil; if ([fileManager fileExistsAtPath:path isDirectory:nil]) &#123; NSData *data = [NSData dataWithContentsOfFile:path]; _cacheData = data; _cacheString = [[NSString alloc] initWithData:_cacheData encoding:self.cacheMetadata.stringEncoding]; switch (self.responseSerializerType) &#123; case YTKResponseSerializerTypeHTTP: // Do nothing. return YES; case YTKResponseSerializerTypeJSON: _cacheJSON = [NSJSONSerialization JSONObjectWithData:_cacheData options:(NSJSONReadingOptions)0 error:&amp;error]; return error == nil; case YTKResponseSerializerTypeXMLParser: _cacheXML = [[NSXMLParser alloc] initWithData:_cacheData]; return YES; &#125; &#125; return NO;&#125; 如果通过了最终的考验，则说明当前请求对应的缓存是符合各项要求并可以被成功取出，也就是可以直接进行回调了。 当确认缓存可以成功取出后，手动设置dataFromCache属性为 YES，说明当前的请求结果是来自于缓存，而没有通过网络请求。 然后在真正回调之前做了如下处理： 12345678910//YTKRequest.m：- (void)start&#123; .... //5. 回调之前的操作 //5.1 缓存处理 [self requestCompletePreprocessor]; //5.2 用户可以在这里进行真正回调前的操作 [self requestCompleteFilter]; ....&#125; 5.1：requestCompletePreprocessor方法: 1234567891011121314151617//YTKRequest.m：- (void)requestCompletePreprocessor &#123; [super requestCompletePreprocessor]; //是否异步将responseData写入缓存（写入缓存的任务放在专门的队列ytkrequest_cache_writing_queue进行） if (self.writeCacheAsynchronously) &#123; dispatch_async(ytkrequest_cache_writing_queue(), ^&#123; //保存响应数据到缓存 [self saveResponseDataToCacheFile:[super responseData]]; &#125;); &#125; else &#123; //保存响应数据到缓存 [self saveResponseDataToCacheFile:[super responseData]]; &#125;&#125; 1234567891011121314151617181920212223//YTKRequest.m：//保存响应数据到缓存- (void)saveResponseDataToCacheFile:(NSData *)data &#123; if ([self cacheTimeInSeconds] &gt; 0 &amp;&amp; ![self isDataFromCache]) &#123; if (data != nil) &#123; @try &#123; // New data will always overwrite old data. [data writeToFile:[self cacheFilePath] atomically:YES]; YTKCacheMetadata *metadata = [[YTKCacheMetadata alloc] init]; metadata.version = [self cacheVersion]; metadata.sensitiveDataString = ((NSObject *)[self cacheSensitiveData]).description; metadata.stringEncoding = [YTKNetworkUtils stringEncodingWithRequest:self]; metadata.creationDate = [NSDate date]; metadata.appVersionString = [YTKNetworkUtils appVersionString]; [NSKeyedArchiver archiveRootObject:metadata toFile:[self cacheMetadataFilePath]]; &#125; @catch (NSException *exception) &#123; YTKLog(@&quot;Save cache failed, reason = %@&quot;, exception.reason); &#125; &#125; &#125;&#125; 我们可以看到, requestCompletePreprocessor方法的任务是将响应数据保存起来，也就是做缓存。但是，缓存的保存有两个条件，一个是需要cacheTimeInSeconds方法返回正整数（缓存时间，单位是秒，后续会详细说明）；另一个条件是isDataFromCache方法返回NO。但是我们知道，如果缓存可用，就会将这个属性设置为YES，所以走到这里的时候，就不做缓存了。 接着看下5.2：requestCompleteFilter方法则是需要用户自己提供具体实现的，专门作为回调成功之前的一些处理： 123//YTKBaseRequest.m- (void)requestCompleteFilter &#123;&#125; 到这里，回调之前的处理都结束了，下面来看一下在缓存可用的情况下的回调： 123456789101112131415161718//YTKRequest.m- (void)start&#123; ... YTKRequest *strongSelf = self; //6. 执行回调 //6.1 请求完成的代理 [strongSelf.delegate requestFinished:strongSelf]; //6.2 请求成功的block if (strongSelf.successCompletionBlock) &#123; strongSelf.successCompletionBlock(strongSelf); &#125; //7. 把成功和失败的block都设置为nil，避免循环引用 [strongSelf clearCompletionBlock];&#125; 我们可以看到 ，这里面同时存在两种回调：代理的回调和block的回调。先执行的是代理的回调，然后执行的是block的回调。而且在回调结束之后，YTKNetwork会帮助我们清空回调的block： 123456//YTKBaseRequest.m- (void)clearCompletionBlock &#123; // 清空请求结束的block，避免循环引用 self.successCompletionBlock = nil; self.failureCompletionBlock = nil;&#125; 注意，在用户同时实现了代理和block的情况下，二者都会被调用。 到这里，我们了解了YTKNetwork在网络请求之前是如何验证缓存，以及在缓存有效的情况下是如何回调的。 反过来，如果缓存无效（或忽略缓存）时，需要立即请求网络。那么我们现在来看一看在这个时候YTKNetwork都做了什么： 仔细看一下上面的start方法，我们会发现，如果缓存不满足条件时，会直接调用startWithoutCache方法： 1234567891011121314151617181920//YTKRequest.m- (void)start&#123; //1. 如果忽略缓存 -&gt; 请求 if (self.ignoreCache) &#123; [self startWithoutCache]; return; &#125; //2. 如果存在下载未完成的文件 -&gt; 请求 if (self.resumableDownloadPath) &#123; [self startWithoutCache]; return; &#125; //3. 获取缓存失败 -&gt; 请求 if (![self loadCacheWithError:nil]) &#123; [self startWithoutCache]; return; &#125; ......&#125; 那么在startWithoutCache方法里都做了什么呢？ 123456789101112131415161718//YTKRequest.m- (void)startWithoutCache &#123; //1. 清除缓存 [self clearCacheVariables]; //2. 调用父类的发起请求 [super start];&#125;//清除当前请求对应的所有缓存- (void)clearCacheVariables &#123; _cacheData = nil; _cacheXML = nil; _cacheJSON = nil; _cacheString = nil; _cacheMetadata = nil; _dataFromCache = NO;&#125; 在这里，首先清除了关于缓存的所有数据，然后调用父类的start方法: 12345678//YTKBaseRequest.m:- (void)start &#123; //1. 告诉Accessories即将回调了（其实是即将发起请求） [self toggleAccessoriesWillStartCallBack]; //2. 令agent添加请求并发起请求，在这里并不是组合关系，agent只是一个单例 [[YTKNetworkAgent sharedAgent] addRequest:self];&#125; 第一步里的Accessories是一些遵从代理的对象。这个代理定义了一些用来追踪请求状况的方法。它被定义在了YTKBaseRequest.h文件里： 123456789101112131415161718//用来跟踪请求的状态的代理。@protocol YTKRequestAccessory &lt;NSObject&gt;@optional/// Inform the accessory that the request is about to start.////// @param request The corresponding request.- (void)requestWillStart:(id)request;/// Inform the accessory that the request is about to stop. This method is called/// before executing `requestFinished` and `successCompletionBlock`.////// @param request The corresponding request.- (void)requestWillStop:(id)request;/// Inform the accessory that the request has already stoped. This method is called/// after executing `requestFinished` and `successCompletionBlock`.////// @param request The corresponding request.- (void)requestDidStop:(id)request;@end 所以只要某个对象遵从了这个代理，就可以追踪到请求将要开始，将要结束，已经结束的状态。 接着看一下第二步：YTKNetworkAgent把当前的请求对象添加到了自己身上并发送请求。来看一下它的具体实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//YTKNetworkAgent.m- (void)addRequest:(YTKBaseRequest *)request &#123; //1. 获取task NSParameterAssert(request != nil); NSError * __autoreleasing requestSerializationError = nil; //获取用户自定义的requestURL NSURLRequest *customUrlRequest= [request buildCustomUrlRequest]; if (customUrlRequest) &#123; __block NSURLSessionDataTask *dataTask = nil; //如果存在用户自定义request，则直接走AFNetworking的dataTaskWithRequest:方法 dataTask = [_manager dataTaskWithRequest:customUrlRequest completionHandler:^(NSURLResponse * _Nonnull response, id _Nullable responseObject, NSError * _Nullable error) &#123; //响应的统一处理 [self handleRequestResult:dataTask responseObject:responseObject error:error]; &#125;]; request.requestTask = dataTask; &#125; else &#123; //如果用户没有自定义url，则直接走这里 request.requestTask = [self sessionTaskForRequest:request error:&amp;requestSerializationError]; &#125; //序列化失败，则认定为请求失败 if (requestSerializationError) &#123; //请求失败的处理 [self requestDidFailWithRequest:request error:requestSerializationError]; return; &#125; NSAssert(request.requestTask != nil, @&quot;requestTask should not be nil&quot;); // 优先级的映射 // !!Available on iOS 8 + if ([request.requestTask respondsToSelector:@selector(priority)]) &#123; switch (request.requestPriority) &#123; case YTKRequestPriorityHigh: request.requestTask.priority = NSURLSessionTaskPriorityHigh; break; case YTKRequestPriorityLow: request.requestTask.priority = NSURLSessionTaskPriorityLow; break; case YTKRequestPriorityDefault: /*!!fall through*/ default: request.requestTask.priority = NSURLSessionTaskPriorityDefault; break; &#125; &#125; // Retain request YTKLog(@&quot;Add request: %@&quot;, NSStringFromClass([request class])); //2. 将request放入保存请求的字典中，taskIdentifier为key，request为值 [self addRequestToRecord:request]; //3. 开始task [request.requestTask resume];&#125; 这个方法挺长的，但是请不要被吓到，它总共分为三个部分： 第一部分是获取当前请求对应的task并赋给request的requestTask属性（以后提到的request，都为用户自定义的当前请求类的实例）。 第二部分是把request放入专门用来保存请求的字典中，key为taskIdentifier。 第三部分是启动task。 下面我来依次讲解每个部分： 第一部分：获取当前请求对应的task并赋给request： 123456789101112131415161718192021//YTKNetworkAgent.m- (void)addRequest:(YTKBaseRequest *)request &#123; ... if (customUrlRequest) &#123; __block NSURLSessionDataTask *dataTask = nil; //如果存在用户自定义request，则直接走AFNetworking的dataTaskWithRequest:方法 dataTask = [_manager dataTaskWithRequest:customUrlRequest completionHandler:^(NSURLResponse * _Nonnull response, id _Nullable responseObject, NSError * _Nullable error) &#123; //统一处理请求响应 [self handleRequestResult:dataTask responseObject:responseObject error:error]; &#125;]; request.requestTask = dataTask; &#125; else &#123; //如果用户没有自定义url，则直接走这里 request.requestTask = [self sessionTaskForRequest:request error:&amp;requestSerializationError]; &#125; ...&#125; 在这里判断了用户是否自定义了request： 如果是，则直接调用AFNetworking的dataTaskWithRequest:方法。 如果不是，则调用YTKRequest自己的生成task的方法。 第一种情况就不说了，因为AF帮我们做好了。在这里看一下第二种情况，sessionTaskForRequest: error :方法内部： 从这个方法最后的switch语句可以看出，这个方法的作用是返回当前request的NSURLSessionTask的实例。而且最终生成NSURLSessionTask实例的方法都是通过dataTaskWithHTTPMethod:requestSerializer:URLString:parameters:error:这个私有方法来实现的。在讲解这个关键的私有方法之前，先来逐步讲解一下这个私有方法需要的每个参数的获取方法： 获得请求类型（GET，POST等）： 123456//YTKNetworkAgent.m- (NSURLSessionTask *)sessionTaskForRequest:(YTKBaseRequest *)request error:(NSError * _Nullable __autoreleasing *)error &#123; ... YTKRequestMethod method = [request requestMethod]; ...&#125; requestMethod方法最初在YTKBaseRequest里面已经实现了，默认返回了YTKRequestMethodGET。 它的枚举类型在YTKBaseRequest.h里面定义： 12345678910//YTKBaseRequest.h/// HTTP Request method.typedef NS_ENUM(NSInteger, YTKRequestMethod) &#123; YTKRequestMethodGET = 0, YTKRequestMethodPOST, YTKRequestMethodHEAD, YTKRequestMethodPUT, YTKRequestMethodDELETE, YTKRequestMethodPATCH,&#125;; 用户可以根据实际的需求在自定义request类里面重写这个方法： 1234//RegisterAPI.m- (YTKRequestMethod)requestMethod &#123; return YTKRequestMethodPOST;&#125; 获得请求url： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//YTKNetworkAgent.m- (NSURLSessionTask *)sessionTaskForRequest:(YTKBaseRequest *)request error:(NSError * _Nullable __autoreleasing *)error &#123; ... NSString *url = [self buildRequestUrl:request]; ...&#125;//返回当前请求url- (NSString *)buildRequestUrl:(YTKBaseRequest *)request &#123; NSParameterAssert(request != nil); //用户自定义的url（不包括在YTKConfig里面设置的base_url） NSString *detailUrl = [request requestUrl]; NSURL *temp = [NSURL URLWithString:detailUrl]; // 存在host和scheme的url立即返回正确 if (temp &amp;&amp; temp.host &amp;&amp; temp.scheme) &#123; return detailUrl; &#125; // 如果需要过滤url，则过滤 NSArray *filters = [_config urlFilters]; for (id&lt;YTKUrlFilterProtocol&gt; f in filters) &#123; detailUrl = [f filterUrl:detailUrl withRequest:request]; &#125; NSString *baseUrl; if ([request useCDN]) &#123; //如果使用CDN，在当前请求没有配置CDN地址的情况下，返回全局配置的CDN if ([request cdnUrl].length &gt; 0) &#123; baseUrl = [request cdnUrl]; &#125; else &#123; baseUrl = [_config cdnUrl]; &#125; &#125; else &#123; //如果使用baseUrl，在当前请求没有配置baseUrl，返回全局配置的baseUrl if ([request baseUrl].length &gt; 0) &#123; baseUrl = [request baseUrl]; &#125; else &#123; baseUrl = [_config baseUrl]; &#125; &#125; // 如果末尾没有/，则在末尾添加一个／ NSURL *url = [NSURL URLWithString:baseUrl]; if (baseUrl.length &gt; 0 &amp;&amp; ![baseUrl hasSuffix:@&quot;/&quot;]) &#123; url = [url URLByAppendingPathComponent:@&quot;&quot;]; &#125; return [NSURL URLWithString:detailUrl relativeToURL:url].absoluteString;&#125; 获得请求参数 123456789//YTKNetworkAgent.m- (NSURLSessionTask *)sessionTaskForRequest:(YTKBaseRequest *)request error:(NSError * _Nullable __autoreleasing *)error &#123; ... //获取用户提供的请求参数 id param = request.requestArgument; //获取用户提供的构造请求体的block（默认是没有的） AFConstructingBlock constructingBlock = [request constructingBodyBlock]; ...&#125; 在这里，requestArgument是一个get方法，需要用户自己定义请求体，例如在RegisterAPI里面就定义了两个请求参数： 1234567//RegisterApi.m- (id)requestArgument &#123; return @&#123; @&quot;username&quot;: _username, @&quot;password&quot;: _password &#125;;&#125; 获得request serializer 123456789101112131415161718192021222324252627282930313233343536373839//YTKNetworkAgent.m- (NSURLSessionTask *)sessionTaskForRequest:(YTKBaseRequest *)request error:(NSError * _Nullable __autoreleasing *)error &#123; ... //4. 获得request serializer AFHTTPRequestSerializer *requestSerializer = [self requestSerializerForRequest:request]; ...&#125;- (AFHTTPRequestSerializer *)requestSerializerForRequest:(YTKBaseRequest *)request &#123; AFHTTPRequestSerializer *requestSerializer = nil; //HTTP or JSON if (request.requestSerializerType == YTKRequestSerializerTypeHTTP) &#123; requestSerializer = [AFHTTPRequestSerializer serializer]; &#125; else if (request.requestSerializerType == YTKRequestSerializerTypeJSON) &#123; requestSerializer = [AFJSONRequestSerializer serializer]; &#125; //超时时间 requestSerializer.timeoutInterval = [request requestTimeoutInterval]; //是否允许数据服务 requestSerializer.allowsCellularAccess = [request allowsCellularAccess]; //如果当前请求需要验证 NSArray&lt;NSString *&gt; *authorizationHeaderFieldArray = [request requestAuthorizationHeaderFieldArray]; if (authorizationHeaderFieldArray != nil) &#123; [requestSerializer setAuthorizationHeaderFieldWithUsername:authorizationHeaderFieldArray.firstObject password:authorizationHeaderFieldArray.lastObject]; &#125; //如果当前请求需要自定义 HTTPHeaderField NSDictionary&lt;NSString *, NSString *&gt; *headerFieldValueDictionary = [request requestHeaderFieldValueDictionary]; if (headerFieldValueDictionary != nil) &#123; for (NSString *httpHeaderField in headerFieldValueDictionary.allKeys) &#123; NSString *value = headerFieldValueDictionary[httpHeaderField]; [requestSerializer setValue:value forHTTPHeaderField:httpHeaderField]; &#125; &#125; return requestSerializer;&#125; 上面这个方法通过传入的request实例，根据它的一些配置（用户提供）来获取AFHTTPRequestSerializer的实例。 到现在为止，获取NSURLSessionTask实例的几个参数都拿到了，剩下的就是调用dataTaskWithHTTPMethod:requestSerializer:URLString:parameters:error:方法来获取NSURLSessionTask实例了。我们来看一下这个方法的具体实现： 12345678910111213141516171819202122232425262728293031//YTKNetworkAgent.m- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method requestSerializer:(AFHTTPRequestSerializer *)requestSerializer URLString:(NSString *)URLString parameters:(id)parameters error:(NSError * _Nullable __autoreleasing *)error &#123; return [self dataTaskWithHTTPMethod:method requestSerializer:requestSerializer URLString:URLString parameters:parameters constructingBodyWithBlock:nil error:error];&#125;//最终返回NSURLSessionDataTask实例- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method requestSerializer:(AFHTTPRequestSerializer *)requestSerializer URLString:(NSString *)URLString parameters:(id)parameters constructingBodyWithBlock:(nullable void (^)(id &lt;AFMultipartFormData&gt; formData))block error:(NSError * _Nullable __autoreleasing *)error &#123; NSMutableURLRequest *request = nil; //根据有无构造请求体的block的情况来获取request if (block) &#123; request = [requestSerializer multipartFormRequestWithMethod:method URLString:URLString parameters:parameters constructingBodyWithBlock:block error:error]; &#125; else &#123; request = [requestSerializer requestWithMethod:method URLString:URLString parameters:parameters error:error]; &#125; //获得request以后来获取dataTask __block NSURLSessionDataTask *dataTask = nil; dataTask = [_manager dataTaskWithRequest:request completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *_error) &#123; //响应的统一处理 [self handleRequestResult:dataTask responseObject:responseObject error:_error]; &#125;]; return dataTask;&#125; 这两个方法，上面的方法调用了下面的来获取最终的NSURLSessionDataTask实例。 OK，现在我们已经知道了NSURLSessionDataTask实例是如何获取的，再来看一下在addRequest：方法里接下来做的是对序列化失败的处理： 123456789101112//YTKNetworkAgent.m- (void)addRequest:(YTKBaseRequest *)request &#123; ... //序列化失败 if (requestSerializationError) &#123; //请求失败的处理 [self requestDidFailWithRequest:request error:requestSerializationError]; return; &#125; ...&#125; requestDidFailWithRequest:方法专门处理请求失败的情况，因为它被包含在统一处理请求回调的方法中，所以在稍后会在讲解统一处理请求回调的方法的时候再详细讲解这个方法。 继续往下走，到了优先级的映射部分： 1234567891011121314151617181920212223//YTKNetworkAgent.m- (void)addRequest:(YTKBaseRequest *)request &#123; ... // 优先级的映射 // !!Available on iOS 8 + if ([request.requestTask respondsToSelector:@selector(priority)]) &#123; switch (request.requestPriority) &#123; case YTKRequestPriorityHigh: request.requestTask.priority = NSURLSessionTaskPriorityHigh; break; case YTKRequestPriorityLow: request.requestTask.priority = NSURLSessionTaskPriorityLow; break; case YTKRequestPriorityDefault: /*!!fall through*/ default: request.requestTask.priority = NSURLSessionTaskPriorityDefault; break; &#125; &#125; ...&#125; requestPriority是YTKBaseRequest的一个枚举属性，它的枚举在YTKBaseRequest.h里面被定义： 12345typedef NS_ENUM(NSInteger, YTKRequestPriority) &#123; YTKRequestPriorityLow = -4L, YTKRequestPriorityDefault = 0, YTKRequestPriorityHigh = 4,&#125;; 在这里，将用户设置的YTKRequestPriority映射到NSURLSessionTask的priority上。 到这里，我们拿到了task的实例并设置好了优先级，紧接着就是addRequest:方法里的第二个部分：YTKNetworkAgent将request实例放在了一个字典中，保存起来： 第二部分：把request放入专门用来保存请求的字典中，key为taskIdentifier： 123456789101112131415161718//YTKNetworkAgent.m- (void)addRequest:(YTKBaseRequest *)request &#123; ... ... //将request实例放入保存请求的字典中，taskIdentifier为key，request为值 [self addRequestToRecord:request]; ...&#125;- (void)addRequestToRecord:(YTKBaseRequest *)request &#123; //加锁 Lock(); _requestsRecord[@(request.requestTask.taskIdentifier)] = request; Unlock();&#125;#define Lock() pthread_mutex_lock(&amp;_lock)#define Unlock() pthread_mutex_unlock(&amp;_lock) 可以看到，在添加前和添加后是进行了加锁和解锁的处理的。而且request实例被保存的时候，将其task的identifier作为key来保存。 在当前的request被保存以后，就到了最后一步，正式发起请求： 第三部分：启动task 1234567//YTKNetworkAgent.m- (NSURLSessionTask *)sessionTaskForRequest:(YTKBaseRequest *)request error:(NSError * _Nullable __autoreleasing *)error &#123; ... [request.requestTask resume]; ...&#125; 到现在为止，我们了解了YTKNetwork里面，一个请求开始之前做的事情：查找可用缓存，生成NSURLSessionTask实例，获取url，requestSerializer，将request放到YTKNetworkAgent的一个字典里等等（详细流程会在稍后给出）。 那么接下来我们看一下YTKNetwork是如何处理请求的回调的。 眼尖的同学们可能会注意到，在获取NSURLSessionTask实例的时候，出现了两次“响应的统一处理”的注释，大家可以搜索这个注释就可以找到这个方法：handleRequestResult:responseObject:error:。这个方法负责的是对请求回调的处理，当然包括了成功和失败的情况。我们来看一下在这个方法里都做了什么： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//YTKNetworkAgent.m//统一处理请求结果，包括成功和失败的情况- (void)handleRequestResult:(NSURLSessionTask *)task responseObject:(id)responseObject error:(NSError *)error &#123; //1. 获取task对应的request Lock(); YTKBaseRequest *request = _requestsRecord[@(task.taskIdentifier)]; Unlock(); //如果不存在对应的request，则立即返回 if (!request) &#123; return; &#125; 。。。 //2. 获取request对应的response request.responseObject = responseObject; //3. 获取responseObject，responseData和responseString if ([request.responseObject isKindOfClass:[NSData class]]) &#123; //3.1 获取 responseData request.responseData = responseObject; //3.2 获取responseString request.responseString = [[NSString alloc] initWithData:responseObject encoding:[YTKNetworkUtils stringEncodingWithRequest:request]]; //3.3 获取responseObject（或responseJSONObject） //根据返回的响应的序列化的类型来得到对应类型的响应 switch (request.responseSerializerType) &#123; case YTKResponseSerializerTypeHTTP: // Default serializer. Do nothing. break; case YTKResponseSerializerTypeJSON: request.responseObject = [self.jsonResponseSerializer responseObjectForResponse:task.response data:request.responseData error:&amp;serializationError]; request.responseJSONObject = request.responseObject; break; case YTKResponseSerializerTypeXMLParser: request.responseObject = [self.xmlParserResponseSerialzier responseObjectForResponse:task.response data:request.responseData error:&amp;serializationError]; break; &#125; &#125; //4. 判断是否有错误，将错误对象赋值给requestError，改变succeed的布尔值。目的是根据succeed的值来判断到底是进行成功的回调还是失败的回调 if (error) &#123; //如果该方法传入的error不为nil succeed = NO; requestError = error; &#125; else if (serializationError) &#123; //如果序列化失败了 succeed = NO; requestError = serializationError; &#125; else &#123; //即使没有error而且序列化通过，也要验证request是否有效 succeed = [self validateResult:request error:&amp;validationError]; requestError = validationError; &#125; //5. 根据succeed的布尔值来调用相应的处理 if (succeed) &#123; //请求成功的处理 [self requestDidSucceedWithRequest:request]; &#125; else &#123; //请求失败的处理 [self requestDidFailWithRequest:request error:requestError]; &#125; //6. 回调完成的处理 dispatch_async(dispatch_get_main_queue(), ^&#123; //6.1 在字典里移除当前request [self removeRequestFromRecord:request]; //6.2 清除所有block [request clearCompletionBlock]; &#125;);&#125; 简单讲解一下上面的代码： 首先通过task的identifier值从YTKNetworkAgent保存的字典里获取对应的请求。 然后将获得的responseObject进行处理，将处理后获得的responseObject，responseData和responseString赋值给当前的请求实例request。 再根据这些值的获取情况来判断最终回调的成败（改变succeed的值）。 最后根据succeed的值来进行成功和失败的回调。 这里先重点介绍一下是如何判断json的有效性的： 1234567891011121314151617181920212223242526272829303132//YTKNetworkAgent.m//判断code是否符合范围和json的有效性- (BOOL)validateResult:(YTKBaseRequest *)request error:(NSError * _Nullable __autoreleasing *)error &#123; //1. 判断code是否在200~299之间 BOOL result = [request statusCodeValidator]; if (!result) &#123; if (error) &#123; *error = [NSError errorWithDomain:YTKRequestValidationErrorDomain code:YTKRequestValidationErrorInvalidStatusCode userInfo:@&#123;NSLocalizedDescriptionKey:@&quot;Invalid status code&quot;&#125;]; &#125; return result; &#125; //2. result 存在的情况判断json是否有效 id json = [request responseJSONObject]; id validator = [request jsonValidator]; if (json &amp;&amp; validator) &#123; //通过json和validator来判断json是否有效 result = [YTKNetworkUtils validateJSON:json withValidator:validator]; //如果json无效 if (!result) &#123; if (error) &#123; *error = [NSError errorWithDomain:YTKRequestValidationErrorDomain code:YTKRequestValidationErrorInvalidJSONFormat userInfo:@&#123;NSLocalizedDescriptionKey:@&quot;Invalid JSON format&quot;&#125;]; &#125; return result; &#125; &#125; return YES;&#125; 在这里，首先，用statusCodeValidator方法判断响应的code是否在正确的范围: 12345678//YTKBaseReqiest.m- (BOOL)statusCodeValidator &#123; NSInteger statusCode = [self responseStatusCode]; return (statusCode &gt;= 200 &amp;&amp; statusCode &lt;= 299);&#125;- (NSInteger)responseStatusCode &#123; return self.response.statusCode;&#125; 然后再判断json的有效性： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//YTKNetworkUtils.m//判断json的有效性+ (BOOL)validateJSON:(id)json withValidator:(id)jsonValidator &#123; if ([json isKindOfClass:[NSDictionary class]] &amp;&amp; [jsonValidator isKindOfClass:[NSDictionary class]]) &#123; NSDictionary * dict = json; NSDictionary * validator = jsonValidator; BOOL result = YES; NSEnumerator * enumerator = [validator keyEnumerator]; NSString * key; while ((key = [enumerator nextObject]) != nil) &#123; id value = dict[key]; id format = validator[key]; if ([value isKindOfClass:[NSDictionary class]] || [value isKindOfClass:[NSArray class]]) &#123; result = [self validateJSON:value withValidator:format]; if (!result) &#123; break; &#125; &#125; else &#123; if ([value isKindOfClass:format] == NO &amp;&amp; [value isKindOfClass:[NSNull class]] == NO) &#123; result = NO; break; &#125; &#125; &#125; return result; &#125; else if ([json isKindOfClass:[NSArray class]] &amp;&amp; [jsonValidator isKindOfClass:[NSArray class]]) &#123; NSArray * validatorArray = (NSArray *)jsonValidator; if (validatorArray.count &gt; 0) &#123; NSArray * array = json; NSDictionary * validator = jsonValidator[0]; for (id item in array) &#123; BOOL result = [self validateJSON:item withValidator:validator]; if (!result) &#123; return NO; &#125; &#125; &#125; return YES; &#125; else if ([json isKindOfClass:jsonValidator]) &#123; return YES; &#125; else &#123; return NO; &#125;&#125; 注意，YTKNetworkUtils这个类是在YTKNetworkPirvate里面定义的，YTKNetworkPirvate里面有一些工具类的方法，在后面还会遇到。 在验证返回的JSON数据是否有效以后，就可以进行回调了： 123456789101112131415161718192021//YTKNetworkAgent.m- (void)handleRequestResult:(NSURLSessionTask *)task responseObject:(id)responseObject error:(NSError *)error &#123; ... //5. 根据succeed的布尔值来调用相应的处理 if (succeed) &#123; //请求成功的处理 [self requestDidSucceedWithRequest:request]; &#125; else &#123; //请求失败的处理 [self requestDidFailWithRequest:request error:requestError]; &#125; //6. 回调完成的处理 dispatch_async(dispatch_get_main_queue(), ^&#123; //6.1 在字典里移除当前request [self removeRequestFromRecord:request]; //6.2 清除所有block [request clearCompletionBlock]; &#125;); ...&#125; 我们先来分别看一下请求成功的处理和失败的处理： 请求成功的处理： 123456789101112131415161718192021222324252627282930//YTKNetworkAgent.m//请求成功：主要负责将结果写入缓存&amp;回调成功的代理和block- (void)requestDidSucceedWithRequest:(YTKBaseRequest *)request &#123; @autoreleasepool &#123; //写入缓存 [request requestCompletePreprocessor]; &#125; dispatch_async(dispatch_get_main_queue(), ^&#123; //告诉Accessories请求就要停止了 [request toggleAccessoriesWillStopCallBack]; //在真正的回调之前做的处理,用户自定义 [request requestCompleteFilter]; //如果有代理，则调用成功的代理 if (request.delegate != nil) &#123; [request.delegate requestFinished:request]; &#125; //如果传入了成功回调的代码，则调用 if (request.successCompletionBlock) &#123; request.successCompletionBlock(request); &#125; //告诉Accessories请求已经结束了 [request toggleAccessoriesDidStopCallBack]; &#125;);&#125; 我么可以看到，在请求成功以后，第一个做的是写入缓存，我们来看一下requestCompletePreprocessor方法的实现： 12345678910111213141516171819202122232425262728293031323334353637383940//YTKRequest.m- (void)requestCompletePreprocessor &#123; [super requestCompletePreprocessor]; //是否异步将responseData写入缓存（写入缓存的任务放在专门的队列进行） if (self.writeCacheAsynchronously) &#123; dispatch_async(ytkrequest_cache_writing_queue(), ^&#123; //写入缓存文件 [self saveResponseDataToCacheFile:[super responseData]]; &#125;); &#125; else &#123; //写入缓存文件 [self saveResponseDataToCacheFile:[super responseData]]; &#125;&#125;//写入缓存文件- (void)saveResponseDataToCacheFile:(NSData *)data &#123; if ([self cacheTimeInSeconds] &gt; 0 &amp;&amp; ![self isDataFromCache]) &#123; if (data != nil) &#123; @try &#123; // 1. 保存request的responseData到cacheFilePath [data writeToFile:[self cacheFilePath] atomically:YES]; // 2. 保存request的metadata到cacheMetadataFilePath YTKCacheMetadata *metadata = [[YTKCacheMetadata alloc] init]; metadata.version = [self cacheVersion]; metadata.sensitiveDataString = ((NSObject *)[self cacheSensitiveData]).description; metadata.stringEncoding = [YTKNetworkUtils stringEncodingWithRequest:self]; metadata.creationDate = [NSDate date]; metadata.appVersionString = [YTKNetworkUtils appVersionString]; [NSKeyedArchiver archiveRootObject:metadata toFile:[self cacheMetadataFilePath]]; &#125; @catch (NSException *exception) &#123; YTKLog(@&quot;Save cache failed, reason = %@&quot;, exception.reason); &#125; &#125; &#125;&#125; 首先看一下写入缓存操作的执行条件：当cacheTimeInSeconds方法返回大于0并且isDataFromCache为NO的时候会进行写入缓存。 cacheTimeInSeconds方法返回的是缓存保存的时间，它最初定义在YTKBaseRquest里面，默认返回是-1： 1234//YTKBaseRequest.m- (NSInteger)cacheTimeInSeconds &#123; return -1;&#125; 所以说YTKNetwork默认是不进行缓存的，如果用户需要做缓存，则需要在自定义的request类里面返回一个大于0的整数，这个整数的单位是秒。 isDataFromCache属性在上面讲解发送请求部分里的查询缓存的步骤里有介绍。在这里再强调一下：isDataFromCache的默认值是NO。在请求发起之前，查询缓存的时候： 如果发现缓存不可用（或忽略缓存），则立即发送请求，这个时候，isDataFromCache的值不做更改，仍然是NO。 如果发现缓存可用（在不忽略缓存的情况下），就要将isDataFromCache属性设置为YES，说明将不需要发送请求，直接在里获取数据了。 即是说，如果发送了请求，则isDataFromCache一定是NO的，那么在上面这个判断里面，(!isDataFromCache)就一定为YES了。 因此，如果用户设置了缓存保存的时间，在请求返回成功后，就会写入缓存。 我们接着往下看，对于缓存，YTKNetwork保存的是两种缓存：第一种是纯粹的NSData类型的实例。第二种是描述当前NSData实例的元数据YTKCacheMetadata的实例，从它的属性来看，分为这几种： 缓存的版本，默认返回为0，用户可以自定义。 敏感数据，类型为id，默认返回nil，用户可以自定义。 NSString的编码格式，在YTKNetworkPrivate内的YTKNetworkUtils实现。 元数据的创建时间。 app的版本号，在YTKNetworkPrivate内的YTKNetworkUtils实现。 在将元数据的实例的这些属性都被赋值以后，将元数据实例序列化写入磁盘中。保存的路径通过cacheMetadataFilePath方法获取。 现在知道了YTKRequest的缓存内容，我们来看一下这两种缓存的位置： 12345678910111213141516171819202122232425262728293031323334353637383940414243//YTKRequest.m//纯NSData数据缓存的文件名- (NSString *)cacheFileName &#123; NSString *requestUrl = [self requestUrl]; NSString *baseUrl = [YTKNetworkConfig sharedConfig].baseUrl; id argument = [self cacheFileNameFilterForRequestArgument:[self requestArgument]]; NSString *requestInfo = [NSString stringWithFormat:@&quot;Method:%ld Host:%@ Url:%@ Argument:%@&quot;, (long)[self requestMethod], baseUrl, requestUrl, argument]; NSString *cacheFileName = [YTKNetworkUtils md5StringFromString:requestInfo]; return cacheFileName;&#125;//纯NSData数据的缓存位置- (NSString *)cacheFilePath &#123; NSString *cacheFileName = [self cacheFileName]; NSString *path = [self cacheBasePath]; path = [path stringByAppendingPathComponent:cacheFileName]; return path;&#125;//元数据的缓存位置- (NSString *)cacheMetadataFilePath &#123; NSString *cacheMetadataFileName = [NSString stringWithFormat:@&quot;%@.metadata&quot;, [self cacheFileName]]; NSString *path = [self cacheBasePath]; path = [path stringByAppendingPathComponent:cacheMetadataFileName]; return path;&#125;//创建用户保存所有YTKNetwork缓存的文件夹- (NSString *)cacheBasePath &#123; //获取全路径 NSString *pathOfLibrary = [NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES) objectAtIndex:0]; NSString *path = [pathOfLibrary stringByAppendingPathComponent:@&quot;LazyRequestCache&quot;]; // YTKCacheDirPathFilterProtocol定义了用户可以自定义存储位置的代理方法 NSArray&lt;id&lt;YTKCacheDirPathFilterProtocol&gt;&gt; *filters = [[YTKNetworkConfig sharedConfig] cacheDirPathFilters]; if (filters.count &gt; 0) &#123; for (id&lt;YTKCacheDirPathFilterProtocol&gt; f in filters) &#123; path = [f filterCacheDirPath:path withRequest:self]; &#125; &#125; //创建文件夹 [self createDirectoryIfNeeded:path]; return path;&#125; 可以看出，纯NSData数据缓存的文件名包含了请求方法（GET,POST..），baseURL，requestURL，请求参数拼接的字符串再进行md5加密而成。 而元数据的的文件名则在纯NSData数据缓存的文件名后面加上了.metadata后缀。 为了更形象地看到这两种缓存，我将缓存的保存时间设置为200秒之后再请求一次，然后打开文件夹找到了它们： 而且我们也确认了保存所有YTKNetwork缓存的文件夹的名字为LazyRequestCache。 OK，现在我们知道了在请求成功回调后的缓存写入，接下来看一下是如何回调的： 1234567891011121314//YTKNetworkAgent.m- (void)handleRequestResult:(NSURLSessionTask *)task responseObject:(id)responseObject error:(NSError *)error &#123; ... YTKRequest *strongSelf = self; //6. 执行回调 //6.1 请求完成的代理 [strongSelf.delegate requestFinished:strongSelf]; //6.2 请求成功的block if (strongSelf.successCompletionBlock) &#123; strongSelf.successCompletionBlock(strongSelf); &#125; //7. 把成功和失败的block都设置为nil，避免循环引用 [strongSelf clearCompletionBlock];&#125; 我们可以看到,代理的回调是先于block的回调的。而且在block回调结束以后，会立即调用clearCompletionBlock方法将block清空。该方法的实现是在YTKBaseRequest里： 123456//YTKBaseRequest.m- (void)clearCompletionBlock &#123; // 清空请求结束的block，避免循环引用 self.successCompletionBlock = nil; self.failureCompletionBlock = nil;&#125; 现在我们知道了请求成功的处理，那么再来看一下请求失败时的处理： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//YTKNetworkAgent.m//请求失败- (void)requestDidFailWithRequest:(YTKBaseRequest *)request error:(NSError *)error &#123; request.error = error; YTKLog(@&quot;Request %@ failed, status code = %ld, error = %@&quot;, NSStringFromClass([request class]), (long)request.responseStatusCode, error.localizedDescription); // 储存未完成的下载数据 NSData *incompleteDownloadData = error.userInfo[NSURLSessionDownloadTaskResumeData]; if (incompleteDownloadData) &#123; [incompleteDownloadData writeToURL:[self incompleteDownloadTempPathForDownloadPath:request.resumableDownloadPath] atomically:YES]; &#125; // Load response from file and clean up if download task failed. //如果下载任务失败，则取出对应的响应文件并清空 if ([request.responseObject isKindOfClass:[NSURL class]]) &#123; NSURL *url = request.responseObject; //isFileURL：是否是文件，如果是，则可以再isFileURL获取；&amp;&amp;后面是再次确认是否存在改url对应的文件 if (url.isFileURL &amp;&amp; [[NSFileManager defaultManager] fileExistsAtPath:url.path]) &#123; //将url的data和string赋给request request.responseData = [NSData dataWithContentsOfURL:url]; request.responseString = [[NSString alloc] initWithData:request.responseData encoding:[YTKNetworkUtils stringEncodingWithRequest:request]]; [[NSFileManager defaultManager] removeItemAtURL:url error:nil]; &#125; //清空request request.responseObject = nil; &#125; @autoreleasepool &#123; //请求失败的预处理，YTK没有定义，需要用户定义 [request requestFailedPreprocessor]; &#125; dispatch_async(dispatch_get_main_queue(), ^&#123; //告诉Accessories请求就要停止了 [request toggleAccessoriesWillStopCallBack]; //在真正的回调之前做的处理 [request requestFailedFilter]; //如果有代理，就调用代理 if (request.delegate != nil) &#123; [request.delegate requestFailed:request]; &#125; //如果传入了失败回调的block代码，就调用block if (request.failureCompletionBlock) &#123; request.failureCompletionBlock(request); &#125; //告诉Accessories请求已经停止了 [request toggleAccessoriesDidStopCallBack]; &#125;);&#125; 在这个方法里，首先判断了当前任务是否为下载任务，如果是，则储存当前已经下载好的data到resumableDownloadPath里面。而如果下载任务失败，则将其对应的在本地保存的路径上的文件清空。 到这里，我已经把单个请求从配置，发送，响应，回调的步骤都讲解完了。为了帮助大家理解整个过程，这里提供了整个的流程图： 我们说YTKNetworkAgent是请求的发送者，既然有发送，也就会有取消等操作，这就不得不提它的另外两个接口： 12345//YTKNetworkAgent.h/// 取消某个request- (void)cancelRequest:(YTKBaseRequest *)request;/// 取消所有添加的request- (void)cancelAllRequests; 首先我们看下取消某个request这个方法的实现： 1234567891011121314151617181920//YTKNetworkAgent.m/// 取消某个request- (void)cancelRequest:(YTKBaseRequest *)request &#123; NSParameterAssert(request != nil); //获取request的task，并取消 [request.requestTask cancel]; //从字典里移除当前request [self removeRequestFromRecord:request]; //清理所有block [request clearCompletionBlock];&#125;//从字典里移除某request- (void)removeRequestFromRecord:(YTKBaseRequest *)request &#123; //加锁 Lock(); [_requestsRecord removeObjectForKey:@(request.requestTask.taskIdentifier)]; YTKLog(@&quot;Request queue size = %zd&quot;, [_requestsRecord count]); Unlock();&#125; 取消所有在字典里添加的request： 12345678910111213141516//YTKNetworkAgent.m- (void)cancelAllRequests &#123; Lock(); NSArray *allKeys = [_requestsRecord allKeys]; Unlock(); if (allKeys &amp;&amp; allKeys.count &gt; 0) &#123; NSArray *copiedKeys = [allKeys copy]; for (NSNumber *key in copiedKeys) &#123; Lock(); YTKBaseRequest *request = _requestsRecord[key]; Unlock(); //stop每个请求 [request stop]; &#125; &#125;&#125; 这个stop方法是在YTKBaseRequest里面定义的： 123456789101112131415//YTKBaseRequest.m- (void)stop &#123; //告诉Accessories将要回调了 [self toggleAccessoriesWillStopCallBack]; //清空代理 self.delegate = nil; //调用agent的取消某个request的方法 [[YTKNetworkAgent sharedAgent] cancelRequest:self]; //告诉Accessories回调完成了 [self toggleAccessoriesDidStopCallBack];&#125; OK，看到这里，相信你对YTKNetwork单个请求的流程有了比较好的了解了，下面我们来看一下YTKNetwork的高级功能：批量请求和链式请求。 3.3 批量请求和链式请求YTKNetwork支持的批量请求有两种： 批量请求：多个请求几乎同时发起。 链式请求：当前个请求结束后才能发起下一个请求。 其实无论是批量请求，还是链式请求，我们都可以想到很可能是用一个数组将这些请求管理了起来。那么具体是如何实现的呢？ 我们首先来看一下YTKNetwork是如何实现批量请求的。 3.31批量请求YTKNetwork 使用YTKBatchRequest类来发送无序的批量请求，它需要用一个含有YTKRequest子类的数组来初始化，并将这个数组保存起来赋给它的_requestArray实例变量： 1234567891011121314151617181920//YTKBatchRequest.m- (instancetype)initWithRequestArray:(NSArray&lt;YTKRequest *&gt; *)requestArray &#123; self = [super init]; if (self) &#123; //保存为属性 _requestArray = [requestArray copy]; //批量请求完成的数量初始化为0 _finishedCount = 0; //类型检查，所有元素都必须为YTKRequest或的它的子类，否则强制初始化失败 for (YTKRequest * req in _requestArray) &#123; if (![req isKindOfClass:[YTKRequest class]]) &#123; YTKLog(@&quot;Error, request item must be YTKRequest instance.&quot;); return nil; &#125; &#125; &#125; return self;&#125; 初始化以后，我们就可以调用start方法来发起当前YTKBatchRequest实例所管理的所有请求了： 1234567891011121314151617181920212223242526272829303132333435//YTKBatchRequest.m//batch请求开始- (void)startWithCompletionBlockWithSuccess:(void (^)(YTKBatchRequest *batchRequest))success failure:(void (^)(YTKBatchRequest *batchRequest))failure &#123; [self setCompletionBlockWithSuccess:success failure:failure]; [self start];&#125;//设置成功和失败的block- (void)setCompletionBlockWithSuccess:(void (^)(YTKBatchRequest *batchRequest))success failure:(void (^)(YTKBatchRequest *batchRequest))failure &#123; self.successCompletionBlock = success; self.failureCompletionBlock = failure;&#125;- (void)start &#123; //如果batch里第一个请求已经成功结束，则不能再start if (_finishedCount &gt; 0) &#123; YTKLog(@&quot;Error! Batch request has already started.&quot;); return; &#125; //最开始设定失败的request为nil _failedRequest = nil; //使用YTKBatchRequestAgent来管理当前的批量请求 [[YTKBatchRequestAgent sharedAgent] addBatchRequest:self]; [self toggleAccessoriesWillStartCallBack]; //遍历所有request，并开始请求 for (YTKRequest * req in _requestArray) &#123; req.delegate = self; [req clearCompletionBlock]; [req start]; &#125;&#125; 在这里，我们可以看出： 在至少完成了其中一个请求以后，调用当前YTKBatchRequest实例的start方法会立即返回，否则可以无限制start。 YTKBatchRequest的实例是需要在发起请求之前，要被添加在YTKBatchRequestAgent里的数组里： 123456//YTKBatchRequestAgent.m- (void)addBatchRequest:(YTKBatchRequest *)request &#123; @synchronized(self) &#123; [_requestArray addObject:request]; &#125;&#125; 因为是批量发送请求，所以在这里是遍历YTKBatchRequest实例的_requestArray并逐一发送请求。因为已经封装好了单个的请求，所以在这里直接start就好了。 发起请求以后，在每个请求回调的代理方法里，来判断这次批量请求是否成功。 YTKRequest子类成功的回调： 123456789101112131415161718192021222324252627282930313233//YTKBatchRequest.m#pragma mark - Network Request Delegate- (void)requestFinished:(YTKRequest *)request &#123; //某个request成功后，首先让_finishedCount + 1 _finishedCount++; //如果_finishedCount等于_requestArray的个数，则判定当前batch请求成功 if (_finishedCount == _requestArray.count) &#123; //调用即将结束的代理 [self toggleAccessoriesWillStopCallBack]; //调用请求成功的代理 if ([_delegate respondsToSelector:@selector(batchRequestFinished:)]) &#123; [_delegate batchRequestFinished:self]; &#125; //调用批量请求成功的block if (_successCompletionBlock) &#123; _successCompletionBlock(self); &#125; //清空成功和失败的block [self clearCompletionBlock]; //调用请求结束的代理 [self toggleAccessoriesDidStopCallBack]; //从YTKBatchRequestAgent里移除当前的batch [[YTKBatchRequestAgent sharedAgent] removeBatchRequest:self]; &#125;&#125; 我们可以看到，在某个请求的回调成功以后，会让成功计数+1。在+1以后，如果成功计数和当前批量请求数组里元素的个数相等，则判定当前批量请求成功，并进行当前批量请求的成功回调。 接下来我们看一下某个请求失败的处理： YTKReques子类失败的回调： 12345678910111213141516171819202122232425262728293031//YTKBatchRequest.m- (void)requestFailed:(YTKRequest *)request &#123; _failedRequest = request; //调用即将结束的代理 [self toggleAccessoriesWillStopCallBack]; //停止batch里所有的请求 for (YTKRequest *req in _requestArray) &#123; [req stop]; &#125; //调用请求失败的代理 if ([_delegate respondsToSelector:@selector(batchRequestFailed:)]) &#123; [_delegate batchRequestFailed:self]; &#125; //调用请求失败的block if (_failureCompletionBlock) &#123; _failureCompletionBlock(self); &#125; //清空成功和失败的block [self clearCompletionBlock]; //调用请求结束的代理 [self toggleAccessoriesDidStopCallBack]; //从YTKBatchRequestAgent里移除当前的batch [[YTKBatchRequestAgent sharedAgent] removeBatchRequest:self];&#125; 在这里不难看出，当前批量请求里面只要有一个request失败了，则判定当前批量请求失败。而当前批量请求失败的回调（代理和block）会传入这个失败的request的实例。而且这个失败的request会先被赋给_failedRequest这个实例变量里。 总的来说，YTKBatchRequest类用一个数组来保存当前批量请求所要处理的所有request实例。而且用一个成功计数来判定当前批量请求整体是否成功。而当前批量请求的失败则是由这些request实例里面第一个失败的实例导致的：只要有一个request回调失败了，则立即停止其他的所有请求并调用当前批量请求的失败回调。 现在讲完了批量请求的处理，我们接下来看一下链式请求的处理。 3.32链式请求和批量请求类似，处理链式请求的类是YTKChainRequest，并且用YTKChainRequestAgent单例来管理YTKChainRequest的实例。 但是和批量请求不同的是，YTKChainRequest实例的初始化是不需要传入一个含有request的数组的： 12345678910111213141516171819202122//YTKChainRequest.m- (instancetype)init &#123; self = [super init]; if (self) &#123; //下一个请求的index _nextRequestIndex = 0; //保存链式请求的数组 _requestArray = [NSMutableArray array]; //保存回调的数组 _requestCallbackArray = [NSMutableArray array]; //空回调，用来填充用户没有定义的回调block _emptyCallback = ^(YTKChainRequest *chainRequest, YTKBaseRequest *baseRequest) &#123; // do nothing &#125;; &#125; return self;&#125; 但是它提供了添加和删除request的接口： 1234567891011121314//YTKChainRequest.m//在当前chain添加request和callback- (void)addRequest:(YTKBaseRequest *)request callback:(YTKChainCallback)callback &#123; //保存当前请求 [_requestArray addObject:request]; if (callback != nil) &#123; [_requestCallbackArray addObject:callback]; &#125; else &#123; //之所以特意弄一个空的callback，是为了避免在用户没有给当前request的callback传值的情况下，造成request数组和callback数组的不对称 [_requestCallbackArray addObject:_emptyCallback]; &#125;&#125; 注意，在给YTKChainRequest实例添加request实例的同时，还可以传入回调的block。当然也可以不传，但是为了保持request数组和callback数组的对称性（因为回调的时候是需要根据request数组里的index来获取callback数组里对应的callback的），YTKNetwork给我们提供了一个空的block。 我们接着看一下链式请求的发起： 123456789101112131415161718//YTKChainRequest.m- (void)start &#123; //如果第1个请求已经结束，就不再重复start了 if (_nextRequestIndex &gt; 0) &#123; YTKLog(@&quot;Error! Chain request has already started.&quot;); return; &#125; //如果请求队列数组里面还有request，则取出并start if ([_requestArray count] &gt; 0) &#123; [self toggleAccessoriesWillStartCallBack]; //取出当前request并start [self startNextRequest]; //在当前的_requestArray添加当前的chain（YTKChainRequestAgent允许有多个chain） [[YTKChainRequestAgent sharedAgent] addChainRequest:self]; &#125; else &#123; YTKLog(@&quot;Error! Chain request array is empty.&quot;); &#125;&#125; 我们可以看到，YTKChainRequest用_nextRequestIndex来保存下一个请求的index，它的默认值是0。而它的值的累加是在当前请求结束后，发起下面的请求之前进行的。所以说，如果已经完成了请求队列里的第一个请求，就无法在启动当前的请求队列了，会立即返回。 这里startNextRequest方法比较重要：在判断请求队列数组里面还有request的话，就会调用这个方法： 12345678910111213//YTKChainRequest.m- (BOOL)startNextRequest &#123; if (_nextRequestIndex &lt; [_requestArray count]) &#123; YTKBaseRequest *request = _requestArray[_nextRequestIndex]; _nextRequestIndex++; request.delegate = self; [request clearCompletionBlock]; [request start]; return YES; &#125; else &#123; return NO; &#125;&#125; 这个方法有两个作用： 第一个作用是判断是否能进行下一个request（如果index 大于或等于 request数组的count的话就不能在request数组里取出request，因为会造成数组越界） 第二个作用是如果可以进行下一个request，则发起该request。并将_nextRequestIndex+1。 所以和批量请求不同的是，链式请求的请求队列是可以变动的，用户可以无限制地添加请求。只要请求队列里面有请求存在，则YTKChainRequest就会继续发送它们。 现在我们知道了YTKChainRequest的发送，接下来看一下回调部分: 和YTKBatchRequest相同的是，YTKChainRequest也实现了YTKRequest的代理： 12345678910111213141516171819//某个request请求成功的代理的实现//YTKChainRequest.m- (void)requestFinished:(YTKBaseRequest *)request &#123; //1. 取出当前的request和callback，进行回调 NSUInteger currentRequestIndex = _nextRequestIndex - 1; YTKChainCallback callback = _requestCallbackArray[currentRequestIndex]; callback(self, request);//注意：这个回调只是当前request的回调，而不是当前chain全部完成的回调。当前chain的回调在下面 //2. 如果不能再继续请求了，说明当前成功的request已经是chain里最后一个request，也就是说当前chain里所有的回调都成功了，即这个chain请求成功了。 if (![self startNextRequest]) &#123; [self toggleAccessoriesWillStopCallBack]; if ([_delegate respondsToSelector:@selector(chainRequestFinished:)]) &#123; [_delegate chainRequestFinished:self]; [[YTKChainRequestAgent sharedAgent] removeChainRequest:self]; &#125; [self toggleAccessoriesDidStopCallBack]; &#125;&#125; 我们可以看到，在某个request回调成功以后，会根据当前请求的index（_nextRequestIndex-1）来获取其对应的block并调用。接着，再调用startNextRequest方法来判断当前的YTKChainRequest的请求队列里面是否还有其他的请求了： 如果没有了，则调用当前YTKChainRequest的最终成功的回调。 如果还有，则发起接下来的request（按顺序）。 接下来我们再看一下某个request失败的代理的实现： 123456789101112//YTKChainRequest.m//某个reqeust请求失败的代理- (void)requestFailed:(YTKBaseRequest *)request &#123; //如果当前 chain里的某个request失败了，则判定当前chain失败。调用当前chain失败的回调 [self toggleAccessoriesWillStopCallBack]; if ([_delegate respondsToSelector:@selector(chainRequestFailed:failedBaseRequest:)]) &#123; [_delegate chainRequestFailed:self failedBaseRequest:request]; [[YTKChainRequestAgent sharedAgent] removeChainRequest:self]; &#125; [self toggleAccessoriesDidStopCallBack];&#125; 如果当前的request请求失败了，则判定当前链式请求是失败的，则立即调用当前链式请求的失败回调。 现在我们知道了链式请求的请求和回调，再来看一下链式请求的终止： 123456789101112//YTKChainRequest.m//终止当前的chain- (void)stop &#123; //首先调用即将停止的callback [self toggleAccessoriesWillStopCallBack]; //然后stop当前的请求，再清空chain里所有的请求和回掉block [self clearRequest]; //在YTKChainRequestAgent里移除当前的chain [[YTKChainRequestAgent sharedAgent] removeChainRequest:self]; //最后调用已经结束的callback [self toggleAccessoriesDidStopCallBack];&#125; 这个stop方法是可以在外部调用的，所以用户可以随时终止当前链式请求的进行。它首先调用clearReuqest方法，将当前request停止，再将请求队列数组和callback数组清空。 1234567891011//YTKChainRequest.m- (void)clearRequest &#123; //获取当前请求的index NSUInteger currentRequestIndex = _nextRequestIndex - 1; if (currentRequestIndex &lt; [_requestArray count]) &#123; YTKBaseRequest *request = _requestArray[currentRequestIndex]; [request stop]; &#125; [_requestArray removeAllObjects]; [_requestCallbackArray removeAllObjects];&#125; 然后在YTKChainRequestAgent单例里面，将自己移除掉。 4. 最后的话阅读这个框架的源码我的收获是：加深了对命令模式，对Block的理解，知道了一个网络请求都需要什么元素组成，知道了网络缓存该怎么设计，也知道了链式请求怎么设计等等。 我还记得当初听说YTKNetwork能发起链式请求的时候觉得毫无思路的感觉，不过现在应该没什么问题了。 所以说多阅读源码对技术水平的提升是很有帮助的，除了能增多对本语言API的了解，其实更有意义的是它能让你接触到一些新的设计和解决问题的办法，这些都是脱离某个语言本身的东西，也是作为一名程序员所必不可少的东西。 希望这篇文章能对读者们有所帮助~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构&算法 in Swift]]></title>
    <url>%2F2018%2F04%2F08%2FData%20Structure%20%26%20Algorithm%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[写在前面作为该系列的开篇，本文分为一下几个部分： Swift语法基础：讲解一下后续连载中讲到的数据结构和算法所涉及到的Swift语法知识（并不是很全面，也不是很深入，但是在实现数据结构和算法这块应该是够了）。 数据结构：简单介绍数据结构和算法的相关概念，以及用Swift来实现几个简单的数据结构（链表，栈，队列） 算法基础：简单介绍算法的概念，时间复杂度与空间复杂度，递归，作为本文第二部分的背景知识。 排序算法：结合Swift的代码实现来讲解冒泡排序，选择排序，插入排序，归并排序，快速排序。 Swift 语法基础Swift语法基础从以下几点来展开： 循环语句 泛型 guard 函数 集合 循环语句循环条件的开闭区间Swift将循环的开闭区间做了语法上的简化： 闭区间： 12345678for index in 1...5 &#123; print(&quot;index: \(index)&quot;)&#125;// index : 1// index : 2// index : 3// index : 4// index : 5 半开闭区间： 1234567for index in 1..&lt;5 &#123; print(&quot;index: \(index)&quot;)&#125;// index : 1// index : 2// index : 3// index : 4 循环的升序与降序 上面两个例子都是升序的（index从小到大），我们来看一下降序的写法： 1234567for index in (1..&lt;5).reversed() &#123; print(&quot;index: \(index)&quot;)&#125;// index : 4// index : 3// index : 2// index : 1 降序的应用可以在下篇的冒泡排序算法中可以看到。 泛型使用泛型可以定义一些可复用的函数或类型，Swift中的Array和Dictionary都是泛型的集合。 为了体现出泛型的意义，下面举一个例子来说明一下： 实现这样一个功能:将传入该函数的两个参数互换。 整型的交换： 12345func swapTwoInts(_ a: inout Int, _ b: inout Int) &#123; let tmp = a a = b b = tmp&#125; 字符串的交换： 12345func swapTwoStrings(_ a: inout String, _ b: inout String) &#123; let tmp = a a = b b = tmp&#125; 浮点型的交换： 12345func swapTwoDoubles(_ a: inout Double, _ b: inout Double) &#123; let tmp = a a = b b = tmp&#125; 上面这三种情况的实现部分其实都是一样的，但仅仅是因为传入类型的不一致，导致对于不同的类型还要定义一个新的函数。所以如果类型有很多的话，定义的新函数也会很多，这样显然是不够优雅的。 此类问题可以使用泛型来解决： 12345func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T) &#123; let tmp = a a = b b = tmp&#125; 上面函数中的T是泛型的固定写法，可以理解为“所有类型”。这样一来，我们可以传入任何相同的类型来作交换了。 泛型还有其他比较强大的功能，由于在后续的数据结构和算法的讲解里面可能不会涉及到，所以在这里先不赘述了。有兴趣的朋友可以参考官方文档：Swift：Generics guard guard是 swift 2.0推出的新的判断语句的用法。 与if语句相同的是，guard也是基于一个表达式的布尔值去判断一段代码是否该被执行。与if语句不同的是，guard只有在条件不满足的时候才会执行这段代码。你可以把guard近似的看做是Assert，但是你可以优雅的退出而非崩溃 使用guard语法，可以先对每个条件逐一做检查，如果不符合条件判断就退出（或者进行其他操作）。这就会让人容易看出来什么条件会让这个函数退出（或者进行其他某些操作）。 可以用一个例子来分别使用if和guard来实现，体会二者的区别： 使用if-else1234567891011121314151617181920212223242526//money: holding moneny (用户持有的钱数)//price: product price (商品的价格)//capacity: bag capacity (用户用来装商品的袋子容量)//volume: product size (商品的大小)func buying1( money: Int , price: Int , capacity: Int , volume: Int)&#123; if money &gt;= price &#123; if capacity &gt;= volume&#123; print(&quot;Start buying...&quot;) print(&quot;\(money-price) money left after buying.&quot;) print(&quot;\(capacity-volume) capacity left after buying.&quot;) &#125;else&#123; print(&quot;No enough capacity&quot;) &#125; &#125;else&#123; print(&quot;No enough money&quot;) &#125;&#125; 从上面的逻辑可以看出，当同时满足： 1. 用户的钱数&gt;商品价格 2. 用户用来装商品的袋子容量&gt;商品的大小 这两个情况的时候，购买才会进行，其他所有情况都无法引发购买。 对于大多数习惯使用if-else的朋友来说，上面的代码立即起来并没有难度，但是相同的逻辑，我们看一下使用guard之后的效果： 使用guard12345678910111213141516func buying2( money: Int , price: Int , capacity: Int , volume: Int)&#123; guard money &gt;= price else&#123; print(&quot;No enough money&quot;) return &#125; guard capacity &gt;= volume else&#123; print(&quot;No enough capacity&quot;) return &#125; print(&quot;Start buying...&quot;) print(&quot;\(money-price) money after buying.&quot;) print(&quot;\(capacity-volume) capacity left after buying.&quot;)&#125; 从上面的实现可以看出： 使用guard以后，将money &lt; price和capacity &lt; volume 这两个情况首先排除掉并填上了相应的处理代码。 在两个guard下面才是真正正确逻辑后的处理代码。 因此通过两个guard判断的语句，我们知道该函数所处理的正确逻辑是什么，非常清晰。 函数因为后续的数据结构和算法的讲解是离不开函数的使用的，所以在这里简单介绍一下Swift中函数的使用。 无返回值的函数 有返回值的函数 省略函数的外部参数名 值传递和引用传递 无返回值的函数12345func log(message: String) &#123; print(&quot;log: \(message)!&quot;)&#125;log(message: &quot;memory warning&quot;)// output: log: memory warning! 有返回值的函数123456func logString(string: String) -&gt; String &#123; return &quot;log: &quot; + string&#125;let logStr = logString(string: &quot;memory warning!&quot;)print(&quot;\(logStr)&quot;)// output: log: memory warning! 省略函数外部参数名通过在函数形参前面加上_,可以起到在调用时省略外部参数的作用： 12345func logMessage(_ message: String) &#123; print(&quot;log: \(message)!&quot;)&#125;logMessage(&quot;memory warning&quot;)// output: log: memory warning! 再来看一下两个参数的情况： 12345func addInt(_ a : Int ,_ b : Int)&#123; print(&quot;sum is \(a + b)&quot;)&#125;addInt(3, 4)//output : sum is 7 值传递和引用传递Swift中，struct是按值传递，class是按引用传递。数组和字典在Swift里是属于struct，所以需要如果在一个函数里要修改传入的数组，需要做特殊处理： 123456789var originalArr = [2,1,3]func removeLastInArray(_ array: inout [Int])&#123; array.removeLast()&#125;print(&quot;\n============ before removing: \(originalArr)&quot;)//[2, 1, 3]removeLastInArray(&amp;originalArr)print(&quot;============ after removing: \(originalArr)&quot;)//[2, 1] 在这里使用的inout关键字就是将传入的数组改为引用传递了。 集合Swift里的集合类型有：数组，集合，字典，下面来分别讲一下。 这三种类型都只支持泛型，也就是说里面的元素可以是整数，字符串，浮点，对象等等。 数组 Swift’s Array type is bridged to Foundation’s NSArray class. 可变数组与不可变数组1234// immutable arraylet immutableNumbers: [Int] = [1, 3, 5, 4, 4, 1]// mutable arrayvar mutableNumbers : [Int] = [2, 1, 5, 4, 1, 3] Swift中可以用let和var来分别声明可变和不可变数组：数组的添加删除等操作只能作用于可变数组。 数组的遍历12345678910111213141516// iteration 1for value in mutableNumbers &#123; if let index = mutableNumbers.index(of: value) &#123; print(&quot;Index of \(value) is \(index)&quot;) &#125;&#125;// iteration 2mutableNumbers.forEach &#123; value in if let index = mutableNumbers.index(of: value) &#123; print(&quot;Index of \(value) is \(index)&quot;) &#125;&#125;// iteration 3for (index, value) in mutableNumbers.enumerated() &#123; print(&quot;Item \(index + 1): \(value)&quot;)&#125; 数组的操作1234567891011121314mutableNumbers.append(11)// Output: [2, 1, 5, 4, 1, 3, 11]mutableNumbers.insert(42, at: 4)// Output: [2, 1, 5, 4, 42, 1, 3, 11]mutableNumbers.swapAt(0, 1)// Output: [1, 2, 5, 4, 42, 1, 3, 11]mutableNumbers.remove(at: 1)// Output: [2, 5, 4, 42, 1, 3, 11]mutableNumbers.removeFirst()// Output: [5, 4, 42, 1, 3, 11]mutableNumbers.removeLast()// Output: [5, 4, 42, 1, 3]mutableNumbers.removeAll()//[] append函数的作用是在数组的末尾添加元素 swapAt函数的作用是交换在传入的两个index上的元素，该方法在下篇的排序算法中使用得非常频繁。 集合 Swift’s Set type is bridged to Foundation’s NSSet class. 集合的无序性，值的唯一性关于集合与数组的区别，除了数组有序，集合无序以外，数组内部的元素的数值可以不是唯一的；但是集合里元素的数值必须是唯一的，如果有重复的数值会算作是一个： 1234567//value in set is uniquelet onesSet: Set = [1, 1, 1, 1]print(onesSet)// Output: [1]let onesArray: Array = [1, 1, 1, 1]print(onesArray)// Output: [1, 1, 1, 1] 集合的遍历12345678910111213let numbersSet: Set = [1, 2, 3, 4, 5]print(numbersSet)// Output: undefined order, e.g. [5, 2, 3, 1, 4]// iteration 1for value in numbersSet &#123; print(value)&#125;// output is in undefined order// iteration 2numbersSet.forEach &#123; value in print(value)&#125;// output is in undefined order 集合的操作12345678910111213141516171819202122232425262728293031var mutableStringSet: Set = [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]let item = &quot;Two&quot;//containsif mutableStringSet.contains(item) &#123; print(&quot;\(item) found in the set&quot;)&#125; else &#123; print(&quot;\(item) not found in the set&quot;)&#125;//isEmptylet strings = Set&lt;String&gt;()if strings.isEmpty &#123; print(&quot;Set is empty&quot;)&#125;//countlet emptyStrings = Set&lt;String&gt;()if emptyStrings.count == 0 &#123; print(&quot;Set has no elements&quot;)&#125;//insertmutableStringSet.insert(&quot;Four&quot;)//remove 1mutableStringSet.remove(&quot;Three&quot;)//remove 2if let removedElement = mutableStringSet.remove(&quot;Six&quot;) &#123; print(&quot;\(removedElement) was removed from the Set&quot;)&#125; else &#123; print(&quot;Six is not found in the Set&quot;)&#125;//removeAll()mutableStringSet.removeAll()// [] 字典 A dictionary Key type must conform to the Hashable protocol, like a set’s value type. 字典的声明12345678//empty dictionaryvar dayOfWeek = Dictionary&lt;Int, String&gt;()var dayOfWeek2 = [Int: String]()//not empty dictionaryvar dayOfWeek3: [Int: String] = [0: &quot;Sun&quot;, 1: &quot;Mon&quot;, 2: &quot;Tue&quot;]print(dayOfWeek3)//output:[2: &quot;Tue&quot;, 0: &quot;Sun&quot;, 1: &quot;Mon&quot;] 可以看到字典的键值对也是无序的，它与声明时的顺序不一定一致。 字典的遍历123456789101112// iteration 1for (key, value) in dayOfWeek &#123; print(&quot;\(key): \(value)&quot;)&#125;// iteration 2for key in dayOfWeek.keys &#123; print(key)&#125;// iteration 3for value in dayOfWeek.values &#123; print(value)&#125; 字典的操作1234567891011121314151617181920212223242526272829303132333435// find valuedayOfWeek = [0: &quot;Sun&quot;, 1: &quot;Mon&quot;, 2: &quot;Tue&quot;]if let day = dayOfWeek[2] &#123; print(day)&#125;// addValue 1dayOfWeek[3] = &quot;Wed&quot;print(dayOfWeek)// Prints: [2: &quot;Tue&quot;, 0: &quot;Sun&quot;, 1: &quot;Mon&quot;, 3: &quot;Wed&quot;]// updateValue 1dayOfWeek[2] = &quot;Mardi&quot;print(dayOfWeek)// Prints: [2: &quot;Mardi&quot;, 0: &quot;Sun&quot;, 1: &quot;Mon&quot;, 3: &quot;Wed&quot;]// updateValue 2dayOfWeek.updateValue(&quot;Tue&quot;, forKey: 2)print(dayOfWeek)// Prints: [2: &quot;Tue&quot;, 0: &quot;Sun&quot;, 1: &quot;Mon&quot;, 3: &quot;Wed&quot;]// removeValue 1dayOfWeek[1] = nilprint(dayOfWeek)// Prints: [2: &quot;Tue&quot;, 0: &quot;Sun&quot;, 3: &quot;Wed&quot;]// removeValue 2dayOfWeek.removeValue(forKey: 2)print(dayOfWeek)// Prints: [0: &quot;Sun&quot;, 3: &quot;Wed&quot;]// removeAlldayOfWeek.removeAll()print(dayOfWeek)// Output: [:] 可以看到从字典里面删除某个键值对有两个方法： 使用removeValue方法并传入要删除的键值对里的键。 将字典取下标之后将nil赋给它。 数据结构这一部分内容主要让大家对数据结构先有一个基本的认识，因此在概念上不会深入讲解。该部分由以下三点展开： 数据结构的基本概念 抽象数据类型 链表，栈和队列的实现 概念首先我们来看一下数据结构的概念： 数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。 由数据结构这个词汇的本身（数据的结构）以及它的概念可以看出，它的重点在于“结构”和“关系”。所以说，数据是何种数据并不重要，重要的是这些数据是如何联系起来的。 而这些联系，可以从两个维度来展开： 逻辑结构：指数据对象中元素之间的相互关系。 物理结构：指数据的逻辑结构在计算机中的存储形式。 可以看出，逻辑结构是抽象的联系，而物理结构是实际在计算机内存里的具体联系。那么它们自己又细分为哪些结构呢？ 逻辑结构： 集合结构：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。 线性结构：线性结构中的数据元素之间是一对一的关系。 树形结构：数据结构中的元素存在一对多的相互关系。 图形结构：数据结构中的元素存在多对多的相互关系。 物理结构： 顺序存储结构：把数据元素粗放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的（数组）。 链式存储结构：把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。 为了便于记忆，用思维导图总结一下上面所说的： 而通过结合这两个维度中的某个结构，可以定义出来一个实际的数据结构的实现： 顺序存储结构的线性表就是数组：它的内存分布是连续的，元素之间可以通过内存地址来做关联； 链式存储结构的线性表就是链表：它的内存分布可以是不连续的，元素之间通过指针来做关联： 如果每个元素（在链表中称作节点）只持有指向后面节点的指针，那此链表就是单链表。 如果每个元素（在链表中称作节点）持有指向前后节点的两个指针，那此链表就是双链表。 为什么会有链表这么麻烦的东西？像数组这样，所有内存地址都是连续的不是很方便么？既生瑜何生亮呢？ 对于获取元素（节点）这一操作，使用数组这个数据结构确实非常方便：因为所有元素在内存中是连续的，所以只需要知道数组中第一个元素的地址以及要获取元素的index就能算出该index内存的地址，一步到位非常方便。 但是对于向数组中某个index中插入新的元素的操作恐怕就没有这么方便了：恰恰是因为数组中所有元素的内存是连续的，所以如果想在中间插入一个新的元素，那么这个位置后面的所有元素都要后移，显然是非常低效的。如果插在数组尾部还好，如果插在第一位的话成本就太高了。 而如果使用链表，只要把要插入到的index前后节点的指针赋给这个新的节点就可以了，不需要移动原有节点在内存中的位置。 关于链表的这种插入操作会在后面用代码的形式体现出来。 既然有这么多的数据结构，那么有没有一个标准的格式来将这些特定的数据结构（也可以说是数学模型）抽象出来呢？答案是肯定的，它就是我们下一节要讲的抽象数据类型。 抽象数据类型首先来看一下抽象数据类型的概念，摘自《大话数据结构》: 抽象数据类型（Abstract Data Type，ADT）：是指一个数学模型及定义在该模型上的一组操作。 需要注意的是：抽象数据类型的定义仅仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现没有关系。而且，抽象数据类型不仅仅指那些已经定义并实现的数据类型，还尅是计算机编程者自己定义的数据类型。 我们看一下数据类型的标准格式： 123456789101112131415ADT 抽象数据类型名Data 数据元素之间逻辑关系的定义 Operation 操作1 初始条件 操作结果描述 操作2 初始条件 操作结果描述 操作nendADT 其实看上去和面向对象编程里的类的定义相似： 可以把抽象数据类型的Data 和 类的成员变量联系起来。 可以把抽象数据类型的操作和类的函数联系起来。 简单来说，抽象数据类型描述了一个数据模型所使用的数据和数据之间的逻辑关系，以及它可以执行的一些操作。因此，如果知道了一个数学模型的抽象数据类型，那么在真正接触数学模型的实现（代码）之前，就可以对该数学模型能做的事情有一个大致的了解。 下一章笔者会介绍链表，栈和队列这三个数学模型，在讲解每个数学模型的实现之前都会给出它们各自的抽象数据类型，让读者可以先对当前数学模型有个大致的了解。 注意：书本文归纳的所有抽象数据类型是笔者自己根据网上资料和相关书籍而定下来的，所以严格来说它们并不是“最官方”的抽象数据类型。读者也可以参考网上的资料或是相关书籍，结合自己的思考来定义自己对着三个数据模型的抽象数据类型。 链表，栈和队列的实现通过上一节的介绍，我们知道了数据结构的概念以及分类，还知道了不同的数据结构在不同的场景下会发挥不同的优势，我们要根据实际的场景来选择合适的数据结构。 下面就来介绍几种在实际应用中使用的比较多的数学模型： 链表 栈 队列 链表（Linked list）说到链表就不得不提线性表这一数据结构，在介绍链表之前，首先看一下线性表的定义： 线性表：零个或多个数据元素的有限序列。 而根据物理结构的不同，线性表有两种具体的实现方式： 线性表的顺序存储结构：线性表的数据元素是被一段地址连续的存储单存储起来的。 线性表的链式存储结构: 线性表的数据元素是被用一组连续或不连续的存储单元存储起来的，这些元素通过指针来作为逻辑上的连接。 注：上面两个概念是笔者用自己的话总结出来的。 在这里，线性表的顺序存储结构的实现就是我们熟悉的数组；而线性表的链式存储结构的实现就是笔者即将要介绍的链表。 链表的定义相信对于读完上一节的朋友来说，应该对链表有一个比较清晰的认识了。关于链表的定义有很多不同的版本，笔者个人比较喜欢百度百科里的定义： 链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。 而且由于数据元素所持有的指针个数和链接特性可以将链表分为： 单向链表：单向链表的链接方向是单向的，其中每个结点都有指针成员变量指向列表中的下一个结点； 双向链表：双向链表的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点，它的链接方向是双向的。 循环链表：循环链表是另一种形式的链式存贮结构。它的特点是表中最后一个结点的指针域指向头结点，整个链表形成一个环。 笔者从中挑选出双向链表来进行讲解，它的难度适中，而且能够很好地让读者体会出链表的优势。 双向链表的抽象数据类型因为节点是链表的基本组成单元，所以想要实现链表，必须先要介绍链表的组成部分-节点。 节点：123456789ADT 节点(node)Data value:持有的数据Operation init:初始化 previous:指向上一节点的指针 next:指向下一节点的指针 endADT 再来看一下链表的抽象数据类型： 123456789101112131415161718ADT 链表（linked list）Data linked list:持有的线性表Operation init:初始化 count:持有节点总个数 isEmpty:是否为空 first:头节点 last:尾节点 node:传入index返回节点 insert:插入node到指定index insertToHead:插入节点到表头 appendToTail:插入节点到表尾 removeAll:移除所有节点 remove:移除传入的节点 removeAt:移除传入index的节点 endADT 双向链表的实现节点1234567891011121314151617public class LinkedListNode&lt;T&gt; &#123; //value of a node var value: T //pointer to previous node weak var previous: LinkedListNode? //pointer to next node var next: LinkedListNode? //init public init(value: T) &#123; self.value = value &#125;&#125; 再来看一下链表的实现： 因为整个链表的插入，删除等操作比较多，整个链表的定义超过了200行代码，所以为了看着方便一点，在这里来分段说明一下。 首先看一下链表的成员变量: 成员变量12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class LinkedList&lt;T&gt; &#123; public typealias Node = LinkedListNode&lt;T&gt; //if empty public var isEmpty: Bool &#123; return head == nil &#125; //total count of nodes public var count: Int &#123; guard var node = head else &#123; return 0 &#125; var count = 1 while let next = node.next &#123; node = next count += 1 &#125; return count &#125; //pointer to the first node, private private var head: Node? //pointer to the first node, public public var first: Node? &#123; return head &#125; //pointer to the last node public var last: Node? &#123; guard var node = head else &#123; return nil &#125; //until node.next is nil while let next = node.next &#123; node = next &#125; return node &#125; ... &#125; 相信看上面的命名以及注释大家可以对链表的成员变量有个初步的理解，这里面需要说三点： typealias是用来重新为已经存在的类型命名的：这里用Node代替了LinkedListNode&lt;T&gt;（节点类型），降低了不少阅读代码的成本。 在获取count和last的实现，都先判断了head这个指针是否为nil，如果是则判定为空链表，自然也就不存在节点个数和最后的节点对象了。 同样地，也是在获取count和last的实现里，使用了while控制语句来判断node.next节点是否存在：如果存在，则继续+1或者继续往下寻找，直到node.next为nil时才停止。在这里我们可以看到链表的寻址方式：是通过头结点开始，以节点的.next指针来寻找下一个节点的。而且作为链表的尾节点，它的.next指针不指向任何对象，因为它本来就是链表的最后一项。 最下方的…代表即将在下面介绍的一些函数，这些函数都定义在的LinkedList这个class里面。 获取index上node1234567891011121314151617181920//get node of indexpublic func node(atIndex index: Int) -&gt; Node? &#123; if index == 0 &#123; //head node return head! &#125; else &#123; var node = head!.next guard index &lt; count else &#123; return nil; &#125; for _ in 1..&lt;index &#123; // go on finding by .next node = node?.next if node == nil &#123; break &#125; &#125; return node! &#125;&#125; 注意在这里返回的node是可以为nil的，而且在这里可以看出来，链表在寻找特定node的时候，是根据节点的.next指针来一个一个寻找的。这个与顺序存储结构的数组是不同的，在后面我会重点讲解一下这二者的不同。 插入节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//insert node to last indexpublic func appendToTail(value: T) &#123; let newNode = Node(value: value) if let lastNode = last &#123; //update last node: newNode becomes new last node; //the previous last node becomes the second-last node newNode.previous = lastNode lastNode.next = newNode &#125; else &#123; //blank linked list head = newNode &#125;&#125;//insert node to index 0public func insertToHead(value: T) &#123; let newHead = Node(value: value) if head == nil &#123; //blank linked list head = newHead &#125;else &#123; newHead.next = head head?.previous = newHead head = newHead &#125;&#125;//insert node in specific indexpublic func insert(_ node: Node, atIndex index: Int) &#123; if index &lt; 0 &#123; print(&quot;invalid input index&quot;) return &#125; let newNode = node if count == 0 &#123; head = newNode &#125;else &#123; if index == 0 &#123; newNode.next = head head?.previous = newNode head = newNode &#125; else &#123; if index &gt; count &#123; print(&quot;out of range&quot;) return &#125; let prev = self.node(atIndex: index-1) let next = prev?.next newNode.previous = prev newNode.next = prev?.next prev?.next = newNode next?.previous = newNode &#125; &#125;&#125; 链表的插入节点的操作分为三种，按照从上到下的顺序依次是： 在头部插入 在尾部插入 指定index插入 需要注意的是 在前两种插入函数中，需要先判断该链表是否是空的，如果是，则要将链表的该节点赋给链表的head指针。 在第三种插入函数中，还是先判断该链表是否是空的，如果是，则无论index是多少(只要不小于0)，都插在链表的头部。如果不是空的，再判断index是否为0，如果是，则直接插在头部；如果index不为0，则判断index是否大于count，如果是，则无法插入；如果不是，则获取插入位置的前后节点进行重连。 在这里判断链表为空链表后的处理是笔者自己加上去的，笔者在网上的资料里没有看到过。大家不必纠结于这种处理方式，毕竟链表操作的重点在于前后节点的重连。 移除节点 1234567891011121314151617181920212223242526272829303132333435363738394041//removing all nodespublic func removeAll() &#123; head = nil&#125;//remove the last nodepublic func removeLast() -&gt; T? &#123; guard !isEmpty else &#123; return nil &#125; return remove(node: last!)&#125;//remove a node by it&apos;s refrencepublic func remove(node: Node) -&gt; T? &#123; guard head != nil else &#123; print(&quot;linked list is empty&quot;) return nil &#125; let prev = node.previous let next = node.next if let prev = prev &#123; prev.next = next &#125; else &#123; head = next &#125; next?.previous = prev node.previous = nil node.next = nil return node.value&#125;//remove a node by it&apos;s indexpublic func removeAt(_ index: Int) -&gt; T? &#123; guard head != nil else &#123; print(&quot;linked list is empty&quot;) return nil &#125; let node = self.node(atIndex: index) guard node != nil else &#123; return nil &#125; return remove(node: node!)&#125; 如果要移除链表上所有节点，只需要将head指针置空就可以了，因为它是所有节点的“源头”，是链表寻址的第一个节点。 在持有某个节点的指针的时候可以指定链表来移除这个节点（使用remove函数）。在这个函数内部，首先需要将该节点的前后节点对接，然后将该几点的前后指针置空。 当有要移除节点的指针但是知道该节点在链表中的index，可以使用removeAt函数。在这个函数内部，首先根据index来获取对应的node的指针，然后再调用remove函数删除这个node。 打印所有节点123456789101112131415public func printAllNodes()&#123; guard head != nil else &#123; print(&quot;linked list is empty&quot;) return &#125; var node = head print(&quot;\nstart printing all nodes:&quot;) for index in 0..&lt;count &#123; if node == nil &#123; break &#125; print(&quot;[\(index)]\(node!.value)&quot;) node = node!.next &#125;&#125; 该函数只是为了方便调试，为了跟踪链表的状态而定义的，它并不存在于链表的模型里。 为了验证上面这些方法的有效性，我们来实例化一个链表后实际操作一下，读者可以结合注释来看一下每一步对应的结果： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374let list = LinkedList&lt;String&gt;()list.isEmpty // truelist.first // nillist.count // 0list.appendToTail(value: &quot;Swift&quot;)list.isEmpty // falselist.first!.value // &quot;Swift&quot;list.last!.value // &quot;Swift&quot;list.count //1list.appendToTail(value:&quot;is&quot;)list.first!.value // &quot;Swift&quot;list.last!.value // &quot;is&quot;list.count // 2list.appendToTail(value:&quot;great&quot;)list.first!.value // &quot;Swift&quot;list.last!.value // &quot;great&quot;list.count // 3list.printAllNodes()//[0]Swift//[1]is//[2]Greatlist.node(atIndex: 0)?.value // Swiftlist.node(atIndex: 1)?.value // islist.node(atIndex: 2)?.value // greatlist.node(atIndex: 3)?.value // nillist.insert(LinkedListNode.init(value: &quot;language&quot;), atIndex: 1)list.printAllNodes()//[0]Swift//[1]language//[2]is//[3]greatlist.remove(node: list.first!)list.printAllNodes()//[0]language//[1]is//[2]greatlist.removeAt(1)list.printAllNodes()//[0]language//[1]greatlist.removeLast()list.printAllNodes()//[0]languagelist.insertToHead(value: &quot;study&quot;)list.count // 2list.printAllNodes()//[0]study//[1]languagelist.removeAll()list.printAllNodes()//linked list is emptylist.insert(LinkedListNode.init(value: &quot;new&quot;), atIndex: 3)list.printAllNodes()//[0]newlist.insert(LinkedListNode.init(value: &quot;new&quot;), atIndex: 3) //out of rangelist.printAllNodes()//[0]newlist.insert(LinkedListNode.init(value: &quot;new&quot;), atIndex: 1)list.printAllNodes()//[0]new//[1]new 栈（Stack）栈的讲解从 栈的定义 栈的抽象数据类型 栈的实现 三个部分来展开。 栈的定义首先来看一下栈的定义： 栈是限定仅在表的尾部进行插入和删除操作的线性表。 从定义中可以看出，我们知道我们只能在栈的一端来操作栈： 允许插入和删除的一端成为栈顶 另一端成为栈底 用一张图来看一下栈的操作： 图源：《维基百科：Stack (abstract data type)》 从上图可以看出，最先压入栈里面的只能最后访问，也就是说，栈遵循后进先出（Last In First Out, LIFO）的原则。 栈的抽象数据类型123456789101112ADT 栈（Stack）Data linked list:持有的线性表Operation init:初始化 count:栈的元素个数 isEmpty:是否为空 push:入栈 pop:出栈 top:返回顶部元素 endADT 上面的operation可能不全，但是涵盖了栈的一些最基本的操作。那么基于这个抽象数据类型，我们来看一下如何使用Swift来实现它。 栈的实现笔者将数组（顺序存储）作为栈的线性表的实现，同时支持泛型。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public struct Stack&lt;T&gt; &#123; //array fileprivate var stackArray = [T]() //count public var count: Int &#123; return stackArray.count &#125; //is empty ? public var isEmpty: Bool &#123; return stackArray.isEmpty &#125; //top element public var top: T? &#123; if isEmpty&#123; return nil &#125;else &#123; return stackArray.last &#125; &#125; //push operation public mutating func push(_ element: T) &#123; stackArray.append(element) &#125; //pop operation public mutating func pop() -&gt; T? &#123; if isEmpty&#123; print(&quot;stack is empty&quot;) return nil &#125;else &#123; return stackArray.removeLast() &#125; &#125; //print all public mutating func printAllElements() &#123; guard count &gt; 0 else &#123; print(&quot;stack is empty&quot;) return &#125; print(&quot;\nprint all stack elemets:&quot;) for (index, value) in stackArray.enumerated() &#123; print(&quot;[\(index)]\(value)&quot;) &#125; &#125;&#125; fileprivate：是Swift3.0新增的访问控制，表示在定义的声明文件里可访问。它代替了过去意义上的private。而有了fileprivate以后，新的private则代表了真正的私有：在这个类或结构体的外部无法访问。 这里printAllElements方法也不属于抽象数据类型里的方法，也是为了方便调试，可以打印出所有的数据元素。 我们来实例化上面定义的栈实际操作一下： 123456789101112131415161718192021222324var stack = Stack.init(stackArray: [])stack.printAllElements() //stack is emptystack.isEmpty //truestack.push(2)stack.printAllElements()//[0]2stack.isEmpty //falsestack.top //2stack.push(3)stack.printAllElements()//[0]2//[1]3stack.isEmpty //falsestack.top //3stack.pop()stack.printAllElements()//[0]2stack.isEmpty //falsestack.top //2stack.pop()stack.printAllElements() //stack is emptystack.top //nilstack.isEmpty //truestack.pop() //stack is empty 队列（Queue）队列的讲解从 队列的定义 队列的抽象数据类型 队列的实现 三个部分来展开。 队列的定义 图源：《维基百科：FIFO (computing and electronics)》 队列的抽象数据类型123456789101112ADT 队列（Queue）Data linked list:持有的线性表Operation init:初始化 count:栈的元素个数 isEmpty:是否为空 front:获取队列头元素 enqueue:插入到队尾 dequeue:删除队列头元素并返回 endADT 和上面的栈的实现一致，队列的实现也使用数组来实现队列内部的线性表。 队列的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public struct Queue&lt;T&gt; &#123; //array fileprivate var queueArray = [T]() //count public var count: Int &#123; return queueArray.count &#125; //is empty? public var isEmpty: Bool &#123; return queueArray.isEmpty &#125; //front element public var front: T? &#123; if isEmpty &#123; print(&quot;queue is empty&quot;) return nil &#125; else &#123; return queueArray.first &#125; &#125; //add element public mutating func enqueue(_ element: T) &#123; queueArray.append(element) &#125; //remove element public mutating func dequeue() -&gt; T? &#123; if isEmpty &#123; print(&quot;queue is empty&quot;) return nil &#125; else &#123; return queueArray.removeFirst() &#125; &#125; //print all public mutating func printAllElements() &#123; guard count &gt; 0 else &#123; print(&quot;queue is empty&quot;) return &#125; print(&quot;\nprint all queue elemets:&quot;) for (index, value) in queueArray.enumerated() &#123; print(&quot;[\(index)]\(value)&quot;) &#125; &#125; &#125; 我们初始化一个队列后实际操作一下： 1234567891011121314151617181920212223242526272829303132333435363738var queue = Queue.init(queueArray: [])queue.printAllElements()//queue is emptyqueue.isEmpty //truequeue.count //0queue.enqueue(2)queue.printAllElements()queue.isEmpty //false//[0]2queue.enqueue(3)queue.printAllElements()//[0]2//[1]3queue.enqueue(4)queue.printAllElements()//[0]2//[1]3//[2]4queue.front //2queue.dequeue()queue.printAllElements()//[0]3//[1]4queue.front //3queue.dequeue()queue.printAllElements()//[0]4queue.front //4queue.dequeue()queue.printAllElements() //queue is emptyqueue.front //return nil, and print : queue is emptyqueue.isEmpty //truequeue.count//0 算法算法基础 该部分是给那些对算法以及相关知识不了解的读者准备的，如果已经对算法的相关知识有所了解，可以略过该部分，直接看本文的第二部分：排序算法。 关于该部分的讨论不属于本文介绍的重点，因此没有过多非常专业的论述，只是让那些对算法不了解的读者可以对算法先有一个基本的认识，为阅读和理解本文的第二部分做好准备。 算法的概念算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。 摘自《大话数据结构》 简单说来，算法就是“一个问题的解法”。对于相同一个问题，可能会有多种不同的解法。这些解法虽然可以得到相同的结果，但是每个算法的执行所需要的时间和空间资源却可以是千差万别的。 以消耗的时间的角度为出发点，我们看一下对于同一个问题，两种不同的解法的效率会相差多大： 现在让我们解决这个问题：计算从1到100数字的总和。 把比较容易想到的下面两种方法作为比较： 1到100循环遍历逐步相加 等差数列求和 用Swift函数来分别实现一下： 12345678910111213141516func sumOpration1(_ n:Int) -&gt; Int&#123; var sum = 0 for i in 1 ... n &#123; sum += i &#125; return sum&#125;sumOpration1(100)//5050func sumOpration2(_ n:Int) -&gt; Int&#123; return (1 + n) * n/2&#125;sumOpration2(100)//5050 上面的代码中，sumOpration1使用的是循环遍历的方式；sumOpration2使用的是等差数列求和的公式。 虽然两个函数都能得到正确的结果，但是不难看出两个函数实现的效率是有区别的: 遍历求和所需要的时间是依赖于传入函数的n的大小的，而等差数列求和的方法所需要的时间对传入的n的大小是完全不依赖的。 在遍历求和中，如果传入的n值是100，则需要遍历100次并相加才能得到结果，那么如果传入的n值是一百万呢？ 而在等差数列求和的函数中，无论n值有多大，只需要一个公式就可以解决。 我们对此可以以小见大：世上千千万万种问题（算法题）可能也有类似的情况：相同的问题，相同的结果，但是执行效率缺差之千里。那么有没有什么方法可以度量某种算法的执行效率以方便人们去选择或是衡量算法之间的差异呢？ 答案是肯定的。 下面笔者就向大家介绍算法所消耗资源的两个维度：时间复杂度和空间复杂度。 时间复杂度与空间复杂度时间复杂度算法的时间复杂度是指算法需要消耗的时间资源。一般来说，计算机算法是问题规模!n的函数f(n)，算法的时间复杂度也因此记做： 常见的时间复杂度有：常数阶O(1)，对数阶O(log n），线性阶 O(n)，线性对数阶O(nlog n)，平方阶O(n^{2})，立方阶O(n^{3})，!k次方阶O(n^{k})，指数阶 O(2^{n})}。随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。 拿其中几个复杂度做对比： 从上图中我们可以看到，平方阶O(n^{2})随着n值的增大，其复杂度近乎直线飙升；而线性阶 O(n)随着n的增大，复杂度是线性增长的；我们还可以看到常数阶 O(1)随着n增大，其复杂度是不变的。 参考上一节的求和问题，我们可以看出来遍历求和的算法复杂度是线性阶O(n)：随着求和的最大数值的大小而线性增长；而等差数列求和算法的复杂度为常数阶 O(1)其算法复杂度与输入n值的大小无关。 读者可以试着想一个算法的复杂度与输入值n的平方成正比的算法。 在这里笔者举一个例子：求一个数组中某两个元素和为某个值的元素index的算法。数组为[0,2,1,3,6]，和为8： 12345678910111213141516171819202122232425func findTwoSum(_ array: [Int], target: Int) -&gt; (Int, Int)? &#123; guard array.count &gt; 1 else &#123; return nil &#125; for i in 0..&lt;array.count &#123; let left = array[i] for j in (i + 1)..&lt;array.count &#123; let right = array[j] if left + right == target &#123; return (i, j) &#125; &#125; &#125; return nil&#125;let array = [0,2,1,3,6]if let indexes = findTwoSum(array, target: 8) &#123; print(indexes) //1， 4&#125; else &#123; print(&quot;No pairs are found&quot;)&#125; 上面的算法准确地计算出了两个元素的index为1和4。因为使用了两层的遍历，所以这里算法的复杂度是平方阶O(n^{2}。关于算法复杂度的详细推倒方法，可以参考网上和算法相关书籍的资料。 而其实，不需要遍历两层，只需要遍历一层即可：在遍历的时候，我么知道当前元素的值a，那么只要其余元素里面有值等于（target - a）的值即可。所以这次算法的复杂度就是线性阶O(n)了。 同样地，上面两种算法虽然可以达到相同的效果，但是当n非常大的时候，二者的计算效率就会相差更大：n = 1000的时候，二者得到结果所需要的时间可能会差好几百倍。可以说平方阶O(n^{2})复杂度的算法在数据量很大的时候是无法让人接受的。 空间复杂度算法的空间复杂度是指算法需要消耗的空间资源。其计算和表示方法与时间复杂度类似，一般都用复杂度的渐近性来表示。同时间复杂度相比，空间复杂度的分析要简单得多。而且控件复杂度不属于本文讨论的重点，因此在这里不展开介绍了。 递归在算法的实现中，遍历与递归是经常出现的两种操作。 对于遍历，无非就是使用一个for循环来遍历集合里的元素，相信大家已经非常熟悉了。但是对于递归操作就可能比较陌生。而且由于本文第二部分讲解算法的是时候有两个算法（也是比较重要）的算法使用了递归操作，所以为了能帮助大家理解这两个算法，笔者觉得有必要将递归单独拿出来讲解。 先看一下递归的概念。 递归的概念递归的概念是：在数学与计算机科学中，是指在函数的定义中使用函数自身的方法摘自维基百科 摘自维基百科 通过使用递归，可以把一个大型复杂的问题逐层转化为一个与原问题相似的规模较小的问题来求解。因此如果使用递归，可以达到使用少量的代码就可描述出解题过程所需的多次重复计算的目的，减少了程序的代码量 。 下面用一个例子来具体感受一下递归操作： 大家应该都比较熟悉阶乘的算法：3！= 3 2 1 ； 4！= 4 3 2 * 1 不难看出，在这里反复执行了一个逐渐-1和相乘的操作，如果可以使用某段代码达到重复调用的效果就很方便了，在这里就可以使用递归： 1234func factorial(_ n:Int) -&gt; Int&#123; return n &lt; 2 ? 1: n * factorial(n-1)&#125;factorial(3) //6 在上面的代码里，factorial函数调用了它自己，并且在n&lt;2的时候返回了1；否则继续调用自己。 从代码本身其实不难理解函数调用的方式，但是这个6究竟是怎么算出来的呢？这就涉及到递归的实现原理了。 递归的实现原理递归的调用实际上是通过调用栈（callback stack）来实现的，笔者用一张图从factorial(3)开始调用到最后得出6这个顺序之间发生的事情画了出来： 由上图可以看出，整个递归的过程和栈的入栈出栈的操作非常类似：橘黄色背景的圆角矩形代表了栈顶元素，也就是正在执行的操作，而灰色背景的圆角矩形则代表了其余的元素，它们的顺序就是当初被调用的顺序，而且在内容上保持了当时被调用时执行的代码。 现在笔者按照时间顺序从左到右来说明一下整个调用的过程： 最开始传入3之后，3满足了n&gt;=2的条件，继续调用自己：3 * factorial(2) ，入栈。 传入2之后，2满足了n&gt;=2的条件，继续调用自己：2 * factorial(1) ，入栈。 传入1之后，1满足了n&lt;2的条件，停止调用自己，返回了1，出栈。 此时的栈顶元素为2 factorial(1) ，而刚刚factorial(1)返回了1，所以现在这里变成了2 1 = 2，出栈。 同样地，此时栈顶元素为3 factorial(2)里的 factorial(2)返回了2，所以现在这里变成了3 2 = 6，出栈。 最后，factorial(3)返回了6，出栈，递归结束。 按照笔者个人的理解：整个递归的过程可以大致理解为：在使递归继续的条件为false之前，持续递归调用，以栈的形式保存调用上下文（临时变量，函数等）。一旦这个条件变为true，则立即按照出栈的顺序（入栈顺序的逆序）来返回值，逐个传递，最终传递到最开始调用的那一层返回最终结果。 再简单点，递归中的“递”就是入栈，传递调用信息；“归”就是出栈，输出返回值。 而这个分界线就是递归的终止条件。很显然，这个终止条件在整个递归过程中起着举足轻重的作用。试想一下，如果这个条件永远不会改变，那么就会一直入栈，就会发生栈溢出的情况。 使用递归时需要注意的问题基于上面递归的例子，我们将递归终止条件去掉： 1234func factorialInfinite(_ n:Int) -&gt; Int&#123; return n * factorialInfinite(n-1)&#125;factorialInfinite(3) 这段代码如果放在playground里，经过一小段时间（几秒钟或更多）后，会报一个运行时错误。也可以在return语句上面写一个print函数打印一些字符串，接着就会看到不停的打印，直到运行时错误，栈溢出。 所以说在今后写关于递归的代码的时候，一定要注意递归的终止条件是否合理，因为即使条件存在也不一定就是合理的条件。我们看一下下面这个例子： 1234567func sumOperation( _ n:Int) -&gt; Int &#123; if n == 0 &#123; return 0 &#125; return n + sumOperation(n - 1)&#125;sumOperation(2) //3 上面的代码跟阶乘类似，也是和小于当前参数的值相加，如果传入2，那么知道 n=0时就开始出栈， 2 + 1 + 0 = 3。看似没什么问题，但是如果一开始传入 - 1 呢？结果就是不停的入栈，直到栈溢出。因为 n == 0 这个条件在传入 - 1 的时候是无法终止入栈的，因为 - 1 之后的 -1 操作都是非0的。 所以说这个条件就不是合理的，一个比较合理的条件是 n &lt; = 0。 1234567func sumOperation( _ n:Int) -&gt; Int &#123; if n &lt;= 0 &#123; return 0 &#125; return n + sumOperation(n - 1)&#125;sumOperation(-1) //0 相信到这里，读者应该对递归的使用，调用过程以及注意事项有个基本的认识了。 那么到这里，关于算法的基本介绍已经讲完了，下面正式开始讲解排序算法。 排序算法讲解算法之前，我们先来看一下几个常见的排序算法的对比： 排序算法 平均情况下 最好情况 最坏情况 稳定性 空间复杂度 冒泡 O(n^2) O(n） O(n^2) 稳定 1 选择排序 O(n^2) O(n^2) O(n^2) 不稳定 1 插入排序 O(n^2) O(n） O(n^2) 稳定 1 希尔排序 O(nlogn) 依赖步长 依赖步长 稳定 1 堆排序 O(nlogn) O(nlogn) O(nlogn) 稳定 1 归并排序 O(nlogn) O(nlogn) O(nlogn) 稳定 O(n） 快速排序 O(nlogn) O(nlogn) O(n^2) 不稳定 O(logn) 最好情况和最坏情况以及稳定性的概念不在本文的讨论范围之内，有兴趣的读者可以查阅相关资料。 现在只看平均情况下的性能： 冒泡排序，选择排序，插入排序的时间复杂度为平方阶O(n^{2}) 希尔排序，堆排序，归并排序，快速排序的时间复杂度为线性对数阶O(nlog n) 本篇要给大家介绍的是冒泡排序，选择排序，插入排序，归并排序和快速排序。 希尔排序是基于插入排序，理解了插入排序以后，理解希尔排序会很容易，故在本文不做介绍。堆排序涉及到一个全新的数据结构：堆，所以笔者将堆这个数据结构和堆排序放在下一篇来做介绍。 排序初探在讲排序算法之前，我们先看一种最简单的排序算法（也是性能最低的，也是最好理解的），在这里先称之为“交换排序”。 注意，这个名称是笔者自己起的，在互联网和相关技术书籍上面没有对该算法起名。 算法讲解用两个循环来嵌套遍历： 外层遍历数组从0到末尾的元素，索引为i. 里层遍历数组从i+1至数组末尾的元素，索引为j。 当i上的元素比j上的元素大的时候，交换i和j的元素，目的是保持index为i的元素是最小的。 我们用一个例子看一下是怎么做交换的： 给定一个初始数组：array = [4, 1, 2, 5, 0] i = 0 时： array[0] &gt; array[1] : 交换4和1：[1, 4, 2, 5, 0]，内层的j继续遍历，j++。 array[0] &gt; array[4] : 交换0和1：[0, 4, 2, 5, 1]，i = 0的外层循环结束，i++。 i = 1时： array[1] &gt; array[2] : 交换2和4：[0, 2, 4, 5, 1]，内层的j继续遍历，j++。 array[1] &gt; array[4] : 交换1和2：[0, 1, 4, 5, 2]，i = 1的外层循环结束，i++。 i = 2 时： array[2] &gt; array[4] : 交换2和4：[0, 1, 2, 5, 4]，i = 2的外层循环结束，i++。 i = 3 时： array[3] &gt; array[4] : 交换5和4：[0, 1, 2, 4, 5]，i = 3的外层循环结束，i++。 i = 4 时： 不符合内循环的边界条件，不进行内循环，排序结束。 那么用代码如何实现呢？ 代码实现1234567891011121314151617func switchSort(_ array: inout [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; for i in 0 ..&lt; array.count &#123; for j in i + 1 ..&lt; array.count &#123; if array[i] &gt; array[j] &#123; array.swapAt(i, j) print(&quot;\(array)&quot;) &#125; &#125; &#125; return array &#125; 这里面swapAt函数是使用了Swift内置的数组内部交换两个index的函数，在后面会经常用到。 为了用代码验证上面所讲解的交换过程，可以在swapAt函数下面将交换元素后的数组打印出来： 1234567891011121314151617181920var originalArray = [4,1,2,5,0]print(&quot;original array:\n\(originalArray)\n&quot;)func switchSort(_ array: inout [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; for i in 0 ..&lt; array.count &#123; for j in i + 1 ..&lt; array.count &#123; if array[i] &gt; array[j] &#123; array.swapAt(i, j) print(&quot;\(array)&quot;) &#125; &#125; &#125; return array &#125;switchSort(&amp;originalArray) 打印结果： 12345678910original array:[4, 1, 2, 5, 0]switch sort...[1, 4, 2, 5, 0][0, 4, 2, 5, 1][0, 2, 4, 5, 1][0, 1, 4, 5, 2][0, 1, 2, 5, 4][0, 1, 2, 4, 5] 验证后我们可以看到，结果和上面分析的结果是一样的。 各位读者也可以自己设置原数组，然后在运行代码之前按照自己的理解，把每一次交换的结果写出来，接着和运行算法之后进行对比。该方法对算法的理解很有帮助，推荐大家使用~ 请务必理解好上面的逻辑，可以通过动笔写结果的方式来帮助理解和巩固，有助于对下面讲解的排序算法的理解。 大家看上面的交换过程（排序过程）有没有什么问题？相信细致的读者已经看出来了：在原数组中，1和2都是比较靠前的位置，但是经过中间的排序以后，被放在了数组后方，然后再次又交换回来。这显然是比较低效的，给人的感觉像是做了无用功。 那么有没有什么方法可以优化一下交换的过程，让交换后的结果与元素最终在数组的位置基本保持一致呢？ 答案是肯定的，这就引出了笔者要第一个正式介绍的排序算法冒泡排序： 冒泡排序算法讲解与上面讲的交换排序类似的是，冒泡排序也是用两层的循环来实现的；但与其不同的是： 循环的边界条件：冒泡排序的外层是[0,array.count-1);内层是[0,array.count-1-i)。可以看到内层的范围是不断缩小的，而且范围的前端不变，后端在向前移。 交换排序比较的是内外层索引的元素（array[i] 和 array[j]）,但是冒泡排序比较的是两个相邻的内层索引的元素：array[j]和array[j+1]。 笔者用和上面交换排序使用的同一个数组来演示下元素是如何交换的： 初始数组：array = [4, 1, 2, 5, 0] i = 0 时： array[0] &gt; array[1] : 交换4和1：[1, 4, 2, 5, 0]，内层的j继续遍历，j++。 array[1] &gt; array[2] : 交换4和2：[1, 2, 4, 5, 0]，内层的j继续遍历，j++。 array[2] &lt; array[3] : 不交换，内层的j继续遍历，j++。 array[3] &gt; array[4] : 交换5和0：[1, 2, 4, 0, 5]，i = 0的外层循环结束，i++。 i = 1时： array[2] &gt; array[3] : 交换2和4：[1, 2, 0, 4, 5]，内层的j继续遍历，j++。 array[3] &lt; array[4] : 不交换，i = 1的外层循环结束，i++。 i = 2 时： array[1] &gt; array[2] : 交换2和0：[1, 0, 2, 4, 5]，内层的j继续遍历，j++，直到退出i=2的外层循环，i++。 i = 3 时： array[0] &gt; array[1] : 交换1和0：[0, 1, 2, 4, 5]，内层的j继续遍历，j++，直到退出i=3的外层循环，i++。 i = 4 时：不符合外层循环的边界条件，不进行外层循环，排序结束。 代码实现我们来看一下冒泡排序的代码： 1234567891011121314func bubbleSort(_ array: inout [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; for i in 0 ..&lt; array.count - 1 &#123; for j in 0 ..&lt; array.count - 1 - i &#123; if array[j] &gt; array[j+1] &#123; array.swapAt(j, j+1) &#125; &#125; &#125; return array&#125; 从上面的代码我们可以清楚地看到循环遍历的边界条件和交换时机。同样地，我们添加上log，将冒泡排序每次交换后的数组打印出来（为了进行对比，笔者将交换排序的log也打印了出来）： 123456789101112131415161718original array:[4, 1, 2, 5, 0]switch sort...[1, 4, 2, 5, 0][0, 4, 2, 5, 1][0, 2, 4, 5, 1][0, 1, 4, 5, 2][0, 1, 2, 5, 4][0, 1, 2, 4, 5]bubble sort...[1, 4, 2, 5, 0][1, 2, 4, 5, 0][1, 2, 4, 0, 5][1, 2, 0, 4, 5][1, 0, 2, 4, 5][0, 1, 2, 4, 5] 从上面两组打印可以看出，冒泡排序算法解决了交换排序算法的不足： 原来就处于靠前位置的1，2两个元素，在排序的过程中一直是靠前的。 原来处于末尾的0元素，在冒泡排序的过程中一点一点地向前移动，最终到了应该处于的位置。 现在我们知道冒泡排序是好于交换排序的，而且它的做法是相邻元素的两两比较：如果是逆序（左大右小）的话就做交换。 那么如果在排序过程中，数组已经变成有序的了，那么再进行两两比较就很不划算了。 为了证实上面这个排序算法的局限性，我们用新的测试用例来看一下： 1var originalArray = [2,1,3,4,5] 而且这次我们不仅仅在交换以后打log，也记录一下作比较的次数： 12345678910111213141516171819func bubbleSort(_ array: inout [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; var compareCount = 0 for i in 0 ..&lt; array.count - 1 &#123; for j in 0 ..&lt; array.count - 1 - i &#123; compareCount += 1 print(&quot;No.\(compareCount) compare \(array[j]) and \(array[j+1])&quot;) if array[j] &gt; array[j+1] &#123; array.swapAt(j, j+1) //keeping index of j is the smaller one print(&quot;after swap: \(array)&quot;) &#125; &#125; &#125; return array&#125; 打印结果： 123456789101112131415original array:[2, 1, 3, 4, 5]bubble sort...No.1 compare 2 and 1after swap: [1, 2, 3, 4, 5] //already sorted, but keep comparingNo.2 compare 2 and 3No.3 compare 3 and 4No.4 compare 4 and 5No.5 compare 1 and 2No.6 compare 2 and 3No.7 compare 3 and 4No.8 compare 1 and 2No.9 compare 2 and 3No.10 compare 1 and 2 从打印的结果可以看出，其实在第一次交换过之后，数组已经是有序的了，但是该算法还是继续在比较，做了很多无用功，能不能有个办法可以让这种两两比较在已知有序的情况下提前结束呢？答案是肯定的。 提前结束这个操作很容易，我们只需要跳出最外层的循环就好了。关键是这个时机：我们需要让算法自己知道什么时候数组已经是有序的了。 是否已经想到了呢？就是在一次内循环过后，如果没有发生元素交换，就说明数组已经是有序的，不需要再次缩小内循环的范围继续比较了。所以我们需要在外部设置一个布尔值的变量来标记“该数组是否有序”： 我们将这个算法称为：advanced bubble sort 12345678910111213141516171819202122232425func bubbleSortAdvanced(_ array: inout [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; for i in 0 ..&lt; array.count - 1 &#123; //bool switch var swapped = false for j in 0 ..&lt; array.count - i - 1 &#123; if array[j] &gt; array [j+1] &#123; array.swapAt(j, j+1) swapped = true; &#125; &#125; //if there is no swapping in inner loop, it means the the part looped is already sorted, //so it&apos;s time to break if (swapped == false)&#123; break &#125; &#125; return array &#125; 从上面的代码可以看出，在第一个冒泡排序的算法之内，只添加了一个swapped这个布尔值，默认为false： 如果在当前内循环里面没有发生过元素交换，则说明当前内循环范围的元素都是有序的；那么就说明后续的内循环范围的元素也是有序的（因为内循环每次迭代后都会缩小），就可以跳出循环了。 反之，如果在当前内循环里发生过元素交换，则说明当前内循环很可能是无序的（也可能是有序的，但是有序性需要在下一个内循环中验证，所以还是不能提前退出，还需要进行一次内循环）。 为了验证上面这个改进冒泡排序是否能解决最初给出的冒泡排序的问题，我们添加上对比次数的log： 1234567891011121314151617181920212223242526original array:[2, 1, 3, 4, 5]bubble sort...No.1 compare 2 and 1after swap: [1, 2, 3, 4, 5]No.2 compare 2 and 3No.3 compare 3 and 4No.4 compare 4 and 5No.5 compare 1 and 2No.6 compare 2 and 3No.7 compare 3 and 4No.8 compare 1 and 2No.9 compare 2 and 3No.10 compare 1 and 2bubble sort time duration : 1.96msadvanced bubble sort...No.1 compare 2 and 1after swap: [1, 2, 3, 4, 5]No.2 compare 2 and 3No.3 compare 3 and 4No.4 compare 4 and 5No.5 compare 1 and 2No.6 compare 2 and 3No.7 compare 3 and 4 我们可以看到，在使用改进的冒泡排序后，对比的次数少了3次。之所以没有立即返回，是因为即使在交换完变成有序数组以后，也无法在当前内循环判断出是有序的。需要在下次内循环才能验证出来。 因为数组的元素数量比较小，所以可能对这个改进所达到的效果体会得不是很明显。现在我们增加一下数组元素的个数，并用记录比较总和的方式来看一下二者的区别： 12345678original array:[2, 1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]bubble sort...total compare count： 91advanced bubble sort...total compare count： 25 从比较结果可以看出，这两种算法在该测试样本下的差距是比较大的，而且随着元素个数的增多这个差距会越来越大（因为做了更多没有意义的比较）。 虽然这种测试样本比较极端，但是在某种意义上还是优化了最初的冒泡排序算法。一般在网上的冒泡排序算法应该都能看到这个优化版的。 现在我们知道这个优化版的冒泡排序算法可以在知道当前数组已经有序的时候提前结束，但是毕竟不断的交换还是比较耗费性能的，有没有什么方法可以只移动一次就能做好当前元素的排序呢？答案又是肯定的，这就引出了笔者即将介绍的选择排序算法。 选择排序算法讲解选择排序也是两层循环： 外层循环的边界是[0,array.count-1)，index为i。 内层循环的边界是[i+1,array.count)，index为j。可以看到内层的范围也是不断缩小的，而且范围的前端一直后移，后端保持不变。 具体做法是： 在外层循环的开始，将i作为最小值index（很可能不是该数组的最小值）。 在内层循环里面找到当前内层循环范围内的最小值，并与已经记录的最小值作比较： 如果与当前记录的最小值index不同，则替换 如果与当前记录的最小值index相同，则不替换 我们还是用手写迭代的方式看一下选择排序的机制，使用的数组和上面交换排序和冒泡排序（非优化版）的数组一致：[4, 1, 2, 5, 0] i = 0 时： 记录当前的最小值的index为0，当前最小值为4。 内层循环开始，找到[1,5)之间的最小值为0，0的index为4，与当前最小值的index0不同，所以二者要做交换。交换后的数组：[0, 1, 2, 5, 4]。当前内层循环结束，i++。 i = 1 时： 记录当前的最小值的index为1，当前最小值为1。 内层循环开始，找到[2,5)之间的最小值为1，与当前记录的最小值index相同。也就是说后面没有比1还要小的了，不做交换。当前内层循环结束，i++。 i = 2 时： 记录当前的最小值的index为2，当前最小值为2。 内层循环开始，找到[3,5)之间的最小值为2，与当前记录的最小值index相同。也就是说后面没有比1还要小的了，不做交换。当前内层循环结束，i++。 i = 3 时： 记录当前的最小值的index为3，当前最小值为2。 内层循环开始，找到[4,5)之间的最小值为4，4的index为4，与当前记录的最小值index3不同，所以二者要做交换。交换后的数组：[0, 1, 2, 4, 5]。当前内层循环结束，i++。 i = 4 时：不符合外层循环的边界条件，不进行外层循环，排序结束。 我们可以看到，同样的初始序列，使用选择排序只进行了2次交换，因为它知道需要替换的最小值是什么，做了很少没意义的交换。 代码实现我们用代码来实现一下上面选择排序的算法： 12345678910111213141516171819202122func selectionSort(_ array: inout [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; for i in 0 ..&lt; array.count - 1&#123; var min = i for j in i + 1 ..&lt; array.count &#123; if array[j] &lt; array[min] &#123; min = j &#125; &#125; //if min has changed, it means there is value smaller than array[min] //if min has not changed, it means there is no value smallter than array[min] if i != min &#123; array.swapAt(i, min) &#125; &#125; return array&#125; 从上面的代码可以看到，在这里使用了min这个变量记录了当前外层循环所需要被比较的index值，如果当前外层循环的内层循环内部找到了比这个最小值还小的值，就替换他们。 下面我们使用log来看一下此时选择排序作替换的次数： 123456789101112original array:[4, 1, 2, 5, 0]advanced bubble sort...after swap: [1, 4, 2, 5, 0]after swap: [1, 2, 4, 5, 0]after swap: [1, 2, 4, 0, 5]after swap: [1, 2, 0, 4, 5]after swap: [1, 0, 2, 4, 5]after swap: [0, 1, 2, 4, 5]selection sort...after swap: [0, 1, 2, 5, 4]after swap: [0, 1, 2, 4, 5] 从上面的log可以看出二者的对比应该比较明显了。 为了进一步验证选择排序的性能，笔者在网上找到了两个工具： 计算程序运行时间的类：executionTimeInterval.swift 生成各种类型随机数的Array的分类：Array+Extension.swift 首先看executionTimeInterval.swift的实现： 123456789101112131415161718//time intervalpublic func executionTimeInterval(block: () -&gt; ()) -&gt; CFTimeInterval &#123; let start = CACurrentMediaTime() block(); let end = CACurrentMediaTime() return end - start&#125;//formatted timepublic extension CFTimeInterval &#123; public var formattedTime: String &#123; return self &gt;= 1000 ? String(Int(self)) + &quot;s&quot; : self &gt;= 1 ? String(format: &quot;%.3gs&quot;, self) : self &gt;= 1e-3 ? String(format: &quot;%.3gms&quot;, self * 1e3) : self &gt;= 1e-6 ? String(format: &quot;%.3gµs&quot;, self * 1e6) : self &lt; 1e-9 ? &quot;0s&quot; : String(format: &quot;%.3gns&quot;, self * 1e9) &#125;&#125; 第一个函数以block的形式传入需要测试运行时间的函数，返回了函数运行的时间。 第二个函数是CFTimeInterval的分类，将秒数添加了单位：毫秒级的以毫秒显示，微秒级的以微秒显示，大于1秒的以秒单位显示。 使用方法是：将两个swift文件拖进playground里面的Sources文件夹里，并点击二者后，进入playground内部： 12345var selectionSortedArray = [Int]()var time4 = executionTimeInterval&#123; selectionSortedArray = selectionSort(&amp;originalArray4) //要测试的函数&#125;print(&quot;selection sort time duration : \(time4.formattedTime)&quot;) //打印出时间 再来看一下Array+Extension.swift类： 先介绍其中的一个方法，生成随机数组： 12345678910111213import Foundationextension Array &#123; static public func randomArray(size: Int, maxValue: UInt) -&gt; [Int] &#123; var result = [Int](repeating: 0, count:size) for i in 0 ..&lt; size &#123; result[i] = Int(arc4random_uniform(UInt32(maxValue))) &#125; return result &#125;&#125; 这个方法只需要传入数组的大小以及最大值就可以生成一个不超过这个最大值的随机数组。 比如我们要生成一个数组长度为10，最大值为100的数组： 12var originalArray = Array&lt;Int&gt;.randomArray(size: inputSize, maxValue:100)//originalArray:[87, 56, 54, 20, 86, 33, 41, 9, 88, 55] 那么现在有了上面两个工具，我们就可以按照我们自己的意愿来生成测试用例数组，并且打印出所用算法的执行时间。我们现在生成一个数组长度为10，最大值为100的数组，然后分别用优化的冒泡排序和选择排序来看一下二者的性能： 12345678original array:[1, 4, 80, 83, 92, 63, 83, 23, 9, 85]advanced bubble sort...advanced bubble sort result: [1, 4, 9, 23, 63, 80, 83, 83, 85, 92] time duration : 8.53msselection sort...selection sort result: [1, 4, 9, 23, 63, 80, 83, 83, 85, 92] time duration : 3.4ms 我们现在让数组长度更长一点:一个长度为100，最大值为200： 12345advanced bubble sort...advanced bubble sort sorted elemets: 100 time duration : 6.27sselection sort...selection sort sorted elemets: 100 time duration : 414ms 可以看到，二者的差别大概在12倍左右。这个差别已经很大了，如果说用选择排序需要1天的话，冒泡排序需要12天。 现在我们学习了选择排序，知道了它是通过减少交换次数来提高排序算法的性能的。 但是关于排序，除了交换操作以外，对比操作也是需要时间的：选择排序通过内层循环的不断对比才得到了当前内层循环的最小值，然后进行后续的判断和操作。 那么有什么办法可以减少对比的次数呢？猜对了，答案又是肯定的。这就引出了笔者下面要说的算法：插入排序算法。 插入排序算法讲解插入排序的基本思想是：从数组中拿出一个元素（通常就是第一个元素）以后，再从数组中按顺序拿出其他元素。如果拿出来的这个元素比这个元素小，就放在这个元素左侧；反之，则放在右侧。整体上看来有点和玩儿扑克牌的时候将刚拿好的牌来做排序差不多。 选择排序也是两层循环：外层循环的边界是[1,array.count)，index为i。内层循环开始的时候初始index j = i，然后使用一个while循环，循环条件是j&gt;0 &amp;&amp; array[j] &lt; array[j - 1],循环内侧是交换j-1和j的元素，并使得j-1。可以简单理解为如果当前的元素比前一个元素小，则调换位置；反之进行下一个外层循环。 下面我们还是用手写迭代的方式看一下插入排序的机制，使用的数组和上面选择排序的数组一致：[4, 1, 2, 5, 0] i = 1 时： j = 1：array[1] &lt; array[0]， 交换4和1：[1, 4, 2, 5, 0]，j-1之后不符合内层循环条件，退出内层循环，i+1。 i = 2 时： j = 2，array[3] &lt; array[2]，交换4和2：[1, 2, 4, 5, 0]，j向左移动，array[2] &gt; array[1]，不符合内层循环条件，退出内层循环，i+1。 i = 3 时： j = 3，array[3] &gt; array[2]，不符合内层循环条件，退出内层循环，i+1。 i = 4 时： j = 4，array[4] &lt; array[3]，交换5和0：[1, 2, 4, 0, 5]，j -1。 j = 3，array[3] &lt; array[2]，交换4和0：[1, 2, 0, 4, 5]，j -1。 j = 2，array[2] &lt; array[1]，交换4和0：[1, 0, 2, 4, 5]，j -1。 j = 1，array[1] &lt; array[0]，交换1和0：[0, 1, 2, 4, 5]，j -1 = 0，不符合内层循环条件，退出内层循环，i+1 = 5，不符合外层循环条件，排序终止。 从上面的描述可以看出，和选择排序相比，插入排序的内层循环是可以提前推出的，其条件就是array[j] &gt;= array[j - 1],也就是说，当前index为j的元素只要比前面的元素大，那么该内层循环就立即退出，不需要再排序了，因为该算法从一开始就是小的放前面，大的放后面。 代码实现下面我们通过代码来看一下如何实现插入排序算法: 1234567891011121314func insertionSort(_ array: inout [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; for i in 1..&lt;array.count &#123; var j = i while j &gt; 0 &amp;&amp; array[j] &lt; array[j - 1] &#123; array.swapAt(j - 1, j) j -= 1 &#125; &#125; return array&#125; 从上面的代码可以看出插入排序内层循环的条件：j &gt; 0 &amp;&amp; array[j] &lt; array[j - 1]。只要当前元素比前面的元素小，就会一直交换下去；反之，当大于等于前面的元素，就会立即跳出循环。 之前笔者有提到相对于选择排序，说插入排序可以减少元素之间对比的次数，下面我们通过打印对比次数来对比一下两种算法： 使用元素个数为50，最大值为50的随机数组： 1234567selection sort...compare times:1225selection sort time duration : 178msinsertion sort...compare times:519insertion sort time duration : 676ms 我们可以看到，使用选择排序的比较次数比插入排序的比较次数多了2倍。但是遗憾的是整体的性能选择排序要高于插入排序。 也就是说虽然插入排序的比较次数少了，但是交换的次数却比选择排序要多，所以性能上有时可能不如选择排序。 注意，这不与笔者之前的意思相矛盾，笔者只是说在减少比较次数上插入排序是优于选择排序的，但没有说插入排序整体上优于选择排序。 那么有何种特性的数组可以让排序算法有其用武之地呢？ 从上面使用插入排序来排序[4, 1, 2, 5, 0]这个数组的时候，我们可以看到，因为0这个元素已经在末尾了，所以在j=4的时候我们费了好大劲才把它移到前面去。 那么将这个情况作为一个极端，我们可以这样想：如果这个数组里的元素里的index大致于最终顺序差不多的情况是不是就不用做这么多的搬移了？。这句话听起来像是理所当然的话，但是有一种数组属于“基本有序”的数组，这种数组也是无需的，但是它在整体上是有序的，比如： [2,1,3,6,4,5,9,7,8] 用笔者的话就叫做整体有序，部分无序。 我们可以简单用这个数组来分别进行选择排序和插入排序做个比较： 1234567selection sort...compare times:36selection sort time duration : 4.7msinsertion sort...compare times:5insertion sort time duration : 3.2ms 我们可以看到插入排序在基本有序的测试用例下表现更好。为了让差距更明显，笔者在Array+Extension.swift文件里增加了一个生成基本有序随机数组的方法： 12345678910111213141516static public func nearlySortedArray(size: Int, gap:Int) -&gt; [Int] &#123; var result = [Int](repeating: 0, count:size) for i in 0 ..&lt; size &#123; result[i] = i &#125; let count : Int = size / gap var arr = [Int]() for i in 0 ..&lt; count &#123; arr.append(i*gap) &#125; for j in 0 ..&lt; arr.count &#123; let swapIndex = arr[j] result.swapAt(swapIndex,swapIndex+1) &#125; return result&#125; 该函数需要传入数组的长度以及需要打乱顺序的index的跨度，它的实现是这样子的： 首先生成一个完全有序的序列。 将数组长度除以跨度来得出需要交换的index的个数count。 根据这个count可以得出需要交换的index，把这些index放在一个新的arr里面 便利这个arr来取出index，将之前生成好的w安全有序的数组的index于index+1做交换。 举个例子，如果我们生成一个数组长度为12，跨度为3的基本有序的数组，就可以这么调用： 12var originalArray = Array&lt;Int&gt;.nearlySortedArray(size: 12, gap: 3)//[1, 0, 2, 4, 3, 5, 7, 6, 8, 10, 9, 11] 跨度为3，说明有12/3 = 4 - 1 = 3 个元素需要调换位置，序号分别为0，3，6，9。所以序号为0，1；3，4；6，7；9，10的元素被调换了位置，可以看到调换后的数组还是基本有序的。 现在我们可以用一个比较大的数组来验证了： 1var originalArray = Array&lt;Int&gt;.nearlySortedArray(size: 100, gap: 10) 结果为： 1234567selection sort...compare times:4950selection sort time duration : 422msinsertion sort...compare times:10insertion sort time duration : 56.4ms 我们可以看到差距是非常明显的，插入排序的性能是选择排序的性能的近乎10倍 归并排序算法讲解归并排序使用了算法思想里的分治思想（divide conquer）。顾名思义，就是将一个大问题，分成类似的小问题来逐个攻破。在归并排序的算法实现上，首先逐步将要排序的数组等分成最小的组成部分（通常是1各元素），然后再反过来逐步合并。 用一张图来体会一下归并算法的实现过程： 上图面的虚线箭头代表拆分的过程；实线代表合并的过程。仔细看可以发现，拆分和归并的操作都是重复进行的，在这里面我们可以使用递归来操作。 首先看一下归并的操作： 归并的操作就是把两个数组（在这里这两个数组的元素个数通常是一致的）合并成一个完全有序数组。 归并操作的实现步骤是： 新建一个空数组，该数组用于存放合并后的有序数组。 两个传入的数组从index 0 开始两两比较，较小的元素放在新建的空数组中，index + 1; 较大的元素不作操作，index 不变，然后继续两两比较。知道index移到末尾为止。 个别情况当两个数组长度不一致的情况下需要将数组里剩余的元素放在新建的数组中。 代码实现我们来看一下归并排序算法的代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445func _merge(leftPile: [Int], rightPile: [Int]) -&gt; [Int] &#123; var leftIndex = 0 //left pile index, start from 0 var rightIndex = 0 //right pile index, start from 0 var sortedPile = [Int]() //sorted pile, empty in the first place while leftIndex &lt; leftPile.count &amp;&amp; rightIndex &lt; rightPile.count &#123; //append the smaller value into sortedPile if leftPile[leftIndex] &lt; rightPile[rightIndex] &#123; sortedPile.append(leftPile[leftIndex]) leftIndex += 1 &#125; else if leftPile[leftIndex] &gt; rightPile[rightIndex] &#123; sortedPile.append(rightPile[rightIndex]) rightIndex += 1 &#125; else &#123; //same value, append both of them and move the corresponding index sortedPile.append(leftPile[leftIndex]) leftIndex += 1 sortedPile.append(rightPile[rightIndex]) rightIndex += 1 &#125; &#125; //left pile is not empty while leftIndex &lt; leftPile.count &#123; sortedPile.append(leftPile[leftIndex]) leftIndex += 1 &#125; //right pile is not empty while rightIndex &lt; rightPile.count &#123; sortedPile.append(rightPile[rightIndex]) rightIndex += 1 &#125; return sortedPile&#125; 因为该函数是归并排序函数内部调用的函数，所以在函数名称的前面添加了下划线。仅仅是为了区分，并不是必须的。 从上面代码可以看出合并的实现逻辑： 新建空数组，初始化两个传入数组的index为0 两两比较两个数组index上的值，较小的放在新建数组里面并且index+1。 最后检查是否有剩余元素，如果有则添加到新建数组里面。 理解了合并的算法，下面我们看一下拆分的算法。拆分算法使用了递归： 123456789func mergeSort(_ array: [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; let middleIndex = array.count / 2 let leftArray = mergeSort(Array(array[0..&lt;middleIndex])) // recursively split left part of original array let rightArray = mergeSort(Array(array[middleIndex..&lt;array.count])) // recursively split right part of original array return _merge(leftPile: leftArray, rightPile: rightArray) // merge left part and right part&#125; 我们可以看到mergeSort调用了自身，它的递归终止条件是!(array.count &gt;1)，也就是说当数组元素个数 = 1的时候就会返回，会触发调用栈的出栈。 从这个递归函数的实现可以看到它的作用是不断以中心店拆分传入的数组。根据他的递归终止条件，当数组元素 &gt; 1的时候，拆分会继续进行。而下面的合并函数只有在递归终止，开始出栈的时候才开始真正执行。也就是说在拆分结束后才开始进行合并，这样符合了上面笔者介绍的归并算法的实现过程。 上段文字需要反复体会。 为了更形象体现出归并排序的实现过程，可以在合并函数(_merge)内部添加log来验证上面的说法： 123456789func _merge(leftPile: [Int], rightPile: [Int]) -&gt; [Int] &#123; print(&quot;\nmerge left pile:\(leftPile) | right pile:\(rightPile)&quot;) ... print(&quot;sorted pile：\(sortedPile)&quot;) return sortedPile&#125; 而且为了方便和上图作比较，初始数组可以取图中的[3, 5, 9, 2, 7, 4, 8, 0]。运行一下看看效果： 12345678910111213141516171819202122232425original array:[3, 5, 9, 2, 7, 4, 8, 0]merge sort...merge left pile:[3] | right pile:[5]sorted pile：[3, 5]merge left pile:[9] | right pile:[2]sorted pile：[2, 9]merge left pile:[3, 5] | right pile:[2, 9]sorted pile：[2, 3, 5, 9]merge left pile:[7] | right pile:[4]sorted pile：[4, 7]merge left pile:[8] | right pile:[0]sorted pile：[0, 8]merge left pile:[4, 7] | right pile:[0, 8]sorted pile：[0, 4, 7, 8]merge left pile:[2, 3, 5, 9] | right pile:[0, 4, 7, 8]sorted pile：[0, 2, 3, 4, 5, 7, 8, 9] 我们可以看到，拆分归并的操作是先处理原数组的左侧部分，然后处理原数组的右侧部分。这是为什么呢？ 我们来看下最初函数是怎么调用的： 最开始我们调用函数： 123456789func mergeSort(_ array: [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; let middleIndex = array.count / 2 let leftArray = mergeSort(Array(array[0..&lt;middleIndex])) //1 let rightArray = mergeSort(Array(array[middleIndex..&lt;array.count])) //2 return _merge(leftPile: leftArray, rightPile: rightArray) //3&#125; 在//1这一行开始了递归，这个时候数组是原数组，元素个数是8，而调用mergeSort时原数组被拆分了一半，是4。而4&gt;1，不满足递归终止的条件，继续递归，直到符合了终止条件（[3]）,递归开始返回。以为此时最初被拆分的是数组的左半部分，所以左半部分的拆分会逐步合并，最终得到了[2,3,5,9]。 同理，再回到了最初被拆分的数组的右半部分（上面代码段中的//2），也是和左测一样的拆分和归并，得到了右侧部分的归并结果：[0,4,7,8]。 而此时的递归调用栈只有一个mergeSort函数了，mergeSort会进行最终的合并（上面代码段中的//3），调用_merge函数，得到了最终的结果：[0, 2, 3, 4, 5, 7, 8, 9]。 关于归并排序的性能：由于使用了分治和递归并且利用了一些其他的内存空间，所以其性能是高于上述介绍的所有排序的，不过前提是初始元素量不小的情况下。 我们可以将选择排序和归并排序做个比较：初始数组为长度500，最大值为500的随机数组： 12345selection sort...selection sort time duration : 12.7smerge sort...merge sort time duration : 5.21s 可以看到归并排序的算法是优与选择排序的。 现在我们知道归并排序使用了分治思想而且使用了递归，能够高效地将数组排序。其实还有一个也是用分治思想和递归，但是却比归并排序还要优秀的算法 - 快速排序算法。 快速排序快速排序算法被称之为20世纪十大算法之一，也是各大公司面试比较喜欢考察的算法。 算法讲解快速排序的基本思想是：通过一趟排序将带排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。 上述文字摘自《大话数据结构》 它的实现步骤为： 从数列中挑出一个元素（挑选的算法可以是随机，也可以作其他的优化），称为”基准”（pivot）。 重新对数组进行排序：所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面，相同的放两边。 递归地进行分区操作，继续把小于基准值元素的子数列和大于基准值元素的子数列排序。 从上面的描述可以看出，分区操作是快速排序中的核心算法。下面笔者结合实例来描述一下分区操作的过程。 首先拿到初始的数组：[5,4,9,1,3,6,7,8,2] 选择5作为pivot。 从剩下部分的两端开始：左侧1的标记为low，最右侧2的标记为high。 先看j：2 &lt; 5 , 交换5和2，j不变 ：[2,4,9,1,3,6,7,8,5]； 再看i：2 &lt; 5 , i ++ ；4 &lt; 5, i++；9 &gt; 5，交换 9 和 5，i不变[2,4,5,1,3,6,7,8,9]。 代码实现使用Swift的filter函数因为在Swift中有一个数组的filter函数可以找出数组中符合某范围的一些数值，所以笔者先介绍一个会用该函数的简单的快速排序的实现： 12345678910func quickSort0&lt;T: Comparable&gt;(_ array: [T]) -&gt; [T] &#123; guard array.count &gt; 1 else &#123; return array &#125; let pivot = array[array.count/2] let less = array.filter &#123; $0 &lt; pivot &#125; let greater = array.filter &#123; $0 &gt; pivot &#125; return quickSort0(less) + quickSort0(greater)&#125; 不难看出这里面使用了递归：选中pivot以后，将数组分成了两个部分，最后将它们合并在一起。虽然这里面使用了Swift里面内置的函数来找出符合这两个个部分的元素，但是读者可以通过这个例子更好地理解快速排序的实现方式。 使用取index = 0 的partition函数除了使用swift内置的filter函数，当然我们也可以自己实现分区的功能，通常使用的是自定义的partition函数。 12345678910111213141516171819func _partition(_ array: inout [Int], low: Int, high: Int) -&gt; Int&#123; var low = low var high = high let pivotValue = array[low] while low &lt; high &#123; while low &lt; high &amp;&amp; array[high] &gt;= pivotValue &#123; high -= 1 &#125; array[low] = array[high] while low &lt; high &amp;&amp; array[low] &lt;= pivotValue &#123; low += 1 &#125; array[high] = array[low] &#125; array[low] = pivotValue return low&#125; 从代码实现可以看出，最初在这里选择的pivotValue是当前数组的第一个元素。 然后从数组的最右侧的index逐渐向左侧移动，如果值大于pivotValue，那么index-1；否则直接将high与low位置上的元素调换；同样左侧的index也是类似的操作。 该函数执行的最终效果就是将最初的array按照选定的pivotValue前后划分。 那么_partition如何使用呢？ 1234567891011func quickSort1(_ array: inout [Int], low: Int, high: Int)&#123; guard array.count &gt; 1 else &#123; return &#125; if low &lt; high &#123; let pivotIndex = _partition(&amp;array, low: low, high: high) quickSort1(&amp;array, low: low, high: pivotIndex - 1) quickSort1(&amp;array, low: pivotIndex + 1, high: high) &#125; &#125; 外层调用的quickSort1是一个递归函数，不断地进行分区操作，最终得到排好序的结果。 我们将上面实现的归并排序，使用swift内置函数的快速排序，以及自定义partition函数的快速排序的性能作对比： 123456merge sort...merge sort time duration : 4.85squick sort...quick sort0 time duration : 984ms //swift filter functionquick sort1 time duration : 2.64s //custom partition 上面的测试用例是选择随机数组的，我们看一下测试用例为元素个数一致的基本有序的数组试一下： 123456merge sort...merge sort time duration : 4.88squick sort...quick sort0 time duration : 921msquick sort1 time duration : 11.3s 虽然元素个数一致，但是性能却差了很多，是为什么呢？因为我们在分区的时候，pivot的index强制为第一个。那么如果这个第一个元素的值本来就非常小，那么就会造成分区不均的情况（前重后轻），而且由于是迭代操作，每次分区都会造成分区不均，导致性能直线下降。所以有一个相对合理的方案就是在选取pivot的index的时候随机选取。 使用随机选择pivotValue的partition函数实现方法肯简单，只需在分区函数里将pivotValue的index随机生成即可： 12345678910func _partitionRandom(_ array: inout [Int], low: Int, high: Int) -&gt; Int&#123; let x = UInt32(low) let y = UInt32(high) let pivotIndex = Int(arc4random() % (y - x)) + Int(x) let pivotValue = array[pivotIndex] ...&#125; 现在用一个数组长度和上面的测试用例一致的基本有序的数组来测试一下随机选取pivotValue的算法： 1234567merge sort...merge sort time duration : 4.73squick sort...quick sort0 time duration : 866msquick sort1 time duration : 15.1s //fixed pivote indexquick sort2 time duration : 4.28s //random pivote index 我们可以看到当随机抽取pivot的index的时候，其运行速度速度是上面方案的3倍。 现在我们知道了3种快速排序的实现，都是根据pivotValue将原数组一分为二。但是如果数组中有大量的重复的元素，而且pivotValue很有可能落在这些元素里，那么显然上面这些算法对于这些可能出现多次于pivotValue重复的情况没有单独做处理。而为了很好解决存在与pivot值相等的元素很多的数组的排序，使用三路排序算法会比较有效果。 三路快速排序三路快速排序将大于，等于，小于pivotValue的元素都区分开，我们看一下具体的实现。先看一下partition函数的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950func swap(_ arr: inout [Int], _ j: Int, _ k: Int) &#123; guard j != k else &#123; return; &#125; let temp = arr[j] arr[j] = arr[k] arr[k] = temp&#125;func quickSort3W(_ array: inout [Int], low: Int, high: Int) &#123; if high &lt;= low &#123; return &#125; var lt = low // arr[low+1...lt] &lt; v var gt = high + 1 // arr[gt...high] &gt; v var i = low + 1 // arr[lt+1...i) == v let pivoteIndex = low let pivoteValue = array[pivoteIndex] while i &lt; gt &#123; if array[i] &lt; pivoteValue &#123; swap(&amp;array, i, lt + 1) i += 1 lt += 1 &#125;else if pivoteValue &lt; array[i]&#123; swap(&amp;array, i, gt - 1) gt -= 1 &#125;else &#123; i += 1 &#125; &#125; swap(&amp;array, low, lt) quickSort3W(&amp;array, low: low, high: lt - 1) quickSort3W(&amp;array, low: gt, high: high) &#125;func quickSort3(_ array: inout [Int] )&#123; quickSort3W(&amp;array, low: 0, high: array.count - 1) &#125; 主要看quickSort3W方法，这里将数组分成了三个区间，分别是大于，等于，小于pivote的值，对有大量重复元素的数组做了比较好的处理。 我们生成一个元素数量为500，最大值为5的随机数组看一下这些快速排序算法的性能： 123quick sort1 time duration : 6.19s //fixed pivote indexquick sort2 time duration : 8.1s //random pivote indexquick sort3 time duration : 4.81s //quick sort 3 way 可以看到三路快速排序（quick sort 3 way）在处理大量重复元素的数组的表现最好。 对于三路快速排序，我们也可以使用Swift内置的filter函数来实现: 1234567891011func quicksort4(_ array: [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; let pivot = array[array.count/2] let less = array.filter &#123; $0 &lt; pivot &#125; let equal = array.filter &#123; $0 == pivot &#125; let greater = array.filter &#123; $0 &gt; pivot &#125; return quicksort4(less) + equal + quicksort4(greater)&#125; 以上，介绍完了快速排序在Swift中的5中实现方式。 最后的话总结本文讲解了Swift的基础语法、算法的一些基本概念以及结合了Swift代码的实现讲解了冒泡排序，选择排序，插入排序，归并排序，快速排序。相信认真阅读本文的读者能对这些算法有进一步的了解。 关于算法学习的思考关于算法的学习，笔者有一些思考想分享出来，也有可能有不对的地方，但笔者觉得有必要在这里说出来，希望可以引发读者的思考： 上图的Question是指问题；Mind是指想法，或者解决问题的思路；Code是指代码实现。 在阅读资料或书籍的算法学习过程，往往是按照图中1，2，3这些实线的路径进行的： 路径1：给出一个既定的问题后，马上给出解题策略 路径2：给出一个既定的问题后，马上给出算法实现 路径3：给出一个算法实现后，马上告诉你这些实现代码的意思 这些路径在算法的学习中虽然也是必不可少的，但是很容易给人一个错觉，这个错觉就是“我已经学会了这个算法了”。但是，仅仅是通过这些路径，对于真正理解算法，和今后对算法的应用还是远远不够的，原因是： 今后遇到的问题，几乎不可能与现在学习的问题一模一样，所以应该知其所以然，将问题本身抽象出来，达到触类旁通，举一反三。 有了一个新想法，如果没有足够的代码实现经验，很难以非常合理的方式用代码将其实现出来。所以应该增强将想法转化为代码的能力。 上面所说的两点的第一点，对应的是上图的路径4：给定一个策略或是设计，要思考这个策略或是设计是解决什么样的问题的，这样也就理解了这个策略或是设计的意义在哪里；而第二点对应的是上图中的路径5：怎样根据一个给定的策略来正确地，合理地用代码地实现出来；而上图中的路径6，笔者觉得也很重要：给定一份解决问题的代码，是否可以想到它所对应的问题是什么。 综上所述，笔者认为对于算法的学习，需要经常反复在问题，策略以及代码之间反复思考，这样才能真正地达到学以致用。 参考文献&amp;网站维基百科：算法 《大话数据结构》 《数据结构与算法分析：C语言描述》]]></content>
      <categories>
        <category>Data Structure &amp; Algorithm</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
        <tag>Algorithm</tag>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDWebImage源码解析]]></title>
    <url>%2F2018%2F03%2F26%2FiOS%2F%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2FSDWebImage%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言相信广大的iOS开发者，对于SDWebImage都不会陌生，这个框架通过给UIButton和UIImageView添加分类，实现了一个异步下载图片并支持缓存的功能。整个框架的接口非常简洁，每个类的分工都很明确，是很值得大家学习的一个框架。 简介在使用这个框架的时候，只需要提供一个下载的url和占位图就可以在回调里拿到下载后的图片： 123456[imageview sd_setImageWithURL:[NSURL URLWithString:@&quot;pic.jpg&quot;] placeholderImage:[UIImage imageNamed:@&quot;placeholder&quot;] completed:^(UIImage * _Nullable image, NSError * _Nullable error, SDImageCacheType cacheType, NSURL * _Nullable imageURL) &#123; imageview.image = image; NSLog(@&quot;图片加载完成&quot;); &#125;]; 而且我们还可以不设置占位图片，也可以不使用回调的block，非常灵活： 12//图片下载完成后直接显示下载后的图片[imageview sd_setImageWithURL:[NSURL URLWithString:@&quot;pic.jpg&quot;]]; 在最开始先简单介绍这个框架： 这个框架的核心类是SDWebImageManger，在外部有UIImageView+WebCache和UIButton+WebCache为下载图片的操作提供接口。内部有SDWebImageManager负责处理和协调SDWebImageDownloader和SDWebImageCache。其中SDWebImageDownloader负责具体的下载任务，SDWebImageCache负责关于缓存的工作：添加，删除，查询缓存。 首先我们大致看一下这个框架的调用流程图： 从这个流程图里可以大致看出，该框架分为两个层：UIKit层（负责接收下载参数）和工具层（负责下载操作和缓存）。 OK～基本流程大概清楚了，我们看一下每个层具体实现吧～ UIKit层该框架最外层的类是UIImageView +WebCache，我们将图片的URL，占位图片直接给这个类。下面是这个类的公共接口： 123456789101112131415161718192021 // ============== UIImageView + WebCache.h ============== //- (void)sd_setImageWithURL:(nullable NSURL *)url;- (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder;- (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options;- (void)sd_setImageWithURL:(nullable NSURL *)url completed:(nullable SDExternalCompletionBlock)completedBlock;- (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder completed:(nullable SDExternalCompletionBlock)completedBlock;- (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options completed:(nullable SDExternalCompletionBlock)completedBlock;- (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDExternalCompletionBlock)completedBlock; 可以看出，这个类提供的接口非常灵活，可以根据我们自己的需求来调用其中某一个方法，而这些方法到最后都会走到： 123456// ============== UIView+ WebCache.m ============== //- (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDExternalCompletionBlock)completedBlock; 为什么不是UIImageView+WebCache而要上一层到UIView的分类里呢？因为SDWebImage框架也支持UIButton的下载图片等方法，所以需要在它们的父类：UIView里面统一一个下载方法。 简单看一下这个方法的实现（省略的代码用…代替）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// ============== UIView+ WebCache.m ============== // //valid key：UIImageView || UIButton NSString *validOperationKey = operationKey ?: NSStringFromClass([self class]); //UIView+WebCacheOperation 的 operationDictionary //下面这行代码是保证没有当前正在进行的异步下载操作, 使它不会与即将进行的操作发生冲突 [self sd_cancelImageLoadOperationWithKey:validOperationKey]; //添加临时的占位图（在不延迟添加占位图的option下） if (!(options &amp; SDWebImageDelayPlaceholder)) &#123; dispatch_main_async_safe(^&#123; [self sd_setImage:placeholder imageData:nil basedOnClassOrViaCustomSetImageBlock:setImageBlock]; &#125;); &#125; //如果url存在 if (url) &#123; ... __weak __typeof(self)wself = self; //SDWebImageManager下载图片 id &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager loadImageWithURL:url options:options progress:progressBlock completed:^(UIImage *image, NSData *data, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; ... //dispatch_main_sync_safe : 保证block能在主线程进行 dispatch_main_async_safe(^&#123; if (!sself) &#123; return; &#125; if (image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage) &amp;&amp; completedBlock) &#123; //image，而且不自动替换 placeholder image completedBlock(image, error, cacheType, url); return; &#125; else if (image) &#123; //存在image，需要马上替换 placeholder image [sself sd_setImage:image imageData:data basedOnClassOrViaCustomSetImageBlock:setImageBlock]; [sself sd_setNeedsLayout]; &#125; else &#123; //没有image，在图片下载完之后显示 placeholder image if ((options &amp; SDWebImageDelayPlaceholder)) &#123; [sself sd_setImage:placeholder imageData:nil basedOnClassOrViaCustomSetImageBlock:setImageBlock]; [sself sd_setNeedsLayout]; &#125; &#125; if (completedBlock &amp;&amp; finished) &#123; completedBlock(image, error, cacheType, url); &#125; &#125;); &#125;]; //在操作缓存字典（operationDictionary）里添加operation，表示当前的操作正在进行 [self sd_setImageLoadOperation:operation forKey:validOperationKey]; &#125; else &#123; //如果url不存在，就在completedBlock里传入error（url为空） dispatch_main_async_safe(^&#123; [self sd_removeActivityIndicator]; if (completedBlock) &#123; NSError *error = [NSError errorWithDomain:SDWebImageErrorDomain code:-1 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Trying to load a nil url&quot;&#125;]; completedBlock(nil, error, SDImageCacheTypeNone, url); &#125; &#125;); &#125; 值得一提的是，在这一层，使用一个字典operationDictionary专门用作存储操作的缓存，随时添加，删除操作任务。而这个字典是UIView+WebCacheOperation分类的关联对象，它的存取方法使用运行时来操作： 12345678910111213 // ============== UIView+WebCacheOperation.m ============== // //获取关联对象：operations（用来存放操作的字典）- (SDOperationsDictionary *)operationDictionary &#123; SDOperationsDictionary *operations = objc_getAssociatedObject(self, &amp;loadOperationKey); //存放操作的字典 if (operations) &#123; return operations; &#125; //如果没有，就新建一个 operations = [NSMutableDictionary dictionary]; objc_setAssociatedObject(self, &amp;loadOperationKey, operations, OBJC_ASSOCIATION_RETAIN_NONATOMIC); return operations;&#125; 为什么不直接在UIImageView+WebCache里直接关联这个对象呢？我觉得这里作者应该是遵从面向对象的单一职责原则（SRP：Single responsibility principle），就连类都要履行这个职责，何况分类呢？这里作者专门创造一个分类UIView+WebCacheOperation来管理操作缓存（字典）。 到这里，UIKit层上面的东西都讲完了，现在开始正式讲解工具层。 工具层上文提到过，SDWebImageManager同时管理SDImageCache和SDWebImageDownloader两个类，它是这一层的老大哥。在下载任务开始的时候，SDWebImageManager首先访问SDImageCache来查询是否存在缓存，如果有缓存，直接返回缓存的图片。如果没有缓存，就命令SDWebImageDownloader来下载图片，下载成功后，存入缓存，显示图片。以上是SDWebImageManager大致的工作流程。 在详细讲解SDWebImageManager是如何下载图片之前，我们先看一下这个类的几个重要的属性： 12345 // ============== SDWebImageManager.h ============== //@property (strong, nonatomic, readwrite, nonnull) SDImageCache *imageCache;//管理缓存@property (strong, nonatomic, readwrite, nonnull) SDWebImageDownloader //下载器*imageDownloader;@property (strong, nonatomic, nonnull) NSMutableSet&lt;NSURL *&gt; *failedURLs;//记录失效url的名单@property (strong, nonatomic, nonnull) NSMutableArray&lt;SDWebImageCombinedOperation *&gt; *runningOperations;//记录当前正在执行的操作 SDWebImageManager下载图片的方法只有一个： 1[SDWebImageManager.sharedManager loadImageWithURL:options:progress:completed:] 看一下这个方法的具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118 // ============== SDWebImageManager.m ============== //- (id &lt;SDWebImageOperation&gt;)loadImageWithURL:(nullable NSURL *)url options:(SDWebImageOptions)options progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDInternalCompletionBlock)completedBlock &#123; ... //在SDImageCache里查询是否存在缓存的图片 operation.cacheOperation = [self.imageCache queryCacheOperationForKey:key done:^(UIImage *cachedImage, NSData *cachedData, SDImageCacheType cacheType) &#123; ... //（没有缓存图片） || （即使有缓存图片，也需要更新缓存图片） || （代理没有响应imageManager:shouldDownloadImageForURL:消息，默认返回yes，需要下载图片）|| （imageManager:shouldDownloadImageForURL:返回yes，需要下载图片） if ((!cachedImage || options &amp; SDWebImageRefreshCached) &amp;&amp; (![self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self shouldDownloadImageForURL:url])) &#123; //1. 存在缓存图片 &amp;&amp; 即使有缓存图片也要下载更新图片 if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123; [self callCompletionBlockForOperation:weakOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url]; &#125; // 2. 如果不存在缓存图片 ... //开启下载器下载 //subOperationToken 用来标记当前的下载任务，便于被取消 SDWebImageDownloadToken *subOperationToken = [self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage *downloadedImage, NSData *downloadedData, NSError *error, BOOL finished) &#123; __strong __typeof(weakOperation) strongOperation = weakOperation; if (!strongOperation || strongOperation.isCancelled) &#123; // 1. 如果任务被取消，则什么都不做，避免和其他的completedBlock重复 &#125; else if (error) &#123; //2. 如果有错误 //2.1 在completedBlock里传入error [self callCompletionBlockForOperation:strongOperation completion:completedBlock error:error url:url]; //2.2 在错误url名单中添加当前的url if ( error.code != NSURLErrorNotConnectedToInternet &amp;&amp; error.code != NSURLErrorCancelled &amp;&amp; error.code != NSURLErrorTimedOut &amp;&amp; error.code != NSURLErrorInternationalRoamingOff &amp;&amp; error.code != NSURLErrorDataNotAllowed &amp;&amp; error.code != NSURLErrorCannotFindHost &amp;&amp; error.code != NSURLErrorCannotConnectToHost) &#123; @synchronized (self.failedURLs) &#123; [self.failedURLs addObject:url]; &#125; &#125; &#125; else &#123; //3. 下载成功 //3.1 如果需要下载失败后重新下载，则将当前url从失败url名单里移除 if ((options &amp; SDWebImageRetryFailed)) &#123; @synchronized (self.failedURLs) &#123; [self.failedURLs removeObject:url]; &#125; &#125; //3.2 进行缓存 BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly); if (options &amp; SDWebImageRefreshCached &amp;&amp; cachedImage &amp;&amp; !downloadedImage) &#123; //（即使缓存存在，也要刷新图片） &amp;&amp; 缓存图片 &amp;&amp; 不存在下载后的图片：不做操作 &#125; else if (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)]) &#123; //（下载图片成功 &amp;&amp; （没有动图||处理动图） &amp;&amp; （下载之后，缓存之前处理图片） dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123; UIImage *transformedImage = [self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url]; if (transformedImage &amp;&amp; finished) &#123; BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage]; // pass nil if the image was transformed, so we can recalculate the data from the image //缓存图片 [self.imageCache storeImage:transformedImage imageData:(imageWasTransformed ? nil : downloadedData) forKey:key toDisk:cacheOnDisk completion:nil]; &#125; //将图片传入completedBlock [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:transformedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url]; &#125;); &#125; else &#123; //(图片下载成功并结束) if (downloadedImage &amp;&amp; finished) &#123; [self.imageCache storeImage:downloadedImage imageData:downloadedData forKey:key toDisk:cacheOnDisk completion:nil]; &#125; [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:downloadedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url]; &#125; &#125; //如果完成，从当前运行的操作列表里移除当前操作 if (finished) &#123; [self safelyRemoveOperationFromRunning:strongOperation]; &#125; &#125;]; //取消的block operation.cancelBlock = ^&#123; //取消当前的token [self.imageDownloader cancel:subOperationToken]; __strong __typeof(weakOperation) strongOperation = weakOperation; //从当前运行的操作列表里移除当前操作 [self safelyRemoveOperationFromRunning:strongOperation]; &#125;; &#125; else if (cachedImage) &#123; //存在缓存图片 __strong __typeof(weakOperation) strongOperation = weakOperation; //调用完成的block [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url]; //删去当前的的下载操作（线程安全） [self safelyRemoveOperationFromRunning:operation]; &#125; else &#123; //没有缓存的图片，而且下载被代理终止了 __strong __typeof(weakOperation) strongOperation = weakOperation; // 调用完成的block [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:nil data:nil error:nil cacheType:SDImageCacheTypeNone finished:YES url:url]; //删去当前的下载操作 [self safelyRemoveOperationFromRunning:operation]; &#125; &#125;]; return operation; &#125; 看完了SDWebImageManager的回调处理，我们分别看一下SDImageCache和SDWebImageDownloader内部具体是如何工作的。首先看一下SDImageCache： SDImageCache属性12345 // ============== SDImageCache.m ============== //@property (strong, nonatomic, nonnull) NSCache *memCache;//内存缓存@property (strong, nonatomic, nonnull) NSString *diskCachePath;//磁盘缓存路径@property (strong, nonatomic, nullable) NSMutableArray&lt;NSString *&gt; *customPaths;//@property (SDDispatchQueueSetterSementics, nonatomic, nullable) dispatch_queue_t //ioQueue唯一子线程; 核心方法：查询缓存12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 // ============== SDImageCache.m ============== //- (nullable NSOperation *)queryCacheOperationForKey:(nullable NSString *)key done:(nullable SDCacheQueryCompletedBlock)doneBlock &#123; if (!key) &#123; if (doneBlock) &#123; doneBlock(nil, nil, SDImageCacheTypeNone); &#125; return nil; &#125; //================查看内存的缓存=================// UIImage *image = [self imageFromMemoryCacheForKey:key]; // 如果存在，直接调用block，将image，data，CaheType传进去 if (image) &#123; NSData *diskData = nil; //如果是gif，就拿到data，后面要传到doneBlock里。不是gif就传nil if ([image isGIF]) &#123; diskData = [self diskImageDataBySearchingAllPathsForKey:key]; &#125; if (doneBlock) &#123; doneBlock(image, diskData, SDImageCacheTypeMemory); &#125; //因为图片有缓存可供使用，所以不用实例化NSOperation，直接范围nil return nil; &#125; //================查看磁盘的缓存=================// NSOperation *operation = [NSOperation new]; //唯一的子线程：self.ioQueue dispatch_async(self.ioQueue, ^&#123; if (operation.isCancelled) &#123; // 在用之前就判断operation是否被取消了，作者考虑的非常严谨 return; &#125; @autoreleasepool &#123; NSData *diskData = [self diskImageDataBySearchingAllPathsForKey:key]; UIImage *diskImage = [self diskImageForKey:key]; if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) &#123; // cost 被用来计算缓存中所有对象的代价。当内存受限或者所有缓存对象的总代价超过了最大允许的值时，缓存会移除其中的一些对象。 NSUInteger cost = SDCacheCostForImage(diskImage); //存入内存缓存中 [self.memCache setObject:diskImage forKey:key cost:cost]; &#125; if (doneBlock) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; doneBlock(diskImage, diskData, SDImageCacheTypeDisk); &#125;); &#125; &#125; &#125;); return operation;&#125; SDWebImageDownloader属性1234567 // ============== SDWebImageDownloader.m ============== //@property (strong, nonatomic, nonnull) NSOperationQueue *downloadQueue;//下载队列@property (weak, nonatomic, nullable) NSOperation *lastAddedOperation;//最后添加的下载操作@property (assign, nonatomic, nullable) Class operationClass;//操作类@property (strong, nonatomic, nonnull) NSMutableDictionary&lt;NSURL *, SDWebImageDownloaderOperation *&gt; *URLOperations;//操作数组@property (strong, nonatomic, nullable) SDHTTPHeadersMutableDictionary *HTTPHeaders;//HTTP请求头@property (SDDispatchQueueSetterSementics, nonatomic, nullable) dispatch_queue_t barrierQueue;//用来阻塞前面的下载线程（串行化） 核心方法：下载图片123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 // ============== SDWebImageDownloader.m ============== //- (nullable SDWebImageDownloadToken *)downloadImageWithURL:(nullable NSURL *)url options:(SDWebImageDownloaderOptions)options progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock &#123; __weak SDWebImageDownloader *wself = self; return [self addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^SDWebImageDownloaderOperation *&#123; __strong __typeof (wself) sself = wself; NSTimeInterval timeoutInterval = sself.downloadTimeout; if (timeoutInterval == 0.0) &#123; timeoutInterval = 15.0; &#125; // In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise //创建下载请求 NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url cachePolicy:(options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData) timeoutInterval:timeoutInterval]; request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies); request.HTTPShouldUsePipelining = YES; if (sself.headersFilter) &#123; request.allHTTPHeaderFields = sself.headersFilter(url, [sself.HTTPHeaders copy]); &#125; else &#123; request.allHTTPHeaderFields = sself.HTTPHeaders; &#125; //创建下载操作：SDWebImageDownloaderOperation用于请求网络资源的操作，它是一个 NSOperation 的子类 SDWebImageDownloaderOperation *operation = [[sself.operationClass alloc] initWithRequest:request inSession:sself.session options:options]; operation.shouldDecompressImages = sself.shouldDecompressImages; //url证书 if (sself.urlCredential) &#123; operation.credential = sself.urlCredential; &#125; else if (sself.username &amp;&amp; sself.password) &#123; operation.credential = [NSURLCredential credentialWithUser:sself.username password:sself.password persistence:NSURLCredentialPersistenceForSession]; &#125; //优先级 if (options &amp; SDWebImageDownloaderHighPriority) &#123; operation.queuePriority = NSOperationQueuePriorityHigh; &#125; else if (options &amp; SDWebImageDownloaderLowPriority) &#123; operation.queuePriority = NSOperationQueuePriorityLow; &#125; //在下载队列里添加下载操作，执行下载操作 [sself.downloadQueue addOperation:operation]; //如果后进先出 if (sself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123; // Emulate LIFO execution order by systematically adding new operations as last operation&apos;s dependency //addDependency:参数opertaion倍添加到NSOperationQueue后，只有等该opertion结束后才能执行其他的operation，实现了后进先出 [sself.lastAddedOperation addDependency:operation]; sself.lastAddedOperation = operation; &#125; return operation; &#125;];&#125; 这里面还有一个addProgressCallback: progressBlock: completedBlock: forURL: createCallback:方法，用来保存progressBlock和completedBlock。我们看一下这个方法的实现： 123456789101112131415161718192021222324252627282930313233343536373839 // ============== SDWebImageDownloader.m ============== //- (nullable SDWebImageDownloadToken *)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock forURL:(nullable NSURL *)url createCallback:(SDWebImageDownloaderOperation *(^)())createCallback &#123; // url 用来作为回调字典的key，如果为空，立即返回失败 if (url == nil) &#123; if (completedBlock != nil) &#123; completedBlock(nil, nil, nil, NO); &#125; return nil; &#125; __block SDWebImageDownloadToken *token = nil; //串行化前面所有的操作 dispatch_barrier_sync(self.barrierQueue, ^&#123; //当前下载操作中取出SDWebImageDownloaderOperation实例 SDWebImageDownloaderOperation *operation = self.URLOperations[url]; if (!operation) &#123; //如果没有，就初始化它 operation = createCallback(); self.URLOperations[url] = operation; __weak SDWebImageDownloaderOperation *woperation = operation; operation.completionBlock = ^&#123; SDWebImageDownloaderOperation *soperation = woperation; if (!soperation) return; if (self.URLOperations[url] == soperation) &#123; [self.URLOperations removeObjectForKey:url]; &#125;; &#125;; &#125; id downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock]; //这里 downloadOperationCancelToken 默认是一个字典，存放 progressBlock 和 completedBlock token = [SDWebImageDownloadToken new]; token.url = url; token.downloadOperationCancelToken = downloadOperationCancelToken; &#125;); return token;&#125; 这里真正保存两个block的方法是addHandlersForProgress: completed:： 123456789101112- (nullable id)addHandlersForProgress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock &#123; //实例化一个SDCallbacksDictionary，存放一个progressBlock 和 completedBlock SDCallbacksDictionary *callbacks = [NSMutableDictionary new]; if (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock copy]; if (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock copy]; dispatch_barrier_async(self.barrierQueue, ^&#123; //添加到缓存中 self.callbackBlocks [self.callbackBlocks addObject:callbacks]; &#125;); return callbacks;&#125; 到这里SDWebImage的核心方法都讲解完毕了，其他没有讲到的部分以后会慢慢添加上去。 最后看一下一些比较零散的知识点： 1. 运行时存取关联对象：存： 12objc_setAssociatedObject(self, &amp;loadOperationKey, operations, OBJC_ASSOCIATION_RETAIN_NONATOMIC);//将operations对象关联给self，地址为&amp;loadOperationKey，语义是OBJC_ASSOCIATION_RETAIN_NONATOMIC。 取： 12SDOperationsDictionary *operations = objc_getAssociatedObject(self, &amp;loadOperationKey);//将operations对象通过地址&amp;loadOperationKey从self里取出来 2. 数组的写操作需要加锁（多线程访问，避免覆写）12345678910111213//给self.runningOperations加锁//self.runningOperations数组的添加操作 @synchronized (self.runningOperations) &#123; [self.runningOperations addObject:operation]; &#125;//self.runningOperations数组的删除操作- (void)safelyRemoveOperationFromRunning:(nullable SDWebImageCombinedOperation*)operation &#123; @synchronized (self.runningOperations) &#123; if (operation) &#123; [self.runningOperations removeObject:operation]; &#125; &#125;&#125; 3. 确保在主线程的宏：123456789101112dispatch_main_async_safe(^&#123; //将下面这段代码放在主线程中 [self sd_setImage:placeholder imageData:nil basedOnClassOrViaCustomSetImageBlock:setImageBlock]; &#125;);//宏定义：#define dispatch_main_async_safe(block)\ if (strcmp(dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL), dispatch_queue_get_label(dispatch_get_main_queue())) == 0) &#123;\ block();\ &#125; else &#123;\ dispatch_async(dispatch_get_main_queue(), block);\ &#125;#endif 4. 设置不能为nil的参数123456789- (nonnull instancetype)initWithCache:(nonnull SDImageCache *)cache downloader:(nonnull SDWebImageDownloader *)downloader &#123; if ((self = [super init])) &#123; _imageCache = cache; _imageDownloader = downloader; _failedURLs = [NSMutableSet new]; _runningOperations = [NSMutableArray new]; &#125; return self;&#125; 如果在参数里添加了nonnull关键字，那么编译器就可以检查传入的参数是否为nil，如果是，则编译器会有警告 5. 容错，强制转换类型123if ([url isKindOfClass:NSString.class]) &#123; url = [NSURL URLWithString:(NSString *)url];&#125; 在传入的参数为NSString时（但是方法参数要求是NSURL），自动转换为NSURL]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F16%2Fhexo%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS代码规范]]></title>
    <url>%2F2018%2F03%2F15%2FiOS%2FiOS%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[利用业余时间，整理出来了这份规范，我会将这份规范作为以后我们团队的代码规范，并且我也会根据读者的反馈以及项目的实践不定时更新，希望大家多多指正批评。 这篇规范一共分为三个部分： 核心原则：介绍这篇代码规范所遵循的核心原则。 通用规范：不局限iOS的通用性的代码规范（使用C语言和Swift语言） iOS规范：仅适用于iOS的代码规范（使用Objective-C） 一、核心原则原则一：代码应该简洁易懂，逻辑清晰以为软件是需要人来维护的。这个人在未来很可能不是你。所以首先是为人编写程序，其次才是计算机。 不要分追求技巧，降低程序的可读性 简洁的代码可以让bug无处藏身。要写出明显没有bug的代码，而不是没有明显bug的代码。 原则二：面向变化编程，而不是面向需求编程需求是暂时的，只有变化才是永恒的。本次迭代不能仅仅为了当前的需求，要写出拓展性强，易修改的程序才是责任的做法，对自己负责，对公司负责。 原则三：先保证程序的正确性，防止过度工程过度工程（over-engineering）：在正确可用的代码写出之前就过度地考虑拓展，重用的的问题，使得工程过度复杂。引用《王垠：编程的智慧》里的话： 先把眼前的问题解决掉，解决好，再考虑将来的扩展问题。 先写出可用的代码，反复推敲，再考虑是否需要重用的问题。 先写出可用，简单，明显没有bug的代码，再考虑测试的问题。 二、通用规范关于大括号 控制语句(if,for,while,switch)中，大括号开始与行尾 函数中，大括号要开始于行首 推荐这样写： 12345678910//控制语句white(someCondition)&#123;&#125;//函数void function(param1,param2)&#123;&#125; 运算符 1.运算符与变量之间的间隔1.1 一元运算符与变量之间没有空格：12345!bValue~iValue++iCount*strSource&amp;fSum 1.2 二元运算符与变量之间必须有空格：1234fWidth = 5 + 5;fLength = fWidth * 2;fHeight = fWidth + fLength;for(int i = 0; i &lt; 10; i++) 2. 多个不同的运算符同时存在时应该使用括号来明确优先级在多个不同的运算符同时存在的时候应该合理使用括号，不要盲目依赖操作符优先级。因为有的时候不能保证阅读你代码的人就一定能了解你写的算式里面所有操作符的优先级。 来看一下这个算式：2 &lt;&lt; 2 + 1 * 3 - 4 这里的&lt;&lt;是移位操作直观上却很容易认为它的优先级很高，所以就把这个算式误认为：(2 &lt;&lt; 2) + 13 - 4但事实上，它的优先级是比加减法还要低的，所以该算式应该等同于：2 &lt;&lt; (2 + 13 - 4).所以在以后写这种复杂一点的算式的时候，尽量多加一点括号，避免让其他人误解（甚至是自己）。 变量 1.一个变量有且只有一个功能，尽量不要把一个变量用作多种用途2.变量在使用前应该初始化，防止未初始化的变量被引用3.局部变量应该尽量接近使用它的地方推荐这样写： 1234567891011func someFunction() &#123; let index = ...; //Do something With index ... ... let count = ...; //Do something With count &#125; 不推荐这样写： 12345678910func someFunction() &#123; let index = ...; let count = ...; //Do something With index ... ... //Do something With count&#125; if语句 1.必须列出所有的分支（列举所有的情况），而且每个分支都必须给出明确的结果。推荐这样写： 123456var hintStr;if (count &lt; 3) &#123; hintStr = &quot;Good&quot;;&#125; else &#123; hintStr = &quot;&quot;;&#125; 不推荐这样写： 1234var hintStr;if (count &lt; 3) &#123; hintStr = &quot;Good&quot;;&#125; 2.不要使用过多的分支，要善于使用return来提前返回错误的情况推荐这样写： 123456- (void)someMethod &#123; if (!goodCondition) &#123; return; &#125; //Do something&#125; 不推荐这样写： 12345- (void)someMethod &#123; if (goodCondition) &#123; //Do something &#125;&#125; 比较典型的例子： 12345678910111213141516171819202122232425262728293031323334-(id)initWithDictionary:(NSDictionary*)dict error:(NSError)err&#123; //方法1. 参数为nil if (!dict) &#123; if (err) *err = [JSONModelError errorInputIsNil]; return nil; &#125; //方法2. 参数不是nil，但也不是字典 if (![dict isKindOfClass:[NSDictionary class]]) &#123; if (err) *err = [JSONModelError errorInvalidDataWithMessage:@&quot;Attempt to initialize JSONModel object using initWithDictionary:error: but the dictionary parameter was not an &apos;NSDictionary&apos;.&quot;]; return nil; &#125; //方法3. 初始化 self = [self init]; if (!self) &#123; //初始化失败 if (err) *err = [JSONModelError errorModelIsInvalid]; return nil; &#125; //方法4. 检查用户定义的模型里的属性集合是否大于传入的字典里的key集合（如果大于，则返回NO） if (![self __doesDictionary:dict matchModelWithKeyMapper:self.__keyMapper error:err]) &#123; return nil; &#125; //方法5. 核心方法：字典的key与模型的属性的映射 if (![self __importDictionary:dict withKeyMapper:self.__keyMapper validation:YES error:err]) &#123; return nil; &#125; //方法6. 可以重写[self validate:err]方法并返回NO，让用户自定义错误并阻拦model的返回 if (![self validate:err]) &#123; return nil; &#125; //方法7. 终于通过了！成功返回model return self;&#125; 可以看到，在这里，首先判断出各种错误的情况然后提前返回，把最正确的情况放到最后返回。 3.条件表达式如果很长，则需要将他们提取出来赋值给一个BOOL值推荐这样写： 123456let nameContainsSwift = sessionName.hasPrefix(&quot;Swift&quot;)let isCurrentYear = sessionDateCompontents.year == 2014let isSwiftSession = nameContainsSwift &amp;&amp; isCurrentYearif (isSwiftSession) &#123; // Do something&#125; 不推荐这样写： 123if ( sessionName.hasPrefix(&quot;Swift&quot;) &amp;&amp; (sessionDateCompontents.year == 2014) ) &#123; // Do something&#125; 4.条件语句的判断应该是变量在左，常量在右推荐这样写： 12if ( count == 6) &#123;&#125; 或者 12if ( object == nil) &#123;&#125; 或者 12if ( !object ) &#123;&#125; 不推荐这样写： 12if ( 6 == count) &#123;&#125; 或者 12f ( nil == object ) &#123;&#125; 5.每个分支必须的实现代码必须用大括号包围推荐这样写： 123if (!error) &#123; return success;&#125; 不推荐这样写：12if (!error) return success; 或者 1if (!error) return success; 6.条件过多，过长的时候应该换行推荐这样写： 123456if (condition1() &amp;&amp; condition2() &amp;&amp; condition3() &amp;&amp; condition4()) &#123; // Do something&#125; 不推荐这样写： 123if (condition1() &amp;&amp; condition2() &amp;&amp; condition3() &amp;&amp; condition4()) &#123; // Do something&#125; for语句 1.不可在for循环内修改循环变量，防止for循环失去控制。1234for (int index = 0; index &lt; 10; index++)&#123; ... logicToChange(index)&#125; 2.避免使用continue和break。continue和break做描述的是“什么时候不做什么”，所以为了读懂二者所在的代码，我们需要在头脑里将他们取反。 其实最好不要让这两个东西出现，移位我们的代码只要体现出“什么时候做什么”就好了，而且通过适当的方法，是可以将这两个东西消灭掉的； 2.1 如果出现了continue，只需要把continue的条件取反即可1234567var filteredProducts = Array&lt;String&gt;()for level in products &#123; if level.hasPrefix(&quot;bad&quot;) &#123; continue &#125; filteredProducts.append(level)&#125; 我们可以看到，通过判断字符串里是否还有“bad”这个prefix老过滤掉一些值。其实我们是可以通过取反，来避免使用continue的： 12345for level in products &#123; if !level.hasPrefix(&quot;bad&quot;) &#123; filteredProducts.append(level) &#125;&#125; 2.2 消除while里的break；讲break的条件取反，合并并到主循环里在while里的block其实就相当于“不存在”，既然是不存在的东西就完全可以子啊最开始的条件语句中将其排除。 while里的break: 123456while (condition1) &#123; ... if (condition2) &#123; break; &#125;&#125; 取反并合并到主条件： 123while (condition1 &amp;&amp; !condition2) &#123; ...&#125; 2.3 在有返回值的方法里消除break：将break转换为return立即返回有些朋友喜欢这样做：在有返回值的方法里break之后，再返回某个值。其实完全可以在break的那一行直接返回。 123456789func hasBadProductIn(products: Array&lt;String&gt;) -&gt; Bool &#123; var result = false for level in products &#123; if level.hasPrefix(&quot;bad&quot;) &#123; result = true &#125; &#125; return result&#125; 遇到错误条件直接返回： 12345678func hasBadProductIn(products: Array&lt;String&gt;) -&gt; Bool &#123; for level in products &#123; if level.hasPrefix(&quot;bad&quot;) &#123; return true &#125; &#125; return false&#125; 这样写的话不用特意声明一个变量来特意保存需要返回的值，看起来非常简洁，可读性高。 Switch语句 1. 每个分支都必须用大括号括起来推荐这样写： 123456789101112131415161718switch (integer) &#123; case 1: &#123; // ... &#125; break; case 2: &#123; // ... break; &#125; case 3: &#123; // ... break; &#125; default:&#123; // ... break; &#125;&#125; 2. 使用枚举类型时，不能有default分支， 除了使用枚举类型以外，都必须有default分支123456789101112131415RWTLeftMenuTopItemType menuType = RWTLeftMenuTopItemMain; switch (menuType) &#123; case RWTLeftMenuTopItemMain: &#123; // ... break; &#125; case RWTLeftMenuTopItemShows: &#123; // ... break; &#125; case RWTLeftMenuTopItemSchedule: &#123; // ... break; &#125;&#125; 在Switch语句使用枚举类型的时候，如果使用了default分支，在将来就无法通过编译器来检查新增的枚举类型了。 函数 1. 一个函数的长度必须限制在50行以内常来说，在阅读一个函数的时候，如果视需要跨过很长的垂直距离会非常影响代码的阅读体验。如果需要来回滚动眼球或代码才能看全一个方法，就会很影响思维的连贯性，对阅读代码的速度造成比较大的影响。最好的情况是在不滚动眼球或代码的情况下一眼就能将该方法的全部代码映入眼帘。 2. 一个函数只做一件事（单一原则）每个函数的职责都应该划分的很明确（就像类一样）。 推荐这样写： 12dataConfiguration()viewConfiguration() 不推荐这样写： 12345void dataConfiguration()&#123; ... viewConfiguration()&#125; 3. 对于有返回值的函数（方法），每一个分支都必须有返回值推荐这样写： 12345678910int function()&#123; if(condition1)&#123; return count1 &#125;else if(condition2)&#123; return count2 &#125;else&#123; return defaultCount &#125; &#125; 不推荐这样写： 12345678int function()&#123; if(condition1)&#123; return count1 &#125;else if(condition2)&#123; return count2 &#125;&#125; 4. 对输入参数的正确性和有效性进行检查，参数错误立即返回推荐这样写： 1234567891011void function(param1,param2)&#123; if(param1 is unavailable)&#123; return; &#125; if(param2 is unavailable)&#123; return; &#125; //Do some right thing&#125; 5. 如果在不同的函数内部有相同的功能，应该把相同的功能抽取出来单独作为另一个函数原来的调用： 123456789void logic() &#123; a(); b()； if (logic1 condition) &#123; c(); &#125; else &#123; d(); &#125;&#125; 将a，b函数抽取出来作为单独的函数 12345678910111213void basicConfig() &#123; a(); b();&#125; void logic1() &#123; basicConfig(); c();&#125;void logic2() &#123; basicConfig(); d();&#125; 6. 将函数内部比较复杂的逻辑提取出来作为单独的函数一个函数内的不清晰（逻辑判断比较多，行数较多）的那片代码，往往可以被提取出去，构成一个新的函数，然后在原来的地方调用它这样你就可以使用有意义的函数名来代替注释，增加程序的可读性。 举一个发送邮件的例子： 123456789openEmailSite();login();writeTitle(title);writeContent(content);writeReceiver(receiver);addAttachment(attachment);send(); 中间的部分稍微长一些，我们可以将它们提取出来： 1234567void writeEmail(title, content,receiver,attachment)&#123; writeTitle(title); writeContent(content); writeReceiver(receiver); addAttachment(attachment); &#125; 然后再看一下原来的代码： 1234openEmailSite();login();writeEmail(title, content,receiver,attachment)send(); 7.避免使用全局变量，类成员（class member）来传递信息，尽量使用局部变量和参数。在一个类里面，经常会有传递某些变量的情况。而如果需要传递的变量是某个全局变量或者属性的时候，有些朋友不喜欢将它们作为参数，而是在方法内部就直接访问了： 1234567891011class A &#123; var x; func updateX() &#123; ... x = ...; &#125; func printX() &#123; updateX(); print(x); &#125;&#125; 我们可以看到，在printX方法里面，updateX和print方法之间并没有值的传递，乍一看我们可能不知道x从哪里来的，导致程序的可读性降低了。 而如果你使用局部变量而不是类成员来传递信息，那么这两个函数就不需要依赖于某一个类，而且更加容易理解，不易出错： 12345678func updateX() -&gt; String&#123; x = ...; return x; &#125; func printX() &#123; String x = updateX(); print(x); &#125; 注释 优秀的代码大部分是可以自描述的，我们完全可以用程代码本身来表达它到底在干什么，而不需要注释的辅助。 但并不是说一定不能写注释，有以下三种情况比较适合写注释： 公共接口（注释要告诉阅读代码的人，当前类能实现什么功能）。涉及到比较深层专业知识的代码（注释要体现出实现原理和思想）。容易产生歧义的代码（但是严格来说，容易让人产生歧义的代码是不允许存在的）。除了上述这三种情况，如果别人只能依靠注释才能读懂你的代码的时候，就要反思代码出现了什么问题。 最后，对于注释的内容，相对于“做了什么”，更应该说明“为什么这么做”。 Code Review 换行、注释、方法长度、代码重复等这些是通过机器检查出来的问题，是无需通过人来做的。 而且除了审查需求的实现的程度，bug是否无处藏身以外，更应该关注代码的设计。比如类与类之间的耦合程度，设计的可扩展性，复用性，是否可以将某些方法抽出来作为接口等等。 三. iOS规范变量 1. 变量名必须使用驼峰格式类，协议使用大驼峰： 12HomePageViewController.h&lt;HeaderViewDelegate&gt; 对象等局部变量使用小驼峰： 12NSString *personName = @&quot;&quot;;NSUInteger totalCount = 0; 2. 变量的名称必须同时包含功能与类型123UIButton *addBtn //添加按钮UILabel *nameLbl //名字标签NSString *addressStr//地址字符串 3. 系统常用类作实例变量声明时加入后缀 类型 后缀 UIViewController VC UIView View UILabel Lbl UIButton Btn UIImage Img UIImageView ImagView NSArray Array NSMutableArray Marray NSDictionary Dict NSMutableDictionary MDdict NSString Str NSMutableString MStr NSSet Set NSMutableSet Mset 常量 1. 常量以相关类名作为前缀推荐这样写： 1static const NSTimeInterval ZOCSignInViewControllerFadeOutAnimationDuration = 0.4; 不推荐这样写： 1static const NSTimeInterval fadeOutTime = 0.4; 2. 建议使用类型常量，不建议使用#define预处理命令首先比较一下这两种声明常量的区别： 预处理命令：简单的文本替换，不包括类型信息，并且可被任意修改。 类型常量：包括类型信息，并且可以设置其使用范围，而且不可被修改。 使用预处理虽然能达到替换文本的目的，但是本身还是有局限性的： 不具备类型信息。 可以被任意修改。 3. 对外公开某个常量：如果我们需要发送通知，那么就需要在不同的地方拿到通知的“频道”字符串（通知的名称），那么显然这个字符串是不能被轻易更改，而且可以在不同的地方获取。这个时候就需要定义一个外界可见的字符串常量。 推荐这样写： 12//头文件extern NSString *const ZOCCacheControllerDidClearCacheNotification; 123//实现文件static NSString * const ZOCCacheControllerDidClearCacheNotification = @&quot;ZOCCacheControllerDidClearCacheNotification&quot;;static const CGFloat ZOCImageThumbnailHeight = 50.0f; 不推荐这样写： 12#define CompanyName @&quot;Apple Inc.&quot; #define magicNumber 42 宏 1. 宏、常量名都要使用大写字母，用下划线‘_’分割单词。123#define URL_GAIN_QUOTE_LIST @&quot;/v1/quote/list&quot;#define URL_UPDATE_QUOTE_LIST @&quot;/v1/quote/update&quot;#define URL_LOGIN @&quot;/v1/user/login” 2. 宏定义中如果包含表达式或变量，表达式和变量必须用小括号括起来。1#define MY_MIN(A, B) ((A)&gt;(B)?(B):(A)) CGRect函数 其实iOS内部已经提供了相应的获取CGRect各个部分的函数了，它们的可读性比较高，而且简短，推荐使用： 推荐这样写： 123456CGRect frame = self.view.frame; CGFloat x = CGRectGetMinX(frame); CGFloat y = CGRectGetMinY(frame); CGFloat width = CGRectGetWidth(frame); CGFloat height = CGRectGetHeight(frame); CGRect frame = CGRectMake(0.0, 0.0, width, height); 而不是 123456CGRect frame = self.view.frame; CGFloat x = frame.origin.x; CGFloat y = frame.origin.y; CGFloat width = frame.size.width; CGFloat height = frame.size.height; CGRect frame = (CGRect)&#123; .origin = CGPointZero, .size = frame.size &#125;; 范型 建议在定义NSArray和NSDictionary时使用泛型，可以保证程序的安全性： 12NSArray&lt;NSString *&gt; *testArr = [NSArray arrayWithObjects:@&quot;Hello&quot;, @&quot;world&quot;, nil];NSDictionary&lt;NSString *, NSNumber *&gt; *dic = @&#123;@&quot;key&quot;:@(1), @&quot;age&quot;:@(10)&#125;; Block为常用的Block类型创建typedef 如果我们需要重复创建某种block（相同参数，返回值）的变量，我们就可以通过typedef来给某一种块定义属于它自己的新类型 例如： 1234int (^variableName)(BOOL flag, int value) =^(BOOL flag, int value)&#123; // Implementation return someInt;&#125; 这个Block有一个bool参数和一个int参数，并返回int类型。我们可以给它定义类型： 12345int(^EOCSomeBlock)(BOOL flag, int value);//再次定义的时候，就可以通过简单的赋值来实现：EOCSomeBlock block = ^(BOOL flag, int value)&#123;// Implementation&#125;; 定义作为参数的Block： 1(void)startWithCompletionHandler: (void(^)(NSData data, NSError error))completion; 这里的Block有一个NSData参数，一个NSError参数并没有返回值 1typedef void(^EOCCompletionHandler)(NSData data, NSError error); 1(void)startWithCompletionHandler:(EOCCompletionHandler)completion;” 通过typedef定义Block签名的好处是:如果要某种块增加参数，那么只修改定义签名的那行代码即可。 字面量语法 尽量使用字面量值来创建 NSString , NSDictionary , NSArray , NSNumber 这些不可变对象： 推荐这样写： 123NSArray *names = @[@&quot;Brian&quot;, @&quot;Matt&quot;, @&quot;Chris&quot;, @&quot;Alex&quot;, @&quot;Steve&quot;, @&quot;Paul&quot;];NSDictionary *productManagers = @&#123;@&quot;iPhone&quot; : @&quot;Kate&quot;, @&quot;iPad&quot; : @&quot;Kamal&quot;, @&quot;Mobile Web&quot; : @&quot;Bill&quot;&#125;; NSNumber *shouldUseLiterals = @YES;NSNumber *buildingZIPCode = @10018; 123NSArray *names = [NSArray arrayWithObjects:@&quot;Brian&quot;, @&quot;Matt&quot;, @&quot;Chris&quot;, @&quot;Alex&quot;, @&quot;Steve&quot;, @&quot;Paul&quot;, nil];NSDictionary *productManagers = [NSDictionary dictionaryWithObjectsAndKeys: @&quot;Kate&quot;, @&quot;iPhone&quot;, @&quot;Kamal&quot;, @&quot;iPad&quot;, @&quot;Bill&quot; ];NSNumber *shouldUseLiterals = [NSNumber numberWithBool:YES];NSNumber *buildingZIPCode = [NSNumber numberWithInteger:10018]; 属性 1. 属性的命名使用小驼峰推荐这样写： 1@property (nonatomic, readwrite, strong) UIButton *confirmButton; 2. 属性的关键字推荐按照 原子性，读写，内存管理的顺序排列推荐这样写： 123@property (nonatomic, readwrite, copy) NSString *name;@property (nonatomic, readonly, copy) NSString *gender;@property (nonatomic, readwrite, strong) UIView *headerView; Block属性应该使用copy关键字 推荐这样写： 12typedef void (^ErrorCodeBlock) (id errorCode,NSString *message);@property (nonatomic, readwrite, copy) ErrorCodeBlock errorBlock;//将block拷贝到堆中 4. 形容词性的BOOL属性的getter应该加上is前缀推荐这样写： 1@property (assign, getter=isEditable) BOOL editable; 5. 使用getter方法做懒加载实例化一个对象是需要耗费资源的，如果这个对象里的某个属性的实例化要调用很多配置和计算，就需要懒加载它，在使用它的前一刻对它进行实例化： 123456789- (NSDateFormatter *)dateFormatter &#123; if (!_dateFormatter) &#123; _dateFormatter = [[NSDateFormatter alloc] init]; NSLocale *enUSPOSIXLocale = [[NSLocale alloc] initWithLocaleIdentifier:@&quot;en_US_POSIX&quot;]; [_dateFormatter setLocale:enUSPOSIXLocale]; [_dateFormatter setDateFormat:@&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss.SSS&quot;]; &#125; return _dateFormatter;&#125; 但是也有对这种做法的争议：getter方法可能会产生某些副作用，例如如果它修改了全局变量，可能会产生难以排查的错误。 6. 除了init和dealloc方法，建议都使用点语法访问属性使用点语法的好处：setter： setter会遵守内存管理语义(strong, copy, weak)。 通过在内部设置断点，有助于调试bug。 可以过滤一些外部传入的值。 捕捉KVO通知。getter： 允许子类化。 通过在内部设置断点，有助于调试bug。 实现懒加载（lazy initialization）。 注意： 懒加载的属性，必须通过点语法来读取数据。因为懒加载是通过重写getter方法来初始化实例变量的，如果不通过属性来读取该实例变量，那么这个实例变量就永远不会被初始化。 在init和dealloc方法里面使用点语法的后果是：因为没有绕过setter和getter，在setter和getter里面可能会有很多其他的操作。而且如果它的子类重载了它的setter和getter方法，那么就可能导致该子类调用其他的方法。 7. 不要滥用点语法，要区分好方法调用和属性访问推荐这样写： 12view.backgroundColor = [UIColor orangeColor]; [UIApplication sharedApplication].delegate; 不推荐这样写： 12[view setBackgroundColor:[UIColor orangeColor]]; UIApplication.sharedApplication.delegate; 8. 尽量使用不可变对象建议尽量把对外公布出来的属性设置为只读，在实现文件内部设为读写。具体做法是： 在头文件中，设置对象属性为 在实现文件中设置为123456 这样一来，在外部就只能读取该数据，而不能修改它，使得这个类的实例所持有的数据更加安全。而且，对于集合类的对象，更应该仔细考虑是否可以将其设为可变的。 如果在公开部分只能设置其为只读属性，那么就在非公开部分存储一个可变型。所以当在外部获取这个属性时，获取的只是内部可变型的一个不可变版本, 例如： 在公共API中： @interface EOCPerson : NSObject @property (nonatomic, copy, readonly) NSString firstName;@property (nonatomic, copy, readonly) NSString lastName;@property (nonatomic, strong, readonly) NSSet *friends //向外公开的不可变集合 (id)initWithFirstName:(NSString)firstName andLastName:(NSString)lastName;(void)addFriend:(EOCPerson)person;(void)removeFriend:(EOCPerson)person;@end1234&gt;在这里，我们将friends属性设置为不可变的set。然后，提供了来增加和删除这个set里的元素的公共接口。在实现文件里： @interface EOCPerson () @property (nonatomic, copy, readwrite) NSString firstName;@property (nonatomic, copy, readwrite) NSString lastName; @end @implementation EOCPerson {NSMutableSet *_internalFriends; //实现文件里的可变集合} (NSSet*)friends { return [_internalFriends copy]; //get方法返回的永远是可变set的不可变型} 12##### 2. 方法实现时，如果参数过长，则令每个参数占用一行，以冒号对齐。 (void)doSomethingWith:(NSString *)theFoo rect:(CGRect)theRect interval:(CGFloat)theInterval { //Implementation} 12##### 3. 私有方法应该在实现文件中申明。 @interface ViewController () (void)basicConfiguration;@end@implementation ViewController (void)basicConfiguration{ //Do some basic configuration}@end 123##### 4. 方法名用小写字母开头的单词组合而成 (NSString *)descriptionWithLocale:(id)locale; 123456##### 5. 方法名前缀* 刷新视图的方法名要以refresh为首。* 更新数据的方法名要以update为首。推荐这样写： (void)refreshHeaderViewWithCount:(NSUInteger)count; (void)updateDataSourceWithViewModel:(ViewModel*)viewModel;123456789101112### 面向协议编程-------如果某些功能（方法）具备可复用性，我们就需要将它们抽取出来放入一个抽象接口文件中（在iOS中，抽象接口即协议），让不同类型的对象遵循这个协议，从而拥有相同的功能。因为协议是不依赖于某个对象的，所以通过协议，我们可以解开两个对象之间的耦合。如何理解呢？我们来看一下下面这个例子：现在有一个需求：在一个`UITableViewController`里面拉取feed并展示出来。#### 方案一：定义一个拉取feed的类ZOCFeedParser，这个类有一些代理方法实现feed相关功能： @protocol ZOCFeedParserDelegate @optional (void)feedParserDidStart:(ZOCFeedParser *)parser; (void)feedParser:(ZOCFeedParser )parser didParseFeedInfo:(ZOCFeedInfoDTO )info; (void)feedParser:(ZOCFeedParser )parser didParseFeedItem:(ZOCFeedItemDTO )item; (void)feedParserDidFinish:(ZOCFeedParser *)parser; (void)feedParser:(ZOCFeedParser )parser didFailWithError:(NSError )error;@end@interface ZOCFeedParser : NSObject@property (nonatomic, weak) id delegate;@property (nonatomic, strong) NSURL *url; (id)initWithURL:(NSURL *)url; (BOOL)start; (void)stop;@end1然后在ZOCTableViewController里面传入ZOCFeedParser，并遵循其代理方法，实现feed的拉取功能。 @interface ZOCTableViewController : UITableViewController (instancetype)initWithFeedParser:(ZOCFeedParser *)feedParser;@end1然后在ZOCTableViewController里面传入ZOCFeedParser，并遵循其代理方法，实现feed的拉取功能。 @interface ZOCTableViewController : UITableViewController (instancetype)initWithFeedParser:(ZOCFeedParser *)feedParser;@end12具体应用： NSURL feedURL = [NSURL URLWithString:@”http://bbc.co.uk/feed.rss“];ZOCFeedParser feedParser = [[ZOCFeedParser alloc] initWithURL:feedURL];ZOCTableViewController *tableViewController = [[ZOCTableViewController alloc] initWithFeedParser:feedParser];feedParser.delegate = tableViewController;1234567OK，现在我们实现了需求：在`ZOCTableViewController`里面存放了一个`ZOCFeedParser`对象来处理feed的拉取功能。于是我们重新审视一下这个需求：其实我们实际上只需要`ZOCTableViewController`拉取feed就可以了，而具体是由哪个对象来拉取，`ZOCTableViewController`并不需要关心。也就是说，我们需要提供给`ZOCTableViewController`的是一个更范型的对象，这个对象具备了拉取feed的功能就好了，而不应该仅仅局限于某个具体的对象（`ZOCFeedParser`）。所以，刚才的设计需要重新做一次修改：#### 方案二：首先需要在一个接口文件`ZOCFeedParserProtocol.h`里面定义抽象的，具有拉取feed功能的协议： @protocol ZOCFeedParserDelegate @optional (void)feedParserDidStart:(id)parser; (void)feedParser:(id)parser didParseFeedInfo:(ZOCFeedInfoDTO *)info; (void)feedParser:(id)parser didParseFeedItem:(ZOCFeedItemDTO *)item; (void)feedParserDidFinish:(id)parser; (void)feedParser:(id)parser didFailWithError:(NSError )error;@end@protocol ZOCFeedParserProtocol @property (nonatomic, weak) id delegate;@property (nonatomic, strong) NSURL url; (BOOL)start; (void)stop;@end1而原来的`ZOCFeedParser`仅仅是需要遵循上面这个协议就具备了拉取feed的功能 @interface ZOCFeedParser : NSObject (id)initWithURL:(NSURL *)url;//仅仅需要通过传入url即可，其他事情都交给ZOCFeedParserProtocol@end1而且，`ZOCTableViewController`也不直接依赖于`ZOCFeedParser`对象，我们只需要传给它一个遵循`&lt;ZOCFeedParserProtocol&gt;`的对象即可。 @interface ZOCTableViewController : UITableViewController (instancetype)initWithFeedParser:(id)feedParser;@end 123456789101112131415这样一来，`ZOCTableViewController`和`wController`和`之间就没有直接的关系了。以后，如果我们想：* 给这个feed拉取器增加新的功能：仅需要修改`ZOCFeedParserProtocol.h`文件。* 更换一个feed拉取器实例：创建一个新类型来遵循`ZOCFeedParserProtocol.h`即可。### iOS 中委托的设计-------#### 1. 要区分好代理和数据源的区别在iOS开发中的委托模式包含了delegate（代理）和datasource（数据源）。虽然二者同属于委托模式，但是这两者是有区别的。这个区别就是二者的信息流方向是不同的：* delegate ：事件发生的时候，委托者需要通知代理。（信息流从委托者到代理）* datasource：委托者需要从数据源拉取数据。（信息流从数据源到委托者）然而包括苹果也没有做好榜样，将它们彻底的区分开。就拿UITableView来说，在它的delegate方法中有一个方法： (void)tableView:(UITableView )tableView didSelectRowAtIndexPath:(NSIndexPath )indexPath; 12这个方法正确地体现了代理的作用：委托者（tableview）告诉代理（控制器）“我的某个cell被点击了”。但是，UITableViewDelegate的方法列表里还有这个方法： (CGFloat)tableView:(UITableView )tableView heightForRowAtIndexPath:(NSIndexPath )indexPath 1234该方法的作用是 由控制器来告诉tabievlew的行高，也就是说，它的信息流是从控制器（数据源）到委托者（tableview）的。准确来讲，它应该是一个数据源方法，而不是代理方法。在UITableViewDataSource中，就有标准的数据源方法： (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView; 1234567这个方法的作用就是让tableview向控制器拉取一个section数量的数据。所以，在我们设计一个视图控件的代理和数据源时，一定要区分好二者的区别，合理地划分哪些方法属于代理方法，哪些方法属于数据源方法。#### 2. 代理方法的第一个参数必须为委托者代理方法必须以委托者作为第一个参数（参考UITableViewDelegate）的方法。其目的是为了区分不同委托着的实例。因为同一个控制器是可以作为多个tableview的代理的。若要区分到底是哪个tableview的cell被点击了，就需要在 (void)tableView:(UITableView )tableView didSelectRowAtIndexPath:(NSIndexPath )indexPath``方法中做个区分。123##### 向代理发送消息时需要判断其是否实现该方法最后，在委托着向代理发送消息的时候，需要判断委托着是否实现了这个代理方法: if ([self.delegate respondsToSelector:@selector(signUpViewControllerDidPressSignUpButton:)]) { [self.delegate signUpViewControllerDidPressSignUpButton:self];}1#### 3. 遵循代理过多的时候，换行对齐显示 @interface ShopViewController () 12#### 4. 代理的方法需要明确必须执行和可不执行代理方法在默认情况下都是必须执行的，然而在设计一组代理方法的时候，有些方法可以不是必须执行（是因为存在默认配置），这些方法就需要使用@optional关键字来修饰： @protocol ZOCServiceDelegate @optional- (void)generalService:(ZOCGeneralService )service didRetrieveEntries:(NSArray )entries;@end123456### 类-------#### 1. 类的名称应该以三个大写字母为前缀；创建子类的时候，应该把代表子类特点的部分放在前缀和父类名的中间推荐这样写： //父类ZOCSalesListViewController//子类ZOCDaySalesListViewControllerZOCMonthSalesListViewController1234567891011#### 2. initializer &amp;&amp; dealloc推荐：* 将 dealloc 方法放在实现文件的最前面* 将init方法放在dealloc方法后面。如果有多个初始化方法，应该将指定初始化方法放在最前面，其他初始化方法放在其后。##### 2.1 dealloc方法里面应该直接访问实例变量，不应该用点语法访问##### 2.2 init方法的写法：* init方法返回类型必须是instancetype，不能是id。* 必须先实现[super init]。 (instancetype)init { self = [super init]; // call the designated initializer if (self) { // Custom initialization } return self;}1234##### 2.3 指定初始化方法指定初始化方法(designated initializer)是提供所有的（最多的）参数的初始化方法，间接初始化方法(secondary initializer)有一个或部分参数的初始化方法。注意事项1：间接初始化方法必须调用指定初始化方法。 @implementation ZOCEvent//指定初始化方法 (instancetype)initWithTitle:(NSString )title date:(NSDate )datelocation:(CLLocation *)location{ self = [super init]; if (self) { _title = title; _date = date; _location = location; } return self;}//间接初始化方法 (instancetype)initWithTitle:(NSString )title date:(NSDate )date{ return [self initWithTitle:title date:date location:nil];}//间接初始化方法 (instancetype)initWithTitle:(NSString *)title{ return [self initWithTitle:title date:[NSDate date] location:nil];}@end 12注意事项2：如果直接父类有指定初始化方法，则必须调用其指定初始化方法 (id)initWithNibName:(NSString )nibNameOrNil bundle:(NSBundle )nibBundleOrNil { self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil]; if (self) { } return self;} 12345678注意事项3：如果想在当前类自定义一个新的全能初始化方法，则需要如下几个步骤1. 定义新的指定初始化方法，并确保调用了直接父类的初始化方法。2. 重载直接父类的初始化方法，在内部调用新定义的指定初始化方法。3. 为新的指定初始化方法写文档。看一个标准的例子： @implementation ZOCNewsViewController//新的指定初始化方法 (id)initWithNews:(ZOCNews *)news { self = [super initWithNibName:nil bundle:nil]; if (self) {_news = news; } return self;}// 重载父类的初始化方法 (id)initWithNibName:(NSString )nibNameOrNil bundle:(NSBundle )nibBundleOrNil{ return [self initWithNews:nil];}@end123456789101112在这里，重载父类的初始化方法并在内部调用新定义的指定初始化方法的原因是你不能确定调用者调用的就一定是你定义的这个新的指定初始化方法，而不是原来从父类继承来的指定初始化方法。假设你没有重载父类的指定初始化方法，而调用者却恰恰调用了父类的初始化方法。那么调用者可能永远都调用不到你自己定义的新指定初始化方法了。而如果你成功定义了一个新的指定初始化方法并能保证调用者一定能调用它，你最好要在文档中明确写出哪一个才是你定义的新初始化方法。或者你也可以使用编译器指令`__attribute__((objc_designated_initializer))`来标记它。#### 3. 所有返回类对象和实例对象的方法都应该使用instancetype将instancetype关键字作为返回值的时候，可以让编译器进行类型检查，同时适用于子类的检查，这样就保证了返回类型的正确性（一定为当前的类对象或实例对象）推荐这样写： @interface ZOCPerson (instancetype)personWithName:(NSString *)name;@end1不推荐这样写： @interface ZOCPerson (id)personWithName:(NSString *)name;@end1234#### 4. 在类的头文件中尽量少引用其他头文件有时，类A需要将类B的实例变量作为它公共API的属性。这个时候，我们不应该引入类B的头文件，而应该使用向前声明（forward declaring）使用class关键字，并且在A的实现文件引用B的头文件。 // EOCPerson.h #import @class EOCEmployer;@interface EOCPerson : NSObject@property (nonatomic, copy) NSString firstName;@property (nonatomic, copy) NSString lastName;@property (nonatomic, strong) EOCEmployer *employer;//将EOCEmployer作为属性@end// EOCPerson.m #import “EOCEmployer.h”12345678910111213这样做有什么优点呢：&gt; * 不在A的头文件中引入B的头文件，就不会一并引入B的全部内容，这样就减少了编译时间。&gt; * 可以避免循环引用：因为如果两个类在自己的头文件中都引入了对方的头文件，那么就会导致其中一个类无法被正确编译。但是个别的时候，必须在头文件中引入其他类的头文件: &gt; 主要有两种情况：&gt; 1. 该类继承于某个类，则应该引入父类的头文件。&gt; 2. 该类遵从某个协议，则应该引入该协议的头文件。而且最好将协议单独放在一个头文件中。#### 5. 类的布局 #pragma mark - Life Cycle Methods (instancetype)init (void)dealloc (void)viewWillAppear:(BOOL)animated (void)viewDidAppear:(BOOL)animated (void)viewWillDisappear:(BOOL)animated (void)viewDidDisappear:(BOOL)animated#pragma mark - Override Methods#pragma mark - Intial Methods#pragma mark - Network Methods#pragma mark - Target Methods#pragma mark - Public Methods#pragma mark - Private Methods#pragma mark - UITableViewDataSource#pragma mark - UITableViewDelegate#pragma mark - Lazy Loads#pragma mark - NSCopying#pragma mark - NSObject Methods1234567### 分类-------#### 1. 分类添加的方法需要添加前缀和下划线推荐这样写： @interface NSDate (ZOCTimeExtensions) (NSString *)zoc_timeAgoShort;@end12不推荐这样写： @interface NSDate (ZOCTimeExtensions) (NSString *)zoc_timeAgoShort;@end12345678#### 2. 把类的实现代码分散到便于管理的多个分类中一个类可能会有很多公共方法，而且这些方法往往可以用某种特有的逻辑来分组。我们可以利用Objecctive-C的分类机制，将类的这些方法按一定的逻辑划入几个分区中。举个🌰：先看一个没有使用无分类的类： #import @interface EOCPerson : NSObject@property (nonatomic, copy, readonly) NSString firstName;@property (nonatomic, copy, readonly) NSString lastName;@property (nonatomic, strong, readonly) NSArray *friends; (id)initWithFirstName:(NSString)firstName andLastName:(NSString)lastName;/ Friendship methods / (void)addFriend:(EOCPerson*)person; (void)removeFriend:(EOCPerson*)person; (BOOL)isFriendsWith:(EOCPerson)person;/ Work methods */ (void)performDaysWork; (void)takeVacationFromWork;/ Play methods / (void)goToTheCinema; (void)goToSportsGame;@end12分类之后： #import @interface EOCPerson : NSObject@property (nonatomic, copy, readonly) NSString firstName;@property (nonatomic, copy, readonly) NSString lastName;@property (nonatomic, strong, readonly) NSArray *friends; (id)initWithFirstName:(NSString)firstNameandLastName:(NSString)lastName;@end@interface EOCPerson (Friendship) (void)addFriend:(EOCPerson*)person; (void)removeFriend:(EOCPerson*)person; (BOOL)isFriendsWith:(EOCPerson*)person;@end@interface EOCPerson (Work) (void)performDaysWork; (void)takeVacationFromWork;@end@interface EOCPerson (Play) (void)goToTheCinema; (void)goToSportsGame;@end12其中，FriendShip分类的实现代码可以这么写： // EOCPerson+Friendship.h #import “EOCPerson.h”@interface EOCPerson (Friendship) (void)addFriend:(EOCPerson*)person; (void)removeFriend:(EOCPerson*)person; (BOOL)isFriendsWith:(EOCPerson*)person;@end// EOCPerson+Friendship.m#import “EOCPerson+Friendship.h”@implementation EOCPerson (Friendship) (void)addFriend:(EOCPerson)person {/ … */} (void)removeFriend:(EOCPerson)person {/ … */} (BOOL)isFriendsWith:(EOCPerson)person {/ … */}@end1234567891011121314151617&gt; 注意：在新建分类文件时，一定要引入被分类的类文件。通过分类机制，可以把类代码分成很多个易于管理的功能区，同时也便于调试。因为分类的方法名称会包含分类的名称，可以马上看到该方法属于哪个分类中。利用这一点，我们可以创建名为Private的分类，将所有私有方法都放在该类里。这样一来，我们就可以根据private一词的出现位置来判断调用的合理性，这也是一种编写“自我描述式代码（self-documenting）”的办法。### 单例-------#### 1. 单例不能作为容器对象来使用单例对象不应该暴露出任何属性，也就是说它不能作为让外部存放对象的容器。它应该是一个处理某些特定任务的工具，比如在iOS中的GPS和加速度传感器。我们只能从他们那里得到一些特定的数据。#### 2. 使用dispatch_once来生成单例推荐这样写： (instancetype)sharedInstance {static id sharedInstance = nil;static dispatch_once_t onceToken = 0; dispatch_once(&amp;onceToken, ^{ sharedInstance = [[self alloc] init];});return sharedInstance;} 12不推荐这样写： (instancetype)sharedInstance {static id sharedInstance;@synchronized(self) {if (sharedInstance == nil) { sharedInstance = [[MyClass alloc] init];} }return sharedInstance;} 12345### 相等性的判断-------判断两个person类是否相等的合理做法： (BOOL)isEqual:(id)object { if (self == object) { return YES; //判断内存地址}if (![object isKindOfClass:[ZOCPerson class]]) { return NO; //是否为当前类或派生类 }return [self isEqualToPerson:(ZOCPerson *)object]; }//自定义的判断相等性的方法 (BOOL)isEqualToPerson:(Person *)person { if (!person) { return NO; } BOOL namesMatch = (!self.name &amp;&amp; !person.name) || [self.name isEqualToString:person.name]; BOOL birthdaysMatch = (!self.birthday &amp;&amp; !person.birthday) || [self.birthday isEqualToDate:person.birthday]; return haveEqualNames &amp;&amp; haveEqualBirthdays;}12345678910111213141516171819### 方法文档-------一个函数(方法)必须有一个字符串文档来解释，除非它：* 非公开，私有函数。* 很短。* 显而易见。 而其余的，包括公开接口，重要的方法，分类，以及协议，都应该伴随文档（注释）：* 以/开始* 第二行识总结性的语句* 第三行永远是空行* 在与第二行开头对齐的位置写剩下的注释。建议这样写： /This comment serves to demonstrate the format of a doc string.Note that the summary line is always at most one line long, and after the opening block comment,and each line of text is preceded by a single space.*/12看一个指定初始化方法的注释： / Designated initializer. * @param store The store for CRUD operations. @param searchService The search service used to query the store. @return A ZOCCRUDOperationsStore object.*/ (instancetype)initWithOperationsStore:(id)store searchService:(id)searchService;1234567### 多用队列，少用同步锁来避免资源抢夺-------多个线程执行同一份代码时，很可能会造成数据不同步。建议使用GCD来为代码加锁的方式解决这个问题。#### 方案一：使用串行同步队列来将读写操作都安排到同一个队列里： _syncQueue = dispatch_queue_create(“com.effectiveobjectivec.syncQueue”, NULL);//读取字符串 (NSString*)someString { __block NSString *localSomeString; dispatch_sync(_syncQueue, ^{ localSomeString = _someString; }); return localSomeString; }//设置字符串 (void)setSomeString:(NSString*)someString { dispatch_sync(_syncQueue, ^{_someString = someString; });}123456这样一来，读写操作都在串行队列进行，就不容易出错。但是，还有一种方法可以让性能更高：#### 方案二：将写操作放入栅栏快中，让他们单独执行；将读取操作并发执行。 _syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);//读取字符串 (NSString)someString { __block NSString localSomeString; dispatch_sync(_syncQueue, ^{localSomeString = _someString; }); return localSomeString;}12 //设置字符串 (void)setSomeString:(NSString*)someString { dispatch_barrier_async(_syncQueue, ^{ _someString = someString; });} 12345678910111213显然，数据的正确性主要取决于写入操作，那么只要保证写入时，线程是安全的，那么即便读取操作是并发的，也可以保证数据是同步的。这里的`dispatch_barrier_async`方法使得操作放在了同步队列里“有序进行”，保证了写入操作的任务是在串行队列里。### 实现description方法打印自定义对象信息-------在打印我们自己定义的类的实例对象时，在控制台输出的结果往往是这样的：`object = &lt;EOCPerson: 0x7fd9a1600600&gt;`这里只包含了类名和内存地址，它的信息显然是不具体的,远达不到调试的要求。但是！如果在我们自己定义的类覆写description方法，我们就可以在打印这个类的实例时输出我们想要的信息。例如： (NSString*)description { return [NSString stringWithFormat:@”&lt;%@: %p, %@ %@&gt;”, [self class], self, firstName, lastName];} 1234在这里，显示了内存地址，还有该类的所有属性。而且，如果我们将这些属性值放在字典里打印，则更具有可读性： (NSString*)description { return [NSString stringWithFormat:@”&lt;%@: %p, %@&gt;”,[self class],self, @{ @”title”:_title, @&quot;latitude&quot;:@(_latitude), @&quot;longitude&quot;:@(_longitude)} ];} 12输出结果： location = 12345678910111213141516171819202122232425262728293031我们可以看到，通过重写`description`方法可以让我们更加了解对象的情况，便于后期的调试，节省开发时间。### NSArray&amp; NSMutableArray-------#### 1. addObject之前要非空判断。#### 2. 取下标的时候要判断是否越界。#### 3. 取第一个元素或最后一个元素的时候使用firtstObject和lastObject### NSCache-------#### 1. 构建缓存时选用NSCache 而非NSDictionary如果我们缓存使用得当，那么应用程序的响应速度就会提高。只有那种“重新计算起来很费事的数据，才值得放入缓存”，比如那些需要从网络获取或从磁盘读取的数据。在构建缓存的时候很多人习惯用NSDictionary或者NSMutableDictionary，但是作者建议大家使用NSCache，它作为管理缓存的类，有很多特点要优于字典，因为它本来就是为了管理缓存而设计的。#### 2. NSCache优于NSDictionary的几点：* 当系统资源将要耗尽时，NSCache具备自动删减缓冲的功能。并且还会先删减“最久未使用”的对象。* NSCache不拷贝键，而是保留键。因为并不是所有的键都遵从拷贝协议（字典的键是必须要支持拷贝协议的，有局限性）。* NSCache是线程安全的：不编写加锁代码的前提下，多个线程可以同时访问NSCache。### NSNotification-------#### 1. 通知的名称建议将通知的名字作为常量，保存在一个专门的类中： // Const.hextern NSString const ZOCFooDidBecomeBarNotification// Const.mNSString const ZOCFooDidBecomeBarNotification = @”ZOCFooDidBecomeBarNotification”;1234567891011#### 2. 通知的移除通知必须要在对象销毁之前移除掉。### 其他-------#### 1. Xcode工程文件的物理路径要和逻辑路径保持一致。#### 2. 忽略没有使用变量的编译警告对于某些暂时不用，以后可能用到的临时变量，为了避免警告，我们可以使用如下方法将这个警告消除： (NSInteger)giveMeFive {NSString *foo;#pragma unused (foo)return 5;} 1234#### 3. 手动标明警告和错误手动明确一个错误： (NSInteger)divide:(NSInteger)dividend by:(NSInteger)divisor {#error Whoa, buddy, you need to check for zero here!return (dividend / divisor);} 1手动明确一个警告： (float)divide:(float)dividend by:(float)divisor {#warning Dude, don’t compare floating point numbers like this!if (divisor != 0.0) {return (dividend / divisor);} else { return NAN;}}``` 参考文献： 王垠：编程的智慧 美团点评技术团队：聊聊clean code 禅与 Objective-C 编程艺术 J_Knight 的文集：iOS - 《Effective Objective-C 2.0》 蝴蝶之梦天使：iOS代码编程规范-根据项目经验汇总 高家二少爷：Objective-C高质量代码参考规范 J_Knight 的文集：iOS 代码规范]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub Pages + Hexo搭建博客]]></title>
    <url>%2F2018%2F03%2F15%2Fhexo%2FGitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[GitHub Pages + Hexo搭建博客一、 前言这是一篇是单纯地利用GitHub Pages搭建自己独立博客的过程，并没有额外使用独立域名之类的。 如果是小小白，可以先花时间去了解下： Git GitHub GitHub Pages Hexo Markdown 二、 必要配置2.1 GitHub Pages 仓库2.1.1 创建对应仓库在自己的GitHub账号下创建一个新的仓库，命名为username.github.io（username是你的账号名)。 在这里，要知道，GitHub Pages有两种类型：User/Organization Pages 和 Project Pages，而我所使用的是User Pages。 简单来说，User Pages 与 Project Pages的区别是： User Pages 是用来展示用户的，而 Project Pages 是用来展示项目的。 用于存放 User Pages 的仓库必须使用username.github.io的命名规则，而 Project Pages 则没有特殊的要求。 User Pages 将使用仓库的 master 分支，而 Project Pages 将使用 gh-pages 分支。 User Pages 通过 http(s)://username.github.io 进行访问，而 Projects Pages通过 http(s)://username.github.io/projectname 进行访问。 2.1.2 相关资料 GitHub Pages Basics / User, Organization, and Project Pages 2.2 Git2.2.1 安装 Git在windows下安装git比较常用的有两种方式： Git 官方版本的安装 GitHub for Windows 2.2.2 配置 Git当安装完Git应该做的第一件事情就是设置用户名称和邮件地址。这样做很重要，因为每一个Git的提交都会使用这些信息，并且它会写入你的每一次提交中，不可更改： 12$ git config --global user.name &quot;username&quot;$ git config --global user.email &quot;username@example.com&quot; 对于user.email，因为在GitHub的commits信息上是可见的，所以如果你不想让人知道你的email，可以Keeping your email address private: 在GitHub右上方点击你的头像，选择”Settings”； 在右边的”Personal settings”侧边栏选择”Emails”； 选择”Keep my email address private”。 这样，你就可以使用如下格式的email进行配置： 1$ git config --global user.email &quot;username@users.noreply.github.com&quot; 2.2.3 相关资料 安装 Git 配置 Git Setting your email in Git Keeping your email address private 2.3 Git 与 GitHub2.3.1 git与github的区别这里，我们要区分清楚git与github。 git是一个版本控制的工具，而github有点类似于远程仓库，用于存放用git管理的各种项目。 2.3.2 与github建立联系为了能够在本地使用git管理github上的项目，需要进行一些配置，这里介绍SSH的方法。 2.3.2.1 检查电脑是否已经有SSH KEYS。12$ ls -al ~/.ssh# Lists the files in your .ssh directory, if they exist 默认情况下，public keys的文件名是以下的格式之一：id_dsa.pub、id_ecdsa.pub、id_ed25519.pub、id_rsa.pub。因此，如果列出的文件有public和private钥匙对（例如id_ras.pub和id_rsa），证明已存在SSH keys。 2.3.2.2 如果没有SSH KEY，则生成新的SSH KEY。12$ ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;# Creates a new ssh key, using the provided email as a label 之后一路回车即可。 2.3.2.3 向SSH-AGENT添加KEY。首先确保ssh-agent可运行： 12# start the ssh-agent in the background$ ssh-agent -s 然后添加SSH key： 1$ ssh-add ~/.ssh/id_rsa 2.3.2.4 在GITHUB添加SSH KEY。首先，拷贝key： 12clip &lt; ~/.ssh/id_rsa.pub# Copies the contents of the id_rsa.pub file to your cllipboard 然后，在GitHub右上方点击头像，选择”Settings”，在右边的”Personal settings”侧边栏选择”SSH Keys”。接着粘贴key，点击”Add key”按钮。最后，测试链接： 12$ ssh -T git@github.com# Attempts to ssh to GitHub 如果你看到： 123The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 就键入：yes。之后将会看到如下信息： 12Hi username! You&apos;ve successfully authenticated, but GitHub does notprovide shell access. 2.3.3 相关资料 Generating SSH keys 2.4 Hexo2.4.1 安装Hexo安装Hexo相当简单。在安装之前，必须检查电脑中是否已经安装下列应用程序： Node.js Git 如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。 1$ npm install -g hexo-cli 2.4.2 使用Hexo建站安装完后，在你喜欢的文件夹内（例如D：\Hexo），点击鼠标右键选择Git bash，输入以下指令： 1$ hexo init 该命令会在目标文件夹内建立网站所需要的所有文件。接下来是安装依赖包： 1$ npm install 这样，我们就已经搭建起本地的Hexo博客了。可以先执行以下命令（在对应文件夹下），然后再浏览器输入localhost:4000查看。 12$ hexo generate$ hexo server 这个博客只是本地的，别人是浏览不了的，之后需要部署到GitHub上。 2.4.3 相关资料 Hexo 官方文档 三、一般的搭建方法在上面，我们已经配置好了所需的所有东西，也成功地搭建了一个本地Hexo博客。现在，需要使用GitHub Pages搭建一个别人能够访问的Hexo博客了。 3.1 使用默认theme我们继续使用上面的文件夹D:\Hexo（也可以新建一个文件夹重新生成），然后编辑该文件夹下的_config.yml。 默认生成的_config.yml： 1234# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy: type: 修改后的_config.yml： 1234deploy: type: git repo: 对应仓库的SSH地址（可以在GitHub对应的仓库中复制） branch: 分支（User Pages为master，Project Pages为gh-pages） 为了能够使Hexo部署到GitHub上，需要安装一个插件： 1$ npm install hexo-deployer-git --save 然后，执行下列指令即可完成部署： 12$ hexo generate$ hexo deploy 之后，可以通过在浏览器键入：username.github.io进行浏览，开心吧~ 3.2 其他theme如果想要使用其他主题，可以使用git clone将别人的主题拷贝到D:\Hexo\themes下，然后将_config.yml中的theme: landscape改为对应的主题名字。 下面是next主题的个性化配置教程: next个性化配置教程 四、 优化部署与管理4.1 概述Hexo部署到GitHub上的文件，是.md（你的博文）转化之后的.html（静态网页）。因此，当你重装电脑或者想在不同电脑上修改博客时，就不可能了（除非你自己写html o(^▽^)o ）。 其实，Hexo生成的网站文件中有.gitignore文件，因此它的本意也是想我们将Hexo生成的网站文件存放到GitHub上进行管理的（而不是用U盘或者云备份啦(╬▔皿▔)凸）。这样，不仅解决了上述的问题，还可以通过git的版本控制追踪你的博文的修改过程，是极赞的。 但是，如果每一个GitHub Pages都需要创建一个额外的仓库来存放Hexo网站文件，我感觉很麻烦（10个项目需要20个仓库(ˉ▽ˉ)…）。 所以，我利用了分支！！！ 简单地说，每个想建立GitHub Pages的仓库，起码有两个分支，一个用来存放Hexo网站的文件，一个用来发布网站。 下面以我的博客作为例子详细地讲述。 4.2 我的博客搭建流程 创建仓库，liuxc123.github.io； 创建两个分支：master 与 hexo； 设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）； 使用git clone git@github.com:liuxc123/liuxc123.github.io.git拷贝仓库； 修改_config.yml中的deploy参数，分支应为master； 依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件； 执行hexo generate -d生成网站并部署到GitHub上。 这样一来，在GitHub上的CrazyMilk.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。完美( •̀ ω •́ )y！ 4.3 我的博客管理流程4.3.1 日常修改在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理： 依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）； 然后才执行hexo generate -d发布网站到master分支上。 虽然两个过程顺序调转一般不会有问题，不过逻辑上这样的顺序是绝对没问题的（例如突然死机要重装了，悲催….的情况，调转顺序就有问题了）。 4.3.2 本地资料丢失当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤： 使用git clone git@github.com:liuxc123/liuxc123.github.io.git拷贝仓库（默认分支为hexo）； 在本地新拷贝的liuxc123.github.io文件夹下通过Git bash依次执行下列指令：npm install hexo、npm install、npm install hexo-deployer-git（记得，不需要hexo init这条指令）。 ###五、结尾ok,现在你就可以轻松的搭建自己的博客了。(ˉ▽ˉ)]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
